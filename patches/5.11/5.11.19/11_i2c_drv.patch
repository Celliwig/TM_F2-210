From 79ef9593874fb883b5ff3b6d834eccd967ea8e93 Mon Sep 17 00:00:00 2001
From: Celliwig <celliwig@nym.hush.com>
Date: Sat, 8 May 2021 11:29:25 +0100
Subject: Added i2c driver.

---
 drivers/i2c/busses/Kconfig         |   11 +
 drivers/i2c/busses/Makefile        |    2 +
 drivers/i2c/busses/i2c-rtk-core.c  |  412 ++++++++
 drivers/i2c/busses/i2c-rtk-priv.c  | 1393 ++++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-rtk-priv.h  |  323 +++++++
 drivers/i2c/busses/i2c-rtk.h       |  166 ++++
 include/soc/realtek/rtk_platform.h |  318 +++++++
 7 files changed, 2625 insertions(+)
 create mode 100755 drivers/i2c/busses/i2c-rtk-core.c
 create mode 100755 drivers/i2c/busses/i2c-rtk-priv.c
 create mode 100755 drivers/i2c/busses/i2c-rtk-priv.h
 create mode 100755 drivers/i2c/busses/i2c-rtk.h
 create mode 100644 include/soc/realtek/rtk_platform.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index ab1f39ac3..be0e6e48c 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -1421,4 +1421,15 @@ config I2C_FSI
 	  This driver can also be built as a module. If so, the module will be
 	  called as i2c-fsi.
 
+config I2C_RTK
+	tristate "Realtek I2C"
+	depends on (ARCH_RTD129x && I2C)
+	default ARCH_RTD129x
+	help
+	  This driver supports I2C Controller on Realtek SoC
+
+config I2C_RTK_SECURE_ACCESS
+	bool
+	depends on HAVE_ARM_SMCCC
+
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 683c49fac..e09dcd0e4 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -148,5 +148,7 @@ obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
 obj-$(CONFIG_I2C_XGENE_SLIMPRO) += i2c-xgene-slimpro.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_I2C_FSI)		+= i2c-fsi.o
+obj-$(CONFIG_I2C_RTK)		+= i2c-rtk.o
+i2c-rtk-objs			:= i2c-rtk-core.o i2c-rtk-priv.o
 
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff --git a/drivers/i2c/busses/i2c-rtk-core.c b/drivers/i2c/busses/i2c-rtk-core.c
new file mode 100755
index 000000000..3d3856148
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rtk-core.c
@@ -0,0 +1,412 @@
+/*
+ * Realtek I2C driver
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+
+#include "i2c-rtk-priv.h"
+
+#include <linux/pinctrl/consumer.h>
+
+
+#define RTK_MASTER_7BIT_ADDR  0x24
+#define IsReadMsg(x) (x.flags & I2C_M_RD)
+#define IsSameTarget(x, y) \
+((x.addr == y.addr) && !((x.flags ^ y.flags) & (~I2C_M_RD)))
+
+struct rtk_i2c_dev {
+	struct device *dev;
+	struct i2c_adapter adapter;
+	struct clk *div_clk;
+	void __iomem *base;
+	unsigned int id;
+	bool is_suspended;
+	u32 bus_clk_rate;
+	int cont_id;
+	int irq;
+	int is_dvc;
+	struct rtk_i2c_reg_map reg_map;
+	struct rtk_i2c_handler *handler;
+};
+
+void i2c_rtk_dump_msg(const struct i2c_msg *p_msg)
+{
+	RTK_DEBUG("%s\n", __func__);
+	pr_info("msg->addr  = %02x\n", p_msg->addr);
+	pr_info("msg->flags = %04x\n", p_msg->flags);
+	pr_info("msg->len   = %d\n", p_msg->len);
+	pr_info("msg->buf   = %p\n", p_msg->buf);
+}
+
+static u32 rtk_i2c_func(struct i2c_adapter *adap)
+{
+	u32 ret = I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
+		I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;
+
+	return ret;
+}
+
+static int  i2c_rtk_xfer(struct i2c_adapter *adap,
+	struct i2c_msg msgs[], int num)
+{
+	struct rtk_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
+	struct rtk_i2c_handler *handler = i2c_dev->handler;
+	int i = 0;
+	int ret = 0;
+	struct pinctrl *pctrl;
+	struct pinctrl_state *pctrl_state;
+
+	RTK_DEBUG("%s\n", __func__);
+
+#ifdef CONFIG_ARCH_RTD16xx
+	if (handler->id == 0) {
+		pctrl = devm_pinctrl_get(i2c_dev->dev);
+		pctrl_state = pinctrl_lookup_state(pctrl, "default");
+		pinctrl_select_state(pctrl, pctrl_state);
+	}
+#endif
+
+#ifdef EDID_4BLOCK_SUPPORT
+	if (handler->id == 1 && num == 3) {
+		if (msgs[0].addr == 0x30 && msgs[1].addr == 0x50) {
+			ret = handler->read_edid_seg(handler, msgs[0].buf[0],
+				msgs[1].buf[0], msgs[2].buf, msgs[2].len);
+
+			if (ret < 0)
+				goto err_occur;
+			else
+				return 3;
+		}
+	}
+#endif
+
+	for (i = 0; i < num; i++) {
+		ret = handler->set_tar(handler, msgs[i].addr, ADDR_MODE_7BITS);
+		if (ret < 0)
+			goto err_occur;
+
+		switch (msgs[i].flags & I2C_M_SPEED_MASK) {
+		case I2C_M_FAST_SPEED:
+			handler->set_spd(handler, 400);
+			break;
+		case I2C_M_HIGH_SPEED:
+#ifdef CONFIG_ARCH_RTD16xx
+			if (handler->id == 0) {
+				pctrl_state = pinctrl_lookup_state(pctrl, "high_speed");
+				pinctrl_select_state(pctrl, pctrl_state);
+				handler->set_spd(handler, 3400);
+			}
+#else
+			handler->set_spd(handler, 800);
+#endif
+			break;
+		case I2C_M_LOW_SPEED:
+			handler->set_spd(handler, 50);
+			break;
+		case I2C_M_LOW_SPEED_80:
+			handler->set_spd(handler, 80);
+			break;
+		case I2C_M_LOW_SPEED_66:
+			handler->set_spd(handler, 66);
+			break;
+		case I2C_M_LOW_SPEED_33:
+			handler->set_spd(handler, 33);
+			break;
+		case I2C_M_LOW_SPEED_10:
+			handler->set_spd(handler, 10);
+			break;
+		default:
+		case I2C_M_NORMAL_SPEED:
+			handler->set_spd(handler, 100);
+			break;
+		}
+
+		handler->set_guard_interval(handler,
+			(msgs[i].flags & I2C_M_NO_GUARD_TIME) ? 0 : 1000);
+
+		if (IsReadMsg(msgs[i])) {
+			ret = handler->read(handler, NULL, 0, msgs[i].buf,
+				msgs[i].len);
+		} else {
+			if ((i < (num-1)) && IsReadMsg(msgs[i+1]) &&
+				IsSameTarget(msgs[i], msgs[i+1])) {
+				/* Random Read = Write + Read (same addr) */
+				ret = handler->read(handler,
+					msgs[i].buf, msgs[i].len,
+					msgs[i+1].buf, msgs[i+1].len);
+				i++;
+			} else {
+				/* Single Write */
+				ret = handler->write(handler,
+					msgs[i].buf, msgs[i].len,
+					(i == (num-1)) ? WAIT_STOP : NON_STOP);
+			}
+		}
+
+		if (ret < 0)
+			goto err_occur;
+	}
+
+	return i;
+
+err_occur:
+
+	switch (ret) {
+	case -ECMDSPLIT:
+		pr_info("[I2C%d] Xfer fail - MSG SPLIT (%d/%d)\n",
+			handler->id, i, num);
+		break;
+	case -ETXABORT:
+		pr_info("[I2C%d] Xfer fail - TXABORT (%d/%d), Reason=%04x\n",
+			handler->id, i, num,
+			handler->get_tx_abort_reason(handler));
+		break;
+	case -ETIMEOUT:
+		pr_info("[I2C%d] Xfer fail - TIMEOUT (%d/%d)\n",
+			handler->id, i, num);
+		break;
+	case -EILLEGALMSG:
+		pr_info("[I2C%d] Xfer fail - ILLEGAL MSG (%d/%d)\n",
+			handler->id, i, num);
+		break;
+	case -EADDROVERRANGE:
+		pr_info("[I2C%d] Xfer fail - ADDRESS OUT OF RANGE (%d/%d)\n",
+			handler->id, i, num);
+		break;
+	default:
+		pr_info("[I2C%d] Xfer fail - Unkonwn Return Value (%d/%d)\n",
+			handler->id, i, num);
+		break;
+	}
+
+	i2c_rtk_dump_msg(&msgs[i]);
+
+	ret = -EACCES;
+	return ret;
+}
+
+static const struct i2c_algorithm rtk_i2c_algo = {
+	.master_xfer = i2c_rtk_xfer,
+	.functionality = rtk_i2c_func,
+};
+
+static int  rtk_i2c_init(struct rtk_i2c_dev *i2c_dev)
+{
+	i2c_dev->handler = create_rtk_i2c_handle(
+		i2c_dev->id, RTK_MASTER_7BIT_ADDR,
+		ADDR_MODE_7BITS, SPD_MODE_SS, i2c_dev->irq,
+		(unsigned long)i2c_dev->base);
+
+	if (i2c_dev->handler == NULL)
+		pr_info("[I2C%d] handler is NULL, FAIL!!!!\n", i2c_dev->id);
+
+	return i2c_dev->handler->init(i2c_dev->handler);
+}
+
+/* Match table for of_platform binding */
+static const struct of_device_id rtk_i2c_of_match[] = {
+	{ .compatible = "realtek,rtk-i2c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_i2c_of_match);
+
+static int rtk_i2c_probe(struct platform_device *pdev)
+{
+	struct rtk_i2c_dev *i2c_dev;
+	struct clk *div_clk = NULL;
+	void __iomem *base;
+	int irq;
+	u32 i2c_id;
+	int ret = 0;
+
+	base = of_iomap(pdev->dev.of_node, 0);
+	if (!base) {
+		pr_err("i2c no mmio space\n");
+		return -EINVAL;
+	}
+
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq < 0) {
+		pr_err("i2c no irq\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(pdev->dev.of_node, "i2c-num", &i2c_id)) {
+		pr_err("Get I2C ID fail\n");
+		return -EINVAL;
+	}
+
+	div_clk = of_clk_get(pdev->dev.of_node, 0);
+	if (IS_ERR_OR_NULL(div_clk)) {
+		pr_warn("Failed to get clk from DT: %ld\n", PTR_ERR(div_clk));
+		div_clk = NULL;
+	}
+	clk_prepare_enable(div_clk);
+	ret = device_reset(&pdev->dev);
+	if (ret)
+		pr_warn("Failed to device reset: %d\n", ret);
+
+	i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
+	i2c_dev->base = base;
+	i2c_dev->div_clk = div_clk;
+	i2c_dev->adapter.algo = &rtk_i2c_algo;
+	i2c_dev->irq = irq;
+	i2c_dev->cont_id = pdev->id;
+	i2c_dev->id = i2c_id;
+	i2c_dev->dev = &pdev->dev;
+
+	ret = of_property_read_u32(i2c_dev->dev->of_node, "clock-frequency",
+		&i2c_dev->bus_clk_rate);
+	if (ret)
+		i2c_dev->bus_clk_rate = 100000; /* default clock rate */
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_device(rtk_i2c_of_match, &pdev->dev);
+	}
+
+	platform_set_drvdata(pdev, i2c_dev);
+
+	ret = rtk_i2c_init(i2c_dev);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to initialize i2c controller");
+		return ret;
+	}
+
+	ret = devm_request_irq(&pdev->dev, i2c_dev->irq, rtk_i2c_isr,
+		IRQF_SHARED, dev_name(&pdev->dev),
+		(void *)i2c_dev->handler);
+
+	i2c_set_adapdata(&i2c_dev->adapter, i2c_dev);
+	i2c_dev->adapter.owner = THIS_MODULE;
+	i2c_dev->adapter.class = I2C_CLASS_HWMON;
+	strlcpy(i2c_dev->adapter.name, "Realtek I2C adapter",
+		sizeof(i2c_dev->adapter.name));
+	i2c_dev->adapter.dev.parent = &pdev->dev;
+	i2c_dev->adapter.nr = pdev->id;
+	i2c_dev->adapter.dev.of_node = pdev->dev.of_node;
+
+	ret = i2c_add_numbered_adapter(&i2c_dev->adapter);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to add I2C adapter\n");
+		return ret;
+	}
+
+	pr_info("[%s] %s okay\n", KBUILD_MODNAME, __func__);
+
+	return 0;
+}
+
+static int rtk_i2c_remove(struct platform_device *pdev)
+{
+	struct rtk_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&i2c_dev->adapter);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int rtk_i2c_suspend(struct device *dev)
+{
+	struct rtk_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+
+	pr_info("[I2C] Enter %s\n", __func__);
+
+	i2c_mark_adapter_suspended(&i2c_dev->adapter);
+	clk_disable_unprepare(i2c_dev->div_clk);
+
+	pr_info("[I2C] Exit %s\n", __func__);
+	return 0;
+}
+
+static int rtk_i2c_resume(struct device *dev)
+{
+	struct rtk_i2c_dev *i2c_dev = dev_get_drvdata(dev);
+	int err;
+
+	pr_info("[I2C] Enter %s\n", __func__);
+
+	/*
+	 * We need to ensure that clocks are enabled so that registers can be
+	 * restored in rtk_i2c_init().
+	 */
+	clk_prepare_enable(i2c_dev->div_clk);
+
+	err = rtk_i2c_init(i2c_dev);
+	if (err)
+		return err;
+
+	i2c_mark_adapter_resumed(&i2c_dev->adapter);
+
+	pr_info("[I2C] Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops rtk_i2c_pm_ops = {
+	.suspend_noirq = rtk_i2c_suspend,
+	.resume_noirq = rtk_i2c_resume,
+};
+
+#define RTK_I2C_PM_OPS (&rtk_i2c_pm_ops)
+#else
+#define RTK_I2C_PM_OPS NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static struct platform_driver rtk_i2c_driver = {
+	.probe = rtk_i2c_probe,
+	.remove = rtk_i2c_remove,
+	.driver = {
+		.name = "rtk_i2c",
+		.owner = THIS_MODULE,
+		.pm = RTK_I2C_PM_OPS,
+		.of_match_table = of_match_ptr(rtk_i2c_of_match),
+	},
+};
+
+/* I2C may be needed to bring up other drivers */
+static int __init rtk_i2c_init_driver(void)
+{
+	return platform_driver_register(&rtk_i2c_driver);
+}
+//subsys_initcall(rtk_i2c_init_driver);
+rootfs_initcall(rtk_i2c_init_driver);
+
+static void __exit rtk_i2c_exit_driver(void)
+{
+	platform_driver_unregister(&rtk_i2c_driver);
+}
+module_exit(rtk_i2c_exit_driver);
+
+MODULE_AUTHOR("James Tai <james.tai@realtek.com>");
+MODULE_DESCRIPTION("Realtek I2C bus adapter");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rtk_i2c");
diff --git a/drivers/i2c/busses/i2c-rtk-priv.c b/drivers/i2c/busses/i2c-rtk-priv.c
new file mode 100755
index 000000000..c964103e0
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rtk-priv.c
@@ -0,0 +1,1393 @@
+/*
+ * Realtek I2C driver
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/arm-smccc.h>
+#include <asm/irq.h>
+
+#include "i2c-rtk-priv.h"
+
+#ifdef CONFIG_I2C_RTK_SECURE_ACCESS
+extern bool secure_dvfs_is_disabled(void);
+
+static void swc_write(unsigned int address, unsigned int value)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(0x8400ff0a, value, 0, 0, 0, 0, 0, 0, &res);
+//	ta_hdcp_lib_set_i2c_enable(value);
+}
+
+void SET_IC_ENABLE(struct rtk_i2c_handler *handler, int value)
+{
+	if (handler->id == 0 && !secure_dvfs_is_disabled())
+		smc_write(handler->reg_map.IC_ENABLE, value);
+	else
+		wr_reg(handler->reg_map.IC_ENABLE, value);
+}
+#endif
+/*
+ * Func : rtk_i2c_init
+ * Desc : init rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0
+ */
+int rtk_i2c_handler_init(struct rtk_i2c_handler *handler)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+//	if (handler->id == 0)
+//		ta_i2c_init();
+#endif
+#if 0
+	if (handler->flags & RTK_I2C_IRQ_RDY)
+		return 0;
+
+	if (rtk_i2c_probe(handler) < 0)
+		return -ENODEV;
+
+	ret = request_irq(handler->irq, rtk_i2c_isr, SA_SHIRQ, "i2c",
+		(void *) handler);
+	if (ret < 0) {
+		pr_err("FATAL: Request irq %d failed(ret=%d)\n",
+			handler->irq, ret);
+		return -ENODEV;
+	}
+#endif
+
+	handler->flags = RTK_I2C_IRQ_RDY;
+	handler->rx_fifo_depth =
+		((GET_IC_COMP_PARAM_1(handler) >>  8) & 0xFF) + 1;
+	handler->tx_fifo_depth =
+		((GET_IC_COMP_PARAM_1(handler) >> 16) & 0xFF) + 1;
+	init_waitqueue_head(&handler->wq);
+
+	spin_lock_init(&handler->lock);
+
+	return rtk_i2c_phy_init(handler);
+}
+
+/*
+ * Func : rtk_i2c_uninit
+ * Desc : uninit rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0
+ */
+int rtk_i2c_handler_uninit(struct rtk_i2c_handler *handler)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+	SET_IC_ENABLE(handler, 0);
+	SET_IC_INTR_MASK(handler, 0);
+
+	if ((handler->flags & RTK_I2C_IRQ_RDY)) {
+		free_irq(handler->irq, handler);
+		handler->flags = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_phy_init
+ * Desc : init rtk i2c phy
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0
+ */
+int rtk_i2c_phy_init(struct rtk_i2c_handler *handler)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+	SET_IC_ENABLE(handler, 0);
+	SET_IC_INTR_MASK(handler, 0); /* disable all interrupt*/
+	SET_IC_CON(handler,
+		IC_SLAVE_DISABLE | IC_RESTART_EN | SPEED_SS | IC_MASTER_MODE);
+	SET_IC_TX_TL(handler, FIFO_THRESHOLD);
+	SET_IC_RX_TL(handler, handler->rx_fifo_depth - FIFO_THRESHOLD);
+	handler->set_spd(handler, handler->spd);
+
+#ifdef DEV_DEBUG
+	rtk_i2c_dump(handler);
+#endif
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_set_spd
+ * Desc : set speed of rtk i2c
+ * Parm : handler:handle of rtk i2c
+ *	KHz:operation speed of i2c
+ * Retn : 0
+ */
+int rtk_i2c_set_spd(struct rtk_i2c_handler *handler, int KHz)
+{
+	unsigned int scl_time;
+	unsigned int div_h;
+	unsigned int div_l;
+	unsigned long sda_del;
+	unsigned int clk_time;
+
+	RTK_DEBUG("%s\n", __func__);
+
+#ifdef CONFIG_ARCH_RTD16xx
+	if (handler->id == 0) {
+		if (KHz < 10 || KHz > 3400) {
+			pr_err("[I2C%d] warning, speed %d out of range,",
+				handler->id, KHz);
+			pr_err("speed should between 10 ~ 3400KHz\n");
+			return -1;
+		}
+	} else {
+		if (KHz < 10 || KHz > 800) {
+			pr_err("[I2C%d] warning, speed %d out of range,",
+				handler->id, KHz);
+			pr_err("speed should between 10 ~ 800KHz\n");
+			return -1;
+		}
+	}
+#else
+	if (KHz < 10 || KHz > 800) {
+		pr_err("[I2C%d] warning, speed %d out of range,",
+			handler->id, KHz);
+		pr_err("speed should between 10 ~ 800KHz\n");
+		return -1;
+	}
+#endif
+
+	clk_time = 37; /*27MHZ*/
+
+	scl_time = (1000000 / KHz) / 2; /* the time ns need for SCL high/low */
+	if (scl_time % clk_time) {
+		if ((scl_time % clk_time) > clk_time / 2)
+			scl_time += (clk_time - (scl_time % clk_time));
+		else
+			scl_time -= (scl_time % clk_time);
+	}
+
+	/*
+	 * 27MHz crystal generate one clock 37ns,
+	 * 108MHz crystal generate one clock 9ns,
+	 * for synopsys design ware ip v1.14a, SCL_LCNT need -1,
+	 * SCL_HCNT need -8, 400KHz SCL Low required min 1.3 us
+	 */
+
+#ifdef CONFIG_ARCH_RTD16xx
+
+	if (handler->id == 0) {
+		if (KHz == 100){
+			div_h = 524;
+			div_l = 531;
+		} else if (KHz == 400){
+			div_h = 119;
+			div_l = 126;
+		} else if (KHz == 3400) {
+			div_h = 7;
+			div_l = 15;
+		}
+	} else {
+		if (KHz < 400) {
+			div_h = (scl_time / clk_time) - 8;
+			div_l = (scl_time / clk_time) - 1;
+		} else {
+			div_h = 25;
+			div_l = 32;
+		}
+	}
+
+#else
+	if (KHz < 400) {
+		div_h = (scl_time / clk_time) - 8;
+		div_l = (scl_time / clk_time) - 1;
+	} else {
+		div_h = 24;
+		div_l = 34;
+	}
+
+	if (div_h >= 0xFFFF || div_h == 0 || div_l >= 0xFFFF || div_l == 0) {
+		pr_err("[I2C%d] fatal, set speed failed : ", handler->id);
+		pr_err("divider divider out of range.");
+		pr_err("div_h = %d, div_l = %d\n", div_h, div_l);
+		return -1;
+	}
+
+#endif
+
+	RTK_DEBUG("[I2C%d] KHz = %d, div_h = %d, div_l = %d\n",
+		handler->id, KHz, div_h, div_l);
+
+
+	SET_IC_ENABLE(handler, 0);
+
+	if (KHz <= 100) {
+		SET_IC_CON(handler, (GET_IC_CON(handler) &
+			(~IC_SPEED)) | SPEED_SS);
+		SET_IC_SS_SCL_HCNT(handler, div_h);
+		SET_IC_SS_SCL_LCNT(handler, div_l);
+	} else if(KHz == 400) {
+		SET_IC_CON(handler, (GET_IC_CON(handler) &
+			(~IC_SPEED)) | SPEED_FS);
+		SET_IC_FS_SCL_HCNT(handler, div_h);
+		SET_IC_FS_SCL_LCNT(handler, div_l);
+	} else if (KHz == 3400) {
+		SET_IC_CON(handler, (GET_IC_CON(handler) &
+			(~IC_SPEED)) | SPEED_HS);
+		SET_IC_HS_SCL_HCNT(handler, div_h);
+		SET_IC_HS_SCL_LCNT(handler, div_l);
+	}
+
+	handler->spd = KHz;
+	/*Todo: Fix tick for 3.4MHz*/
+	handler->tick = 1000 / KHz;
+
+	/*Set SDA delay time */
+	if (KHz == 3400) { /*disabled sda_del*/
+		sda_del = 0x0;
+	} else {
+		sda_del = GET_IC_SDA_DEL(handler) & ~I2C_SDA_DEL_MASK;
+		sda_del |= I2C_SDA_DEL_EN | I2C_SDA_DEL_SEL(SDA_DEL_518NS);
+	}
+	SET_IC_SDA_DEL(handler, sda_del);
+
+	return 0;
+}
+
+/**
+ * Func : rtk_i2c_set_tar
+ * Desc : set tar of rtk i2c
+ * Parm : handler : handle of rtk i2c
+ *	addr : address of sar
+ *	mode : mode of sar
+ * Retn : 0
+ */
+int rtk_i2c_set_tar(struct rtk_i2c_handler *handler, unsigned short addr,
+	enum ADDR_MODE mode)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+	if (mode == ADDR_MODE_10BITS) {
+		if (addr > ADDR_10BITS_MASK)
+			return -EADDROVERRANGE;
+
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_TAR(handler, addr & ADDR_10BITS_MASK);
+		SET_IC_CON(handler, (GET_IC_CON(handler) &
+			(~IC_10BITADDR_MASTER)) | IC_10BITADDR_MASTER);
+	} else {
+		if (addr > ADDR_7BITS_MASK)
+			return -EADDROVERRANGE;
+
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_TAR(handler, addr & ADDR_7BITS_MASK);
+		SET_IC_CON(handler, GET_IC_CON(handler) &
+			(~IC_10BITADDR_MASTER));
+	}
+
+	handler->tar = addr;
+	handler->tar_mode = mode;
+
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_set_guard_interval
+ * Desc : set guard_interval of rtk i2c
+ * Parm : handler : handle of rtk i2c
+ *		us : operation speed of i2c
+ * Retn : 0
+ */
+int rtk_i2c_set_guard_interval(struct rtk_i2c_handler *handler,
+	unsigned long us)
+{
+	RTK_DEBUG("%s\n", __func__);
+	handler->guard_interval = us;
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_read
+ * Desc : read data from sar
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0 for success, others is failed
+ */
+int rtk_i2c_read(struct rtk_i2c_handler *handler,
+	unsigned char *tx_buf, unsigned short tx_buf_len,
+	unsigned char *rx_buf, unsigned short rx_buf_len)
+{
+	int retry = 2;
+	unsigned int ret = 0;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	while (retry > 0) {
+		rtk_i2c_load_message(handler,
+			tx_buf_len ? I2C_MASTER_RANDOM_READ : I2C_MASTER_READ,
+			tx_buf, tx_buf_len,
+			rx_buf, rx_buf_len, 0);
+
+		ret = rtk_i2c_start_xfer(handler);
+		if (ret != -ETIMEOUT)
+			break;
+
+		/*JAM_DEBUG("[I2C] read timeout detected, do retry\n");*/
+		retry--;
+	}
+
+	return ret;
+}
+
+/*
+ * Func : rtk_i2c_write
+ * Desc : write data to sar
+ * Parm : handler : handle of rtk i2c
+ *	tx_buf : data to write
+ *	tx_buf_len : number of bytes to write
+ *	wait_stop  : wait for stop of not (extension)
+ * Retn : 0 for success, others is failed
+ */
+int rtk_i2c_write(struct rtk_i2c_handler *handler, unsigned char *tx_buf,
+	unsigned short tx_buf_len, unsigned char wait_stop)
+{
+	int retry = 2;
+	unsigned int ret = 0;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	while (retry > 0) {
+		rtk_i2c_load_message(handler, I2C_MASTER_WRITE, tx_buf,
+			tx_buf_len, NULL, 0, (wait_stop) ? 0 : I2C_NO_STOP);
+
+		ret = rtk_i2c_start_xfer(handler);
+
+		if (ret != -ETIMEOUT)
+			break;
+
+		retry--;
+	}
+
+	return ret;
+}
+
+/*
+ * Func : rtk_i2c_load_message
+ * Desc : load a i2c message (just add this message to the queue)
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0 for success, others is failed
+ */
+int rtk_i2c_load_message(struct rtk_i2c_handler *handler,
+		unsigned char mode, unsigned char *tx_buf,
+		unsigned short tx_buf_len, unsigned char *rx_buf,
+		unsigned short rx_buf_len, unsigned char xfer_flags)
+{
+	unsigned long flags;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+
+	memset(&handler->xfer, 0, sizeof(handler->xfer));
+
+	handler->xfer.mode = mode;
+	handler->xfer.flags = xfer_flags;
+	handler->xfer.tx_buff = tx_buf;
+	handler->xfer.tx_buff_len = tx_buf_len;
+	handler->xfer.tx_len = 0;
+	handler->xfer.rx_buff = rx_buf;
+	handler->xfer.rx_buff_len = rx_buf_len;
+	handler->xfer.rx_len = 0;
+	handler->xfer.except_time =
+		((tx_buf_len + rx_buf_len + 2) * 9 * handler->tick);
+
+	if (rx_buf && rx_buf_len)
+		memset(rx_buf, 0, rx_buf_len);
+
+	//handler->xfer.gpio_xfer_state = G2C_ST_START;
+	//handler->xfer.gpio_xfer_sub_state = 0;
+
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+
+#ifdef DEV_DEBUG
+	{
+		int i;
+
+		pr_info("%s xfer.mode = %x\n",
+			__func__, handler->xfer.mode);
+		pr_info("%s xfer.flags= 0x%x\n",
+			__func__, handler->xfer.flags);
+
+		if (handler->xfer.tx_buff_len) {
+			for (i = 0; i < handler->xfer.tx_buff_len; i++) {
+				pr_info("%s xfer.tx_buff= 0x%x\n",
+					__func__, *handler->xfer.tx_buff);
+				pr_info("%s xfer.tx_buff= 0x%x\n",
+					__func__, handler->xfer.tx_buff[i]);
+			}
+		}
+
+		pr_info("%s xfer.tx_buff_len= 0x%x\n",
+			__func__, handler->xfer.tx_buff_len);
+		pr_info("%s xfer.tx_len= 0x%x\n",
+			__func__, handler->xfer.tx_len);
+
+		if (handler->xfer.rx_buff_len) {
+			for (i = 0; i < handler->xfer.rx_buff_len; i++) {
+				pr_info("%s xfer.rx_buff= 0x%x\n",
+					__func__, *handler->xfer.rx_buff);
+				pr_info("%s xfer.rx_buff= 0x%x\n",
+					__func__, handler->xfer.rx_buff[i]);
+			}
+		}
+
+		pr_info("%s xfer.rx_buff_len= 0x%x\n",
+			__func__, handler->xfer.rx_buff_len);
+		pr_info("%s xfer.rx_len= 0x%x\n",
+			__func__, handler->xfer.rx_len);
+		pr_info("%s xfer.except_time= 0x%lx\n",
+			__func__, handler->xfer.except_time);
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_start_xfer
+ * Desc : start xfer message
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0 for success, others is failed
+ */
+int rtk_i2c_start_xfer(struct rtk_i2c_handler *handler)
+{
+	unsigned long flags;
+	unsigned int ret;
+	int mode = handler->xfer.mode;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	LOG_EVENT(EVENT_START_XFER);
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+
+	if ((GET_IC_CON(handler) & IC_SLAVE_DISABLE) == 0) {
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_CON(handler, GET_IC_CON(handler) | IC_SLAVE_DISABLE);
+	}
+
+	switch (handler->xfer.mode) {
+	case I2C_MASTER_WRITE:
+		SET_IC_INTR_MASK(handler,
+			TX_EMPTY_BIT | TX_ABRT_BIT | STOP_DET_BIT);
+		break;
+	case I2C_MASTER_READ:
+	case I2C_MASTER_RANDOM_READ:
+		if (GET_IC_RXFLR(handler)) {
+			pr_info("WARNING, RX FIFO NOT EMPRY\n");
+
+			while (GET_IC_RXFLR(handler))
+				GET_IC_DATA_CMD(handler);
+		}
+		SET_IC_INTR_MASK(handler,
+			RX_FULL_BIT | TX_EMPTY_BIT | TX_ABRT_BIT |
+			STOP_DET_BIT);
+		break;
+	default:
+		UNLOCK_RTK_I2C(&handler->lock, flags);
+		LOG_EVENT(EVENT_STOP_XFER);
+		return -EILLEGALMSG;
+	}
+
+	if (handler->reg_map.I2C_ISR_EN)
+		wr_reg(handler->reg_map.I2C_ISR_EN,
+			rd_reg(handler->reg_map.I2C_ISR_EN) |
+			handler->reg_map.I2C_ISR_EN_MASK);
+
+#ifdef MINIMUM_DELAY_EN
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+
+	/* cfyeh found that delay 1/2 tick will cause long
+	 * system booting time, so we revert the delay setting
+	 * temporarily until we findout the root cause
+	 */
+	if (time_after(jiffies, handler->time_stamp)) {
+		// udelay(handler->tick/2); /* wait 1/2 ticks */
+		udelay(handler->guard_interval);
+	}
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+#endif
+
+	SET_IC_ENABLE(handler, 1); /* Start Xfer */
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+
+	/* less than 1 ms */
+	if (handler->xfer.except_time < 1000) {
+		/* extra 20 us for extra guard interval */
+		udelay(handler->xfer.except_time + 20);
+	}
+
+	if (handler->xfer.mode != I2C_IDLE)
+		wait_event_timeout(handler->wq,
+			handler->xfer.mode == I2C_IDLE, 1 * HZ);
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+
+	SET_IC_INTR_MASK(handler, 0);
+	SET_IC_ENABLE(handler, 0);
+
+	if (handler->xfer.mode != I2C_IDLE) {
+		handler->xfer.ret  = -ETIMEOUT;
+
+	} else if (handler->xfer.ret == -ECMDSPLIT) {
+		pr_warn("WARNING,");
+		switch (mode) {
+		case I2C_MASTER_WRITE:
+			pr_warn("Write Cmd Split, tx : %d/%d\n",
+				handler->xfer.tx_len,
+				handler->xfer.tx_buff_len);
+			break;
+		case I2C_MASTER_READ:
+			pr_warn("Read Cmd Split, tx : %d/%d rx : %d/%d\n",
+				handler->xfer.tx_len,
+				handler->xfer.tx_buff_len,
+				handler->xfer.rx_len,
+				handler->xfer.rx_buff_len);
+			break;
+		case I2C_MASTER_RANDOM_READ:
+			ret = handler->xfer.tx_buff_len +
+				handler->xfer.rx_buff_len;
+			pr_warn("Read Cmd Split, tx : %d/%d rx : %d/%d\n",
+				handler->xfer.tx_len,
+				ret,
+				handler->xfer.rx_len,
+				handler->xfer.rx_buff_len);
+			break;
+		default:
+			break;
+		}
+	}
+
+#ifdef MINIMUM_DELAY_EN
+	handler->time_stamp = (unsigned long) jiffies;
+#endif
+
+	ret = handler->xfer.ret;
+
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+
+#ifndef MINIMUM_DELAY_EN
+	udelay(handler->guard_interval);
+#endif
+
+	LOG_EVENT(EVENT_STOP_XFER);
+
+	if (handler->flags & RTK_I2C_SLAVE_ENABLE)
+		handler->slave_mode_enable(handler, 1);
+
+	return ret;
+}
+
+/*
+ * Func : rtk_i2c_get_tx_abort_reason
+ * Desc : get reason of tx abort, this register will be clear when new
+ *	message is loaded
+ * Parm : handler : handle of rtk i2c
+ * Retn : tx about source
+ */
+unsigned int rtk_i2c_get_tx_abort_reason(struct rtk_i2c_handler *handler)
+{
+	RTK_DEBUG("%s\n", __func__);
+	return handler->xfer.tx_abort_source;
+}
+
+
+/*
+ * Func : rtk_i2c_master_write
+ * Desc : master write handler for rtk i2c
+ * Parm : handler : handle of rtk i2c
+ *		event  : INT event of rtk i2c
+ * Retn : N/A
+ */
+void rtk_i2c_master_write(struct rtk_i2c_handler *handler, unsigned int event,
+	unsigned int tx_abort_source)
+{
+#define TxComplete() (handler->xfer.tx_len >= handler->xfer.tx_buff_len)
+
+	RTK_DEBUG("%s\n", __func__);
+
+	while (!TxComplete() && NOT_TXFULL(handler)) {
+		if (handler->xfer.tx_len == handler->xfer.tx_buff_len - 1) {
+			SET_IC_DATA_CMD(handler,
+				handler->xfer.tx_buff[handler->xfer.tx_len++] |
+				(0x1 << 9));
+		} else {
+			SET_IC_DATA_CMD(handler,
+				handler->xfer.tx_buff[handler->xfer.tx_len++]);
+		}
+	}
+
+	if (TxComplete())
+		SET_IC_INTR_MASK(handler,
+			GET_IC_INTR_MASK(handler) & ~TX_EMPTY_BIT);
+
+	if (event & TX_ABRT_BIT) {
+		handler->tx_abort_flag = 1;
+		handler->xfer.tx_abort_source = tx_abort_source;
+	} else if (event & STOP_DET_BIT) {
+		if (handler->tx_abort_flag != 1) {
+			handler->xfer.ret =
+				TxComplete() ? handler->xfer.tx_len : -ECMDSPLIT;
+		} else {
+			handler->tx_abort_flag = 0;
+			handler->xfer.ret = -ETXABORT;
+		}
+	}
+
+	if (handler->xfer.ret) {
+		SET_IC_INTR_MASK(handler, 0);
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+		SET_IC_ENABLE(handler, 0);
+#endif
+		handler->xfer.mode = I2C_IDLE; /* change to idle state */
+		wake_up(&handler->wq);
+	}
+
+#undef TxComplete
+}
+
+/*
+ * Func : rtk_i2c_master_read
+ * Desc : master read handler for rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : N/A
+ */
+void rtk_i2c_master_read(struct rtk_i2c_handler *handler, unsigned int event,
+	unsigned int tx_abort_source)
+{
+#define TxComplete() (handler->xfer.tx_len >= handler->xfer.rx_buff_len)
+#define RxComplete() (handler->xfer.rx_len >= handler->xfer.rx_buff_len)
+
+	RTK_DEBUG("%s\n", __func__);
+
+	/* TX Thread */
+	while (!TxComplete() && NOT_TXFULL(handler)) {
+		if (handler->xfer.tx_len ==
+			((handler->xfer.rx_buff_len +
+			handler->xfer.tx_buff_len) - 1)) {
+			/* send stop command to rx fifo */
+			SET_IC_DATA_CMD(handler, (READ_CMD | (0x1 << 9)));
+		} else {
+			/* send read command to rx fifo*/
+			SET_IC_DATA_CMD(handler, READ_CMD);
+		}
+
+		handler->xfer.tx_len++;
+		while (!RxComplete() && NOT_RXEMPTY(handler))
+			handler->xfer.rx_buff[handler->xfer.rx_len++] =
+				(unsigned char)(GET_IC_DATA_CMD(handler) &
+				0xFF);
+	}
+
+	/* RX Thread */
+	while (!RxComplete() && NOT_RXEMPTY(handler))
+		handler->xfer.rx_buff[handler->xfer.rx_len++] =
+			(unsigned char)(GET_IC_DATA_CMD(handler) & 0xFF);
+
+	if (TxComplete())
+		SET_IC_INTR_MASK(handler,
+			GET_IC_INTR_MASK(handler) & ~TX_EMPTY_BIT);
+
+	if (event & TX_ABRT_BIT) {
+		handler->tx_abort_flag =1;
+		handler->xfer.tx_abort_source = tx_abort_source;
+	} else if ((event & STOP_DET_BIT) || RxComplete()) {
+		SET_IC_INTR_MASK(handler,
+			GET_IC_INTR_MASK(handler) & ~RX_FULL_BIT);
+		if (handler->tx_abort_flag != 1) {
+			handler->xfer.ret =
+				RxComplete() ? handler->xfer.rx_len : -ECMDSPLIT;
+		} else {
+			handler->tx_abort_flag = 0;
+			handler->xfer.ret = -ETXABORT;
+		}
+	}
+
+	if (handler->xfer.ret  && (handler->xfer.ret!=-ETXABORT)) {
+		SET_IC_INTR_MASK(handler, 0);
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+		SET_IC_ENABLE(handler, 0);
+#endif
+		handler->xfer.mode = I2C_IDLE; /* change to idle state */
+		wake_up(&handler->wq);
+	}
+
+#undef TxComplete
+#undef RxComplete
+}
+
+/*
+ * Func : rtk_i2c_master_random_read
+ * Desc : master random read handler for rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : N/A
+ */
+void rtk_i2c_master_random_read(struct rtk_i2c_handler *handler,
+	unsigned int event, unsigned int tx_abort_source)
+{
+/* it should add the same number of read command to tx fifo */
+#define TxComplete() \
+(handler->xfer.tx_len >= \
+(handler->xfer.rx_buff_len + handler->xfer.tx_buff_len))
+#define RxComplete() (handler->xfer.rx_len >=  handler->xfer.rx_buff_len)
+
+	RTK_DEBUG("%s\n", __func__);
+
+	/* TX Thread  */
+	while (!TxComplete() && NOT_TXFULL(handler)) {
+		if (handler->xfer.tx_len < handler->xfer.tx_buff_len) {
+			SET_IC_DATA_CMD(handler,
+				handler->xfer.tx_buff[handler->xfer.tx_len]);
+		} else {
+			if ((handler->xfer.tx_len == handler->xfer.tx_buff_len)
+				&& (handler->xfer.tx_len ==
+				((handler->xfer.rx_buff_len +
+				handler->xfer.tx_buff_len) - 1))) {
+				/* send Restart command and STOP to rx fifo :
+				 * first also last read cmd
+				 */
+				SET_IC_DATA_CMD(handler,
+					(READ_CMD | (0x3 << 9)));
+			} else if ((handler->xfer.tx_len ==
+					(handler->xfer.tx_buff_len)) &&
+					(!(handler->xfer.tx_len ==
+					((handler->xfer.rx_buff_len +
+					handler->xfer.tx_buff_len) - 1)))) {
+				/* send restart command to rx fifo :
+				 * first but not last read cmd
+				 */
+				SET_IC_DATA_CMD(handler,
+					(READ_CMD | (0x1 << 10)));
+			} else if ((!(handler->xfer.tx_len ==
+					(handler->xfer.tx_buff_len))) &&
+					(handler->xfer.tx_len ==
+					((handler->xfer.rx_buff_len +
+					handler->xfer.tx_buff_len) - 1))) {
+				/* send stop command to rx fifo :
+				 * not first but last read cmd
+				 */
+				SET_IC_DATA_CMD(handler,
+					(READ_CMD | (0x1 << 9)));
+			} else {
+				/* send read command to rx fifo :
+				 * not first also not last read cmd
+				 */
+				SET_IC_DATA_CMD(handler, READ_CMD);
+			}
+		}
+
+		handler->xfer.tx_len++;
+
+		/* RX Thread,
+		 * incase rxfifo overflow and the datas are droped
+		 */
+		while (!RxComplete() && NOT_RXEMPTY(handler)) {
+			RTK_DEBUG("%s handler->xfer.rx_len =%d\n",
+				__func__, handler->xfer.rx_len);
+			handler->xfer.rx_buff[handler->xfer.rx_len++] =
+				(unsigned char)(GET_IC_DATA_CMD(handler) &
+				0xFF);
+		}
+	}
+
+	/* RX Thread */
+	while (!RxComplete() && NOT_RXEMPTY(handler))
+		handler->xfer.rx_buff[handler->xfer.rx_len++] =
+			(unsigned char)(GET_IC_DATA_CMD(handler) & 0xFF);
+
+	if (TxComplete())
+		SET_IC_INTR_MASK(handler,
+			GET_IC_INTR_MASK(handler) & ~TX_EMPTY_BIT);
+
+	if (event & TX_ABRT_BIT) {
+		handler->tx_abort_flag =1;
+		handler->xfer.tx_abort_source = tx_abort_source;
+	} else if ((event & STOP_DET_BIT) || RxComplete()) {
+		SET_IC_INTR_MASK(handler,
+			GET_IC_INTR_MASK(handler) & ~RX_FULL_BIT);
+		if (handler->tx_abort_flag != 1) {
+			handler->xfer.ret =
+				RxComplete() ? handler->xfer.rx_len : -ECMDSPLIT;
+		} else {
+			handler->tx_abort_flag = 0;
+			handler->xfer.ret = -ETXABORT;
+		}
+	}
+
+	if (handler->xfer.ret) {
+		SET_IC_INTR_MASK(handler, 0);
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+		SET_IC_ENABLE(handler, 0);
+#endif
+		handler->xfer.mode = I2C_IDLE; /* change to idle state */
+		wake_up(&handler->wq);
+	}
+
+#undef TxComplete
+#undef RxComplete
+}
+
+#ifdef EDID_4BLOCK_SUPPORT
+
+/*
+ * Func : rtk_i2c_read_edid_seg
+ * Desc : read edid seg
+ * Parm : Block 0~1: Seg 0
+ *	Block 2: Seg 1, Offset 0
+ *	Block 3: Seg 1, Offset 128
+ * Retn : 0 for success, others is failed
+ */
+int rtk_i2c_read_edid_seg(struct rtk_i2c_handler *handler,
+	unsigned char seg, /* Segment Pointer */
+	unsigned char offset, /* Word Offset */
+	unsigned char *rx_buff, unsigned short rx_buf_len)
+{
+#define RxComplete() (rx_len >= rx_buf_len)
+#define TxComplete() (tx_len >= rx_buf_len)
+
+	int rx_len = 0;
+	int tx_len = 0;
+	int cnt = 0;
+
+	RTK_DEBUG("%s seg=0x%x offset=0x%02x len(%u)\n",
+		__func__, seg, offset, rx_buf_len);
+
+	rtk_i2c_set_tar(handler, 0x30, ADDR_MODE_7BITS);
+	CLR_IC_INTR(handler);
+	SET_IC_ENABLE(handler, 1);
+
+	while (GET_IC_STATUS(handler) & (ST_ACTIVITY_BIT == 0)) {
+		if (cnt++ < 5)
+			udelay(50);
+		else
+			return -ETIMEOUT;
+
+		RTK_DEBUG("%s IC_STATUS = 0x%x\n",
+			__func__, GET_IC_STATUS(handler));
+	}
+
+	SET_IC_DATA_CMD(handler, seg); /* Segment Pointer */
+	udelay(50);
+	CLR_IC_INTR(handler);
+	SET_IC_ENABLE(handler, 0);
+
+	rtk_i2c_set_tar(handler, 0x50, ADDR_MODE_7BITS);
+	CLR_IC_INTR(handler);
+	SET_IC_ENABLE(handler, 1);
+	cnt = 0;
+
+	while (GET_IC_STATUS(handler) & (ST_ACTIVITY_BIT == 0)) {
+		if (cnt++ < 5)
+			udelay(50);
+		else
+			return -ETIMEOUT;
+	}
+
+	SET_IC_DATA_CMD(handler, offset|(0x1<<10)); /* Restart, Word Offset */
+	udelay(100);
+
+	RTK_DEBUG("%s IC_STATUS= 0x%x\n", __func__, GET_IC_STATUS(handler));
+
+	while (!TxComplete() && NOT_TXFULL(handler)) {
+
+		if (tx_len == rx_buf_len - 1)
+			/* Read, Stop */
+			SET_IC_DATA_CMD(handler, (0x1 << 8) | (0x1 << 9));
+		else
+			/* Read */
+			SET_IC_DATA_CMD(handler, (0x1 << 8));
+
+		tx_len++;
+		udelay(100);
+		while (NOT_RXEMPTY(handler)) {
+			rx_buff[rx_len] =
+				(unsigned char)(GET_IC_DATA_CMD(handler) &
+				0xFF);
+			udelay(50);
+			rx_len++;
+		}
+	}
+
+	while (!RxComplete() && NOT_RXEMPTY(handler)) {
+		rx_buff[rx_len] =
+			(unsigned char)(GET_IC_DATA_CMD(handler) & 0xFF);
+		rx_len++;
+		udelay(50);
+	}
+
+	CLR_IC_INTR(handler);
+	SET_IC_ENABLE(handler, 0);
+
+	return 0;
+}
+#endif
+
+/*
+ * Func : rtk_i2c_isr
+ * Desc : isr of rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0
+ */
+irqreturn_t rtk_i2c_isr(int this_irq, void *dev_id)
+{
+	struct rtk_i2c_handler *handler = (struct rtk_i2c_handler *) dev_id;
+	unsigned long flags;
+	unsigned int event = 0;
+	unsigned int tx_abrt_source = 0;
+	unsigned int tmp;
+
+	RTK_DEBUG("%s\n", __func__);
+
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+	LOCK_RTK_I2C(&handler->lock, flags);
+#endif
+
+	/* interrupt belongs to I2C */
+	if (!(GET_I2C_ISR(handler) & handler->reg_map.I2C_INT)) {
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+		UNLOCK_RTK_I2C(&handler->lock, flags);
+#endif
+		return IRQ_NONE;
+	}
+
+	LOG_EVENT(EVENT_ENTER_ISR);
+
+	event = GET_IC_INTR_STAT(handler);
+	tx_abrt_source = GET_IC_TX_ABRT_SOURCE(handler);
+
+	CLR_IC_INTR(handler); /* clear interrupts of i2c_x */
+
+	if ((GET_IC_CON(handler) & IC_SLAVE_DISABLE) == 0) {
+		while (NOT_RXEMPTY(handler) &&
+			(handler->slave_rx_len <
+			sizeof(handler->slave_rx_buffer))) {
+			handler->slave_rx_buffer[handler->slave_rx_len++] =
+				(unsigned char)(GET_IC_DATA_CMD(handler) &
+				0xFF);
+		}
+
+		if ((event & STOP_DET_BIT) && handler->slave_rx_len) {
+			if (handler->slave_ops.handle_command)
+				handler->slave_ops.handle_command(
+						handler->slave_id,
+						handler->slave_rx_buffer,
+						handler->slave_rx_len);
+
+			handler->slave_rx_len = 0; /* flush buffer */
+		}
+
+		if (event & RD_REQ_BIT) {
+			if (handler->slave_ops.read_data) {
+				tmp = handler->slave_id;
+				SET_IC_DATA_CMD(handler,
+					handler->slave_ops.read_data(tmp));
+			} else
+				SET_IC_DATA_CMD(handler, 0xFF);
+		}
+	} else {
+		switch (handler->xfer.mode) {
+		case I2C_MASTER_WRITE:
+			rtk_i2c_master_write(handler, event, tx_abrt_source);
+			break;
+
+		case I2C_MASTER_READ:
+			rtk_i2c_master_read(handler, event, tx_abrt_source);
+			break;
+
+		case I2C_MASTER_RANDOM_READ:
+			rtk_i2c_master_random_read(handler, event,
+						tx_abrt_source);
+			break;
+
+		default:
+			pr_info("Unexcepted Interrupt\n");
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+			SET_IC_ENABLE(handler, 0);
+#endif
+		}
+	}
+
+	/* clear I2C Interrupt Flag */
+	SET_I2C_ISR(handler, handler->reg_map.I2C_INT);
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#else
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+#endif
+	return IRQ_HANDLED;
+}
+
+/*
+ * Func : rtk_i2c_set_sar
+ * Desc : set sar of rtk i2c
+ * Parm : handler : handle of rtk i2c
+ *	addr : address of sar
+ *	mode : mode of sar
+ * Retn : 0
+ */
+int rtk_i2c_set_sar(struct rtk_i2c_handler *handler,
+	unsigned short addr, enum ADDR_MODE mode)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+	if (mode == ADDR_MODE_10BITS) {
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_SAR(handler, handler->sar & ADDR_10BITS_MASK);
+		SET_IC_CON(handler, GET_IC_CON(handler) | IC_10BITADDR_SLAVE);
+	} else {
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_SAR(handler, handler->sar & ADDR_7BITS_MASK);
+		SET_IC_CON(handler, GET_IC_CON(handler) &
+			(~IC_10BITADDR_SLAVE));
+	}
+
+	handler->sar = addr;
+	handler->sar_mode = mode;
+
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_slave_mode_enable
+ * Desc : enable/disable i2c slave mode
+ * Parm : handler : handle of rtk i2c
+ *	on : enable /disable
+ * Retn : 0
+ */
+int rtk_i2c_slave_mode_enable(struct rtk_i2c_handler *handler,
+	unsigned char on)
+{
+	unsigned long flags;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+
+	if (on) {
+		pr_info("[I2C%d] i2c slave enabled, sar=%x\n",
+				handler->id, GET_IC_SAR(handler));
+		SET_IC_ENABLE(handler, 0);
+		handler->set_sar(handler, handler->sar, handler->sar_mode);
+		SET_IC_CON(handler, GET_IC_CON(handler) & ~(IC_SLAVE_DISABLE));
+		SET_IC_INTR_MASK(handler, START_DET_BIT |
+				STOP_DET_BIT | RD_REQ_BIT | RX_FULL_BIT);
+		if (handler->reg_map.I2C_ISR_EN)
+			wr_reg(handler->reg_map.I2C_ISR_EN,
+				rd_reg(handler->reg_map.I2C_ISR_EN) |
+				handler->reg_map.I2C_ISR_EN_MASK);
+		SET_IC_ENABLE(handler, 1);
+		handler->flags |= RTK_I2C_SLAVE_ENABLE;
+	} else {
+		pr_info("[I2C%d] i2c slave disabled\n", handler->id);
+		SET_IC_ENABLE(handler, 0);
+		SET_IC_CON(handler, GET_IC_CON(handler) | IC_SLAVE_DISABLE);
+		SET_IC_INTR_MASK(handler, 0);
+		handler->flags &= ~RTK_I2C_SLAVE_ENABLE;
+	}
+
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_register_slave_ops
+ * Desc : register slave mode ops
+ * Parm : handler : handle of rtk i2c
+ *		ops : slave mode ops
+ * Retn : 0
+ */
+int rtk_i2c_register_slave_ops(struct rtk_i2c_handler *handler,
+	struct rtk_i2c_slave_ops *ops, unsigned long id)
+{
+	unsigned long flags;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	LOCK_RTK_I2C(&handler->lock, flags);
+
+	if (ops == NULL) {
+		handler->slave_ops.handle_command = NULL;
+		handler->slave_ops.read_data = NULL;
+		handler->slave_id = 0;
+		rtk_i2c_slave_mode_enable(handler, 0);
+	} else {
+		handler->slave_ops.handle_command = ops->handle_command;
+		handler->slave_ops.read_data = ops->read_data;
+		handler->slave_id = id;
+	}
+
+	UNLOCK_RTK_I2C(&handler->lock, flags);
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_dump
+ * Desc : dump staus of rtk i2c
+ * Parm : handler : handle of rtk i2c
+ * Retn : 0 for success
+ */
+int rtk_i2c_dump(struct rtk_i2c_handler *handler)
+{
+	RTK_DEBUG("%s\n", __func__);
+	pr_info("=========================\n");
+	pr_info("= VER : %s\n", VERSION);
+	pr_info("=========================\n");
+	pr_info("= PHY : %d\n", handler->id);
+	//pr_info("= PORT: %ld\n", current_port_id(handler));
+	pr_info("= MODEL: %s\n", handler->model_name);
+	pr_info("= SPD : %d\n", handler->spd);
+	pr_info("= SAR : 0x%03x (%d bits)\n",
+			handler->sar, handler->sar_mode);
+	pr_info("= TX FIFO DEPTH : %d\n", handler->tx_fifo_depth);
+	pr_info("= RX FIFO DEPTH : %d\n", handler->rx_fifo_depth);
+	pr_info("= FIFO THRESHOLD: %d\n", FIFO_THRESHOLD);
+	pr_info("=========================\n");
+	return 0;
+}
+
+/*
+ * Func : rtk_i2c_setup_reg_base
+ * Desc : setup register of rtk i2c
+ * Parm : N/A
+ * Retn : reg_map of rtk i2c
+ */
+struct rtk_i2c_reg_map rtk_i2c_setup_reg_base(unsigned int id,
+	unsigned long base)
+{
+	struct rtk_i2c_reg_map reg_map;
+
+	switch (id) {
+	case 0:
+		reg_map.I2C_ISR = (base & ~0xFFF);
+		reg_map.I2C_INT = ISO_ISR_I2C0;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | ISO_I2C0_SDA_DEL;
+		break;
+	case 1:
+#ifdef CONFIG_ARCH_RTD119X
+		reg_map.I2C_ISR = (base & ~0xFFF) | 0x000C;
+		reg_map.I2C_INT = MISC_ISR_I2C1;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | MISC_I2C1_SDA_DEL;
+#else
+		reg_map.I2C_ISR = (base & ~0xFFF);
+		reg_map.I2C_INT = ISO_ISR_I2C1;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | ISO_I2C1_SDA_DEL;
+#endif
+		break;
+	case 2:
+		reg_map.I2C_ISR = (base & ~0xFFF) | 0x000C;
+		reg_map.I2C_INT = MIS_ISR_I2C2;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | MIS_I2C2_SDA_DEL;
+		break;
+	case 3:
+		reg_map.I2C_ISR = (base & ~0xFFF) | 0x000C;
+		reg_map.I2C_INT = MIS_ISR_I2C3;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | MIS_I2C3_SDA_DEL;
+		break;
+	case 4:
+		reg_map.I2C_ISR = (base & ~0xFFF) | 0x000C;
+		reg_map.I2C_INT = MIS_ISR_I2C4;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | MIS_I2C4_SDA_DEL;
+		break;
+	case 5:
+		reg_map.I2C_ISR = (base & ~0xFFF) | 0x000C;
+		reg_map.I2C_INT = MIS_ISR_I2C5;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | MIS_I2C5_SDA_DEL;
+		break;
+	case 6:
+		reg_map.I2C_ISR = (base & ~0xFFF);
+		reg_map.I2C_INT = ISO_ISR_I2C6;
+		reg_map.IC_SDA_DEL = (base & ~0xFFF) | ISO_I2C6_SDA_DEL;
+		break;
+	default:
+		break;
+	}
+
+	reg_map.I2C_ISR_EN = 0;
+	reg_map.I2C_ISR_EN_MASK = 0;
+	reg_map.IC_CON = base | I2C_CON;
+	reg_map.IC_TAR = base | I2C_TAR;
+	reg_map.IC_SAR = base | I2C_SAR;
+	reg_map.IC_HS_MADDR = base | I2C_HS_MADDR;
+	reg_map.IC_DATA_CMD = base | I2C_DATA_CMD;
+
+	reg_map.IC_FS_SCL_HCNT = base | I2C_FS_SCL_HCNT;
+	reg_map.IC_FS_SCL_LCNT = base | I2C_FS_SCL_LCNT;
+	reg_map.IC_SS_SCL_HCNT = base | I2C_SS_SCL_HCNT;
+	reg_map.IC_SS_SCL_LCNT = base | I2C_SS_SCL_LCNT;
+#ifdef CONFIG_ARCH_RTD16xx
+	if (id == 0) {
+		reg_map.IC_HS_SCL_HCNT = base | I2C_HS_SCL_HCNT;
+		reg_map.IC_HS_SCL_LCNT = base | I2C_HS_SCL_LCNT;
+	}
+#endif
+	reg_map.IC_INTR_STAT = base | I2C_INTR_STAT;
+	reg_map.IC_INTR_MASK = base | I2C_INTR_MASK;
+	reg_map.IC_RAW_INTR_STAT = base | I2C_RAW_INTR_STAT;
+	reg_map.IC_RX_TL = base | I2C_RX_TL;
+	reg_map.IC_TX_TL = base | I2C_TX_TL;
+
+	reg_map.IC_CLR_INTR = base | I2C_CLR_INTR;
+	reg_map.IC_CLR_RX_UNDER = base | I2C_CLR_RX_UNDER;
+	reg_map.IC_CLR_RX_OVER = base | I2C_CLR_RX_OVER;
+	reg_map.IC_CLR_TX_OVER = base | I2C_CLR_TX_OVER;
+	reg_map.IC_CLR_RD_REQ = base | I2C_CLR_RD_REQ;
+	reg_map.IC_CLR_TX_ABRT = base | I2C_CLR_TX_ABRT;
+	reg_map.IC_CLR_RX_DONE = base | I2C_CLR_RX_DONE;
+	reg_map.IC_CLR_ACTIVITY = base | I2C_CLR_ACTIVITY;
+	reg_map.IC_CLR_STOP_DET = base | I2C_CLR_STOP_DET;
+	reg_map.IC_CLR_START_DET = base | I2C_CLR_START_DET;
+	reg_map.IC_CLR_GEN_CALL = base | I2C_CLR_GEN_CALL;
+
+	reg_map.IC_ENABLE = base | I2C_ENABLE;
+	reg_map.IC_STATUS = base | I2C_STATUS;
+	reg_map.IC_TXFLR = base | I2C_TXFLR;
+	reg_map.IC_RXFLR = base | I2C_RXFLR;
+	reg_map.IC_SDA_HOLD = base | I2C_SDA_HOLD;
+	reg_map.IC_TX_ABRT_SOURCE = base | I2C_TX_ABRT_SOURCE;
+	reg_map.IC_SLV_DATA_NACK_ONLY = base | I2C_SLV_DATA_NACK_ONLY;
+	reg_map.IC_DMA_CR = base | I2C_DMA_CR;
+	reg_map.IC_DMA_TDLR = base | I2C_DMA_TDLR;
+	reg_map.IC_DMA_RDLR = base | I2C_DMA_RDLR;
+	reg_map.IC_SDA_SETUP = base | I2C_SDA_SETUP;
+	reg_map.IC_ACK_GENERAL_CALL = base | I2C_ACK_GENERAL_CALL;
+	reg_map.IC_ENABLE_STATUS = base | I2C_ENABLE_STATUS;
+	reg_map.IC_COMP_PARAM_1 = base | I2C_COMP_PARAM_1;
+	reg_map.IC_COMP_VERSION = base | I2C_COMP_VERSION;
+	reg_map.IC_COMP_TYPE = base | I2C_COMP_TYPE;
+	return reg_map;
+}
+
+static unsigned char rtk_i2c_flags;
+static struct rtk_i2c_handler *rtk_i2c_phy_handle[I2C_PHY_CNT] = {NULL};
+
+/*
+ * Func : create_rtk_i2c_handle
+ * Desc : create handle of rtk i2c
+ * Parm : N/A
+ * Retn : handle of rtk i2c
+ */
+struct rtk_i2c_handler *create_rtk_i2c_handle(
+	unsigned int id,
+	unsigned short sar,
+	enum ADDR_MODE sar_mode,
+	unsigned int spd,
+	unsigned int irq,
+	unsigned long base)
+{
+	struct rtk_i2c_handler *hHandle;
+
+	RTK_DEBUG("%s\n", __func__);
+
+	if (!(BIT(id) & I2C_ID_MASK))
+		return NULL;
+
+	if (((rtk_i2c_flags>>id) & 0x01))
+		return rtk_i2c_phy_handle[id];
+
+	hHandle = kmalloc(sizeof(struct rtk_i2c_handler), GFP_KERNEL);
+
+	if (hHandle != NULL) {
+		memset(hHandle, 0, sizeof(struct rtk_i2c_handler));
+		hHandle->flags = 0;
+		hHandle->id = id;
+		hHandle->irq = irq;
+		hHandle->sar = sar;
+		hHandle->sar_mode = sar_mode;
+		hHandle->spd = spd;
+		hHandle->guard_interval = 1000;
+		hHandle->tx_abort_flag = 0;
+		hHandle->init = rtk_i2c_handler_init;
+		hHandle->uninit = rtk_i2c_handler_uninit;
+		hHandle->set_spd = rtk_i2c_set_spd;
+		hHandle->set_guard_interval = rtk_i2c_set_guard_interval;
+		hHandle->set_tar = rtk_i2c_set_tar;
+		hHandle->reg_map = rtk_i2c_setup_reg_base(id, base);
+		hHandle->read = rtk_i2c_read;
+		hHandle->write = rtk_i2c_write;
+		hHandle->get_tx_abort_reason = rtk_i2c_get_tx_abort_reason;
+		hHandle->dump = rtk_i2c_dump;
+		hHandle->set_sar = rtk_i2c_set_sar;
+		hHandle->slave_mode_enable = rtk_i2c_slave_mode_enable;
+		hHandle->register_slave_ops = rtk_i2c_register_slave_ops;
+		/* GPIO */
+		//hHandle->set_port = rtk_i2c_set_port;
+		//hHandle->gpio_read = rtk_g2c_read;
+		//hHandle->gpio_write = rtk_g2c_write;
+#ifdef EDID_4BLOCK_SUPPORT
+		hHandle->read_edid_seg = rtk_i2c_read_edid_seg;
+#endif
+		atomic_set(&hHandle->ref_cnt, 1);
+		memset(&hHandle->xfer, 0, sizeof(struct rtk_i2c_xfer));
+		rtk_i2c_phy_handle[id] = hHandle;
+		rtk_i2c_flags |= (0x01 << id);
+	}
+
+	return hHandle;
+}
+EXPORT_SYMBOL(create_rtk_i2c_handle);
+
+/*
+ * Func : destroy_rtk_i2c_handle
+ * Desc : destroy handle of rtk i2c
+ * Parm : N/A
+ * Retn : N/A
+ */
+void destroy_rtk_i2c_handle(struct rtk_i2c_handler *hHandle)
+{
+	RTK_DEBUG("%s\n", __func__);
+
+	if (hHandle == NULL)
+		return;
+
+	if (atomic_dec_return(&hHandle->ref_cnt) > 0) {
+		pr_info("[I2C] destroy I2C%d successed, reference cnt=%d\n",
+			hHandle->id, atomic_read(&hHandle->ref_cnt));
+		return;
+	}
+
+	pr_info("[I2C] destroy rtk i2c%d handle\n", hHandle->id);
+	hHandle->uninit(hHandle);
+	rtk_i2c_flags &= ~(0x01 << hHandle->id);
+	rtk_i2c_phy_handle[hHandle->id] = NULL;
+	kfree(hHandle);
+}
+EXPORT_SYMBOL(destroy_rtk_i2c_handle);
+
+MODULE_AUTHOR("James Tai <james.tai@realtek.com>");
+MODULE_DESCRIPTION("Realtek I2C bus adapter");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rtk_i2c");
diff --git a/drivers/i2c/busses/i2c-rtk-priv.h b/drivers/i2c/busses/i2c-rtk-priv.h
new file mode 100755
index 000000000..0a3ff4906
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rtk-priv.h
@@ -0,0 +1,323 @@
+/*
+ * Realtek I2C driver
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/i2c.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/atomic.h>
+
+#include "i2c-rtk.h"
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+extern int ta_i2c_init(void);
+extern void ta_hdcp_lib_set_i2c_enable(unsigned int  i2c_enable_value);
+#endif
+
+#define FIFO_THRESHOLD 4
+#define ADDR_10BITS_MASK 0x3FF
+#define ADDR_7BITS_MASK 0x7F
+
+#ifdef CONFIG_ARCH_RTD119X
+#define I2C_ID_MASK 0x7F
+
+#elif defined(CONFIG_ARCH_RTD129x)
+#define I2C_ID_MASK 0x3F
+
+#elif defined(CONFIG_ARCH_RTD139x)
+
+#define I2C_ID_MASK 0x23
+
+#elif defined(CONFIG_ARCH_RTD16xx)
+
+#define I2C_ID_MASK 0x3B
+
+#elif defined(CONFIG_ARCH_RTD13xx)
+
+#define I2C_ID_MASK 0x3B
+
+#endif
+
+
+/* DEFINE FLAG ENABLE */
+#define MINIMUM_DELAY_EN
+#define SPIN_LOCK_PROTECT_EN
+#define EDID_4BLOCK_SUPPORT /* For HDMI TX CTS 7-1 */
+
+/* DEBUG */
+#ifdef DEV_DEBUG
+#define RTK_DEBUG(fmt, ...) pr_info(fmt, ##__VA_ARGS__)
+#else
+#define RTK_DEBUG(fmt, ...)
+#endif /* DEV_DEBUG */
+
+/* LOG EVENT */
+#ifdef I2C_PROFILEING_EN
+#define LOG_EVENT(x) log_event(x)
+#else
+#define LOG_EVENT(x)
+#endif /* LOG EVENT */
+
+#define EVENT_START_XFER 4
+#define EVENT_STOP_XFER 5
+#define EVENT_ENTER_ISR 6
+#define EVENT_EXIT_ISR 7
+#define EVENT_EXIT_TIMEOUT 8
+
+/* SPINLOCK */
+#ifdef SPIN_LOCK_PROTECT_EN
+#if defined(CONFIG_I2C_RTK_SECURE_ACCESS)
+#define LOCK_RTK_I2C(a, b) spin_lock(a)
+#define UNLOCK_RTK_I2C(a, b) spin_unlock(a)
+#else
+#define LOCK_RTK_I2C(a, b) spin_lock_irqsave(a, b)
+#define UNLOCK_RTK_I2C(a, b) spin_unlock_irqrestore(a, b)
+#endif
+#else
+#define LOCK_RTK_I2C(a, b) do {} while (0)
+#define UNLOCK_RTK_I2C(a, b) do {} while (0)
+#endif /* SPIN_LOCK_PROTECT_EN */
+
+/* RTK I2C API */
+#define wr_reg(x, y) writel(y, (unsigned int *)x)
+#define rd_reg(x) readl((unsigned int *)x)
+#define SET_I2C_ISR(adp, x) wr_reg(adp->reg_map.I2C_ISR, x)
+#define GET_I2C_ISR(adp) rd_reg(adp->reg_map.I2C_ISR)
+#ifndef CONFIG_I2C_RTK_SECURE_ACCESS
+#define SET_IC_ENABLE(adp, x) wr_reg(adp->reg_map.IC_ENABLE, x)
+#endif
+#define GET_IC_ENABLE(adp) rd_reg(adp->reg_map.IC_ENABLE)
+#define SET_IC_CON(adp, x) wr_reg(adp->reg_map.IC_CON, x)
+#define GET_IC_CON(adp) rd_reg(adp->reg_map.IC_CON)
+#define SET_IC_SAR(adp, x) wr_reg(adp->reg_map.IC_SAR, x)
+#define GET_IC_SAR(adp) rd_reg(adp->reg_map.IC_SAR)
+#define SET_IC_TAR(adp, x) wr_reg(adp->reg_map.IC_TAR, x)
+#define GET_IC_TAR(adp) rd_reg(adp->reg_map.IC_TAR)
+#define SET_IC_DATA_CMD(adp, x) wr_reg(adp->reg_map.IC_DATA_CMD, x)
+#define GET_IC_DATA_CMD(adp) rd_reg(adp->reg_map.IC_DATA_CMD)
+#define SET_IC_SS_SCL_HCNT(adp, x) wr_reg(adp->reg_map.IC_SS_SCL_HCNT, x)
+#define SET_IC_SS_SCL_LCNT(adp, x) wr_reg(adp->reg_map.IC_SS_SCL_LCNT, x)
+#define SET_IC_FS_SCL_HCNT(adp, x) wr_reg(adp->reg_map.IC_FS_SCL_HCNT, x)
+#define SET_IC_FS_SCL_LCNT(adp, x) wr_reg(adp->reg_map.IC_FS_SCL_LCNT, x)
+#define SET_IC_HS_SCL_HCNT(adp, x) wr_reg(adp->reg_map.IC_HS_SCL_HCNT, x)
+#define SET_IC_HS_SCL_LCNT(adp, x) wr_reg(adp->reg_map.IC_HS_SCL_LCNT, x)
+#define GET_IC_STATUS(adp) rd_reg(adp->reg_map.IC_STATUS)
+#define SET_IC_INTR_MASK(adp, x) wr_reg(adp->reg_map.IC_INTR_MASK, x)
+#define GET_IC_INTR_MASK(adp) rd_reg(adp->reg_map.IC_INTR_MASK)
+#define GET_IC_INTR_STAT(adp) rd_reg(adp->reg_map.IC_INTR_STAT)
+#define GET_IC_RAW_INTR_STAT(adp) rd_reg(adp->reg_map.IC_RAW_INTR_STAT)
+#define CLR_IC_INTR(adp) rd_reg(adp->reg_map.IC_CLR_INTR)
+#define CLR_IC_RX_UNDER(adp) rd_reg(adp->reg_map.IC_CLR_RX_UNDER)
+#define CLR_IC_TX_OVER(adp) rd_reg(adp->reg_map.IC_CLR_TX_OVER)
+#define CLR_IC_RD_REQ(adp) rd_reg(adp->reg_map.IC_CLR_RD_REQ)
+#define CLR_IC_RX_DONE(adp) rd_reg(adp->reg_map.IC_CLR_RX_DONE)
+#define CLR_IC_ACTIVITY(adp) rd_reg(adp->reg_map.IC_CLR_ACTIVITY)
+#define CLR_IC_GEN_CALL(adp) rd_reg(adp->reg_map.IC_CLR_GEN_CALL)
+#define CLR_IC_TX_ABRT(adp) rd_reg(adp->reg_map.IC_CLR_TX_ABRT)
+#define CLR_IC_STOP_DET(adp) rd_reg(adp->reg_map.IC_CLR_STOP_DET)
+#define GET_IC_COMP_PARAM_1(adp) rd_reg(adp->reg_map.IC_COMP_PARAM_1)
+#define GET_IC_TXFLR(adp) rd_reg(adp->reg_map.IC_TXFLR)
+#define GET_IC_RXFLR(adp) rd_reg(adp->reg_map.IC_RXFLR)
+#define GET_IC_RX_TL(adp) rd_reg(adp->reg_map.IC_RX_TL)
+#define GET_IC_TX_TL(adp) rd_reg(adp->reg_map.IC_TX_TL)
+#define GET_IC_SDA_DEL(adp) rd_reg(adp->reg_map.IC_SDA_DEL)
+#define SET_IC_RX_TL(adp, x) wr_reg(adp->reg_map.IC_RX_TL, x)
+#define SET_IC_TX_TL(adp, x) wr_reg(adp->reg_map.IC_TX_TL, x)
+#define SET_IC_SDA_DEL(adp, x) wr_reg(adp->reg_map.IC_SDA_DEL, x)
+#define GET_IC_TX_ABRT_SOURCE(adp) rd_reg(adp->reg_map.IC_TX_ABRT_SOURCE)
+#define NOT_TXFULL(adp) (GET_IC_STATUS(adp) & ST_TFNF_BIT)
+#define NOT_RXEMPTY(adp) (GET_IC_STATUS(adp) & ST_RFNE_BIT)
+
+/* TRUCT DEFINE */
+enum SPD_MODE {
+	SPD_MODE_LS = 33,
+	SPD_MODE_SS = 100,
+	SPD_MODE_FS = 400,
+	SPD_MODE_HS = 1000
+};
+
+enum ADDR_MODE {
+	ADDR_MODE_7BITS   = 7,
+	ADDR_MODE_10BITS  = 10
+};
+
+enum {
+	ECMDSPLIT = 40, /* stop detected during transfer*/
+	ETXABORT = 41,
+	ETIMEOUT = 42,
+	EILLEGALMSG = 43, /* illegal message*/
+	EADDROVERRANGE = 44, /* invalid Address*/
+};
+
+enum {
+	NON_STOP = 0, /* stop detected during transfer */
+	WAIT_STOP = 1,
+};
+
+struct rtk_i2c_xfer {
+	unsigned char mode;
+	#define I2C_IDLE 0
+	#define I2C_MASTER_READ 1
+	#define I2C_MASTER_WRITE 2
+	#define I2C_MASTER_RANDOM_READ 3
+
+	/* don't issue stop command, (for gpio xfer only) */
+	#define I2C_NO_STOP 0x01
+
+	unsigned char flags;
+	unsigned char *tx_buff;
+	unsigned short tx_buff_len;
+	unsigned short tx_len;
+	unsigned char *rx_buff;
+	unsigned short rx_buff_len;
+	unsigned short rx_len;
+	unsigned long except_time;
+	unsigned long timeout;
+	int ret; /* 0 : on going, > 0 : success, < 0 : err */
+	unsigned int tx_abort_source; /* for gpio mode */
+};
+
+struct rtk_i2c_slave_ops {
+	int (*handle_command)(int id, unsigned char *cmd, unsigned char len);
+	unsigned char (*read_data)(int id); /* read data form i2c slave */
+};
+
+struct rtk_i2c_reg_map {
+	unsigned long I2C_ISR_EN;
+	unsigned long I2C_ISR_EN_MASK;
+	unsigned long I2C_ISR;
+	unsigned long I2C_INT;
+	unsigned long IC_CON;
+	unsigned long IC_TAR;
+	unsigned long IC_SAR;
+	unsigned long IC_HS_MADDR;
+	unsigned long IC_DATA_CMD;
+	unsigned long IC_SS_SCL_HCNT;
+	unsigned long IC_SS_SCL_LCNT;
+	unsigned long IC_FS_SCL_HCNT;
+	unsigned long IC_FS_SCL_LCNT;
+	unsigned long IC_HS_SCL_HCNT;
+	unsigned long IC_HS_SCL_LCNT;
+	unsigned long IC_INTR_STAT;
+	unsigned long IC_INTR_MASK;
+	unsigned long IC_RAW_INTR_STAT;
+	unsigned long IC_RX_TL;
+	unsigned long IC_TX_TL;
+	unsigned long IC_CLR_INTR;
+	unsigned long IC_CLR_RX_UNDER;
+	unsigned long IC_CLR_RX_OVER;
+	unsigned long IC_CLR_TX_OVER;
+	unsigned long IC_CLR_RD_REQ;
+	unsigned long IC_CLR_TX_ABRT;
+	unsigned long IC_CLR_RX_DONE;
+	unsigned long IC_CLR_ACTIVITY;
+	unsigned long IC_CLR_STOP_DET;
+	unsigned long IC_CLR_START_DET;
+	unsigned long IC_CLR_GEN_CALL;
+	unsigned long IC_ENABLE;
+	unsigned long IC_STATUS;
+	unsigned long IC_TXFLR;
+	unsigned long IC_RXFLR;
+	unsigned long IC_SDA_HOLD;
+	unsigned long IC_TX_ABRT_SOURCE;
+	unsigned long IC_SLV_DATA_NACK_ONLY;
+	unsigned long IC_DMA_CR;
+	unsigned long IC_DMA_TDLR;
+	unsigned long IC_DMA_RDLR;
+	unsigned long IC_SDA_SETUP;
+	unsigned long IC_ACK_GENERAL_CALL;
+	unsigned long IC_ENABLE_STATUS;
+	unsigned long IC_COMP_PARAM_1;
+	unsigned long IC_COMP_VERSION;
+	unsigned long IC_COMP_TYPE;
+	unsigned long IC_SDA_DEL;
+};
+
+struct rtk_i2c_handler {
+#define RTK_I2C_IRQ_RDY 0x01
+#define RTK_I2C_SLAVE_ENABLE 0x80
+	unsigned int flags;
+	atomic_t ref_cnt;
+	char *model_name;
+	unsigned int irq;
+	unsigned char id;
+	unsigned int spd;
+	unsigned int tick;
+	unsigned int guard_interval;
+	unsigned short sar;
+	unsigned short tar;
+	unsigned char rx_fifo_depth;
+	unsigned char tx_fifo_depth;
+	unsigned long time_stamp;
+	unsigned char slave_rx_buffer[64];
+	unsigned int slave_rx_len;
+	unsigned long slave_id;
+	unsigned int tx_abort_flag;
+	enum ADDR_MODE tar_mode;
+	enum ADDR_MODE sar_mode;
+	struct rtk_i2c_reg_map reg_map;
+	struct rtk_i2c_xfer xfer;
+	struct rtk_i2c_slave_ops slave_ops;
+	wait_queue_head_t wq;
+	spinlock_t lock;
+	int (*init)(struct rtk_i2c_handler *handler);
+	int (*uninit)(struct rtk_i2c_handler *handler);
+	int (*set_spd)(struct rtk_i2c_handler *handler, int KHz);
+	int (*set_guard_interval)(struct rtk_i2c_handler *handler,
+		unsigned long us);
+	int (*set_tar)(struct rtk_i2c_handler *handler, unsigned short addr,
+		enum ADDR_MODE mode);
+	int (*read)(struct rtk_i2c_handler *handler, unsigned char *tx_buf,
+		unsigned short tx_buf_len, unsigned char *rx_buff,
+		unsigned short rx_buf_len);
+	int (*write)(struct rtk_i2c_handler *handler, unsigned char *tx_buf,
+		unsigned short tx_buf_len, unsigned char wait_stop);
+#if 0
+	int (*gpio_read)(struct rtk_i2c_handler *handler,
+		unsigned char *tx_buf, unsigned short tx_buf_len,
+		unsigned char *rx_buff, unsigned short rx_buf_len);
+	int (*gpio_write)(struct rtk_i2c_handler *handler,
+		unsigned char *tx_buf, unsigned short tx_buf_len,
+		unsigned char wait_stop);
+#endif
+	int (*dump)(struct rtk_i2c_handler *handler); /* for debug*/
+#if 0
+	int (*suspend)(struct rtk_i2c_handler *handler);
+	int (*resume)(struct rtk_i2c_handler *handler);
+#endif
+	unsigned int (*get_tx_abort_reason)(struct rtk_i2c_handler *handler);
+	int (*set_sar)(struct rtk_i2c_handler *handler,
+		unsigned short, enum ADDR_MODE mode);
+	int (*register_slave_ops)(struct rtk_i2c_handler *handler,
+		struct rtk_i2c_slave_ops *ops, unsigned long id);
+	int (*slave_mode_enable)(struct rtk_i2c_handler *handler,
+		unsigned char on);
+#ifdef EDID_4BLOCK_SUPPORT
+	int (*read_edid_seg)(struct rtk_i2c_handler *handler,
+		unsigned char seg, unsigned char offset,
+		unsigned char *rx_buff, unsigned short rx_buf_len);
+#endif /* EDID_4BLOCK_SUPPORT */
+
+};
+
+/* FUNCTION PROTOTYPE */
+struct rtk_i2c_handler  *create_rtk_i2c_handle(unsigned int id,
+	unsigned short sar, enum ADDR_MODE sar_mode, enum SPD_MODE spd,
+	unsigned int irq, unsigned long base);
+
+int rtk_i2c_phy_init(struct rtk_i2c_handler *handler);
+
+int rtk_i2c_load_message(struct rtk_i2c_handler *handler, unsigned char mode,
+	unsigned char *tx_buf, unsigned short tx_buf_len,
+	unsigned char *rx_buf, unsigned short rx_buf_len,
+	unsigned char xfer_flags);
+
+int rtk_i2c_start_xfer(struct rtk_i2c_handler *handler);
+unsigned int rtk_i2c_get_tx_abort_reason(struct rtk_i2c_handler *handler);
+irqreturn_t rtk_i2c_isr(int this_irq, void *dev_id);
diff --git a/drivers/i2c/busses/i2c-rtk.h b/drivers/i2c/busses/i2c-rtk.h
new file mode 100755
index 000000000..a1a37a158
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rtk.h
@@ -0,0 +1,166 @@
+/*
+ * Realtek I2C driver
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __I2C_RTK_H__
+#define __I2C_RTK_H__
+
+#include <soc/realtek/rtk_platform.h>
+
+#define MODLE_NAME        "rtk_i2c"
+#define I2C_PHY_CNT       7
+#define VERSION                "2.2"
+
+
+#define SET_I2C_CFG(phy_id, port_id)          ((0x80000000) | ((phy_id)<<8) \
+						 | (port_id))
+#define SET_G2C_CFG(sda, scl)                 ((0xC0000000) | ((sda)<<8) \
+						 | (scl))
+#define IS_I2C_CFG(cfg)                       ((cfg & 0xFFFF0000) == 0x80000000)
+#define IS_G2C_CFG(cfg)                       ((cfg & 0xFFFF0000) == 0xC0000000)
+#define IS_VALID_CFG(cfg)                     (IS_G2C_MODE(cfg) || \
+						IS_I2C_MODE(cfg))
+#define GET_I2C_PHY(cfg)                      ((cfg>>8) & 0xFF)
+#define GET_I2C_PORT(cfg)                     (cfg & 0xFF)
+#define GET_G2C_SDA(cfg)                      ((cfg>>8) & 0xFF)
+#define GET_G2C_SCL(cfg)                      (cfg & 0xFF)
+
+
+#define I2C_CON                 0x0000
+#define I2C_TAR                 0x0004
+#define I2C_SAR                 0x0008
+#define I2C_HS_MADDR            0x000c
+#define I2C_DATA_CMD            0x0010
+#define I2C_SS_SCL_HCNT         0x0014
+#define I2C_SS_SCL_LCNT         0x0018
+#define I2C_FS_SCL_HCNT         0x001c
+#define I2C_FS_SCL_LCNT         0x0020
+#define I2C_HS_SCL_HCNT         0x0024
+#define I2C_HS_SCL_LCNT         0x0028
+#define I2C_INTR_STAT           0x002c
+#define I2C_INTR_MASK           0x0030
+#define I2C_RAW_INTR_STAT       0x0034
+#define I2C_RX_TL               0x0038
+#define I2C_TX_TL               0x003c
+#define I2C_CLR_INTR            0x0040
+#define I2C_CLR_RX_UNDER        0x0044
+#define I2C_CLR_RX_OVER         0x0048
+#define I2C_CLR_TX_OVER         0x004c
+#define I2C_CLR_RD_REQ          0x0050
+#define I2C_CLR_TX_ABRT         0x0054
+#define I2C_CLR_RX_DONE         0x0058
+#define I2C_CLR_ACTIVITY        0x005c
+#define I2C_CLR_STOP_DET        0x0060
+#define I2C_CLR_START_DET       0x0064
+#define I2C_CLR_GEN_CALL        0x0068
+#define I2C_ENABLE              0x006c
+#define I2C_STATUS              0x0070
+#define I2C_TXFLR               0x0074
+#define I2C_RXFLR               0x0078
+#define I2C_SDA_HOLD            0x007c
+#define I2C_TX_ABRT_SOURCE      0x0080
+#define I2C_SLV_DATA_NACK_ONLY  0x0084
+#define I2C_DMA_CR              0x0088
+#define I2C_DMA_TDLR            0x008c
+#define I2C_DMA_RDLR            0x0090
+#define I2C_SDA_SETUP		0x0094
+#define I2C_ACK_GENERAL_CALL	0x0098
+#define I2C_ENABLE_STATUS		0x009c
+#define I2C_COMP_PARAM_1        0x00f4
+#define I2C_COMP_VERSION        0x00f8
+#define I2C_COMP_TYPE           0x00fc
+
+
+#ifdef CONFIG_ARCH_RTD119X
+#define MISC_ISR_I2C1    (0x00000001 << 4)
+#define MISC_I2C1_SDA_DEL	0x0088
+#else
+#define ISO_ISR_I2C1    (0x00000001 << 11)
+#define ISO_I2C1_SDA_DEL	0x0080
+#endif
+
+#define ISO_ISR_I2C0	(0x00000001 << 8)
+#define ISO_ISR_I2C6	(0x00000001 << 10)
+
+#define MIS_ISR_I2C2	(0x00000001 << 26)
+#define MIS_ISR_I2C3	(0x00000001 << 23)
+#define MIS_ISR_I2C4	(0x00000001 << 15)
+#define MIS_ISR_I2C5	(0x00000001 << 14)
+
+#define MIS_I2C2_SDA_DEL	0x008C
+#define MIS_I2C3_SDA_DEL	0x0090
+#define MIS_I2C4_SDA_DEL	0x0094
+#define MIS_I2C5_SDA_DEL	0x0098
+
+#define ISO_I2C0_SDA_DEL	0x0084
+#define ISO_I2C6_SDA_DEL	0x00c0
+
+
+
+/*IC_CON*/
+#define IC_SLAVE_DISABLE    0x0040
+#define IC_RESTART_EN       0x0020
+#define IC_10BITADDR_MASTER 0x0010
+#define IC_10BITADDR_SLAVE  0x0008
+#define IC_MASTER_MODE      0x0001
+
+#define IC_SPEED            0x0006
+#define SPEED_SS            0x0002
+#define SPEED_FS            0x0004
+#define SPEED_HS            0x0006
+
+/*ID_DATA*/
+#define READ_CMD            0x0100
+
+/*INT*/
+#define GEN_CALL_BIT        0x800
+#define START_DET_BIT       0x400
+#define STOP_DET_BIT        0x200
+#define ACTIVITY_BIT        0x100
+#define RX_DONE_BIT         0x080
+#define TX_ABRT_BIT         0x040
+#define RD_REQ_BIT          0x020
+#define TX_EMPTY_BIT        0x010
+#define TX_OVER_BIT         0x008
+#define RX_FULL_BIT         0x004
+#define RX_OVER_BIT         0x002
+#define RX_UNDER_BIT        0x001
+
+/*STATUS*/
+#define ST_RFF_BIT          0x10
+#define ST_RFNE_BIT         0x08
+#define ST_TFE_BIT          0x04
+#define ST_TFNF_BIT         0x02
+#define ST_ACTIVITY_BIT     0x01
+
+/*DELAY*/
+#define I2C_SDA_DEL_MASK	(0x1FF)
+#define I2C_SDA_DEL_EN		(0x00000001<<8)
+#define I2C_SDA_DEL_SEL(x)	((x & 0x1F)) /* Delay time: (unit 518ns)*/
+#define SDA_DEL_518NS		1
+#define SDA_DEL_1036NS		2
+#define SDA_DEL_1554NS		3
+#define SDA_DEL_2072NS		4
+#define SDA_DEL_2590NS		5
+
+#define I2C_M_NORMAL_SPEED	0x0000	/* 20120716 - Kevin Wang add for Standard Speed Transmission : 100Kbps */
+#define I2C_M_FAST_SPEED	0x0002	/* 20120716 - Kevin Wang add for Fast Speed Transmission : 400Kbps */
+#define I2C_M_HIGH_SPEED	0x0004	/* 20120716 - Kevin Wang add for High Speed Transmission : > 400Kbps to max 3.4 Mbps */
+#define I2C_M_LOW_SPEED		0x0006	/* 20120716 - Kevin Wang add for Low  Speed Transmission : 50Kbps */
+#define I2C_M_LOW_SPEED_80	0x0008	/* 20140910 - Victor hsu add for Low  Speed Transmission : 80Kbps */
+#define I2C_M_LOW_SPEED_66	0x000a	/* 20120716 - Kevin Wang add for Low  Speed Transmission : 66Kbps */
+#define I2C_M_LOW_SPEED_33	0x000c	/* 20140910 - Victor hsu add for Low  Speed Transmission : 33Kbps */
+#define I2C_M_LOW_SPEED_10	0x000e	/* 20140910 - Victor hsu add for Low  Speed Transmission : 10Kbps */
+#define I2C_M_SPEED_MASK	0x000e	/* 20120716 - Kevin Wang add for speed control*/
+
+#define I2C_M_NO_GUARD_TIME	0x0020	/* 20121120 - Kevin Wang add for disable guard time*/
+#define I2C_GPIO_RW		0x0080	/* 20100510 - Kevin Wang add for Venus I2C */
+
+#endif /*__I2C_RTK_H__*/
diff --git a/include/soc/realtek/rtk_platform.h b/include/soc/realtek/rtk_platform.h
new file mode 100644
index 000000000..0849bffa5
--- /dev/null
+++ b/include/soc/realtek/rtk_platform.h
@@ -0,0 +1,318 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * This file contains platform-related defines for Realtek boards.
+ *
+ * Copyright (C) 2010 by Chien-An Lin <colin@realtek.com.tw>
+ */
+
+
+#ifndef _MACH_PLATFORM_H
+#define _MACH_PLATFORM_H
+
+#define AES_CCMP_LEN		571
+#define SYSTEM_PARAMETERS_LEN	960 // 1~6
+#define MODEL_CONFIG_LEN	64	// Originally this value is 20 for libra 10bytes config and now we support 32byes for customer extra use
+#define SIGNATURE_LEN		129
+#define AES_IMG_KEY_LEN		16
+#define RSA_KEY_MODULUS_LEN	128
+#define _PRIV_LEN		1024
+#define _CUSTOM_PARAM_LEN	4096
+#if defined(CONFIG_REALTEK_PCBMGR)
+#define panel_parameter_LEN     129
+#define pcb_enum_parameter_LEN  4096
+#endif
+
+typedef struct {
+	int mode;		// 0: NTSC, 1: PAL
+	int size;
+	int color[4];
+} logo_info_struct;
+
+/* The format of "bootrev" is like "00.00.26c". The second byte of it stands for board id, and the upper half byte of board id stands for CPU id */
+/* The new format of "bootrev" is extended to be "xxxx.xxxx.xx". We support both "xx.xx.xx" and "xxxx.xxxx.xx".  */
+typedef enum {
+	realtek_qa_board		=0x0,
+	realtek_mk_board		=0x1,
+	realtek_1261_demo_board		=0x2,		/* first demo board */
+	realtek_1281_demo_board		=0x4,		/* little blue */
+	realtek_mk2_board		=0x5,		/* little white */
+	realtek_photoviewer_board	=0x7,
+	realtek_avhdd_demo_board	=0x8,		/* little yellow */
+	realtek_pvr_demo_board		=0x9,
+	realtek_pvrbox_demo_board	=0xA,
+	realtek_avhdd2_demo_board	=0xB,		/* little yellow 2 */
+	realtek_pvrbox_pc_demo_board	=0xC,		/* little yellow 2 with PC install */
+	realtek_1071_avhdd_mk_demo_board	=0xD,	/* 1071 AVHDD MK Demo Board */
+	realtek_1261_avhdd_hdd25_demo_board	=0xE,	/* 1261 2.5" AVHDD Demo Board */
+	realtek_neptune_qa_board	=0x0101,
+	realtek_neptuneB_qa_board	=0x1101,
+	realtek_neptune_demo_board	=0x0102,
+	realtek_neptuneB_demo_board	=0x1102,
+	realtek_1282_neptuneB_qa_board	=0x1103, /* 1282 Neptune B, QA Board. */
+	realtek_1282_neptuneB_demo_board	=0x1104, /* 1282 Neptune B, DEMO board. */
+	realtek_1262_neptuneB_pc_install_demo_board	=0x1105, /* 1262 Neptune B, DEMO board with PC install. */
+	realtek_1262_neptuneB_mk_board	=0x1106, /* 1262 Neptune B, MK board. */
+	realtek_1262_neptuneB_avhdd_ewha10_mk_board	=0x1107, /* 1262 Neptune B, AVHDD Ewha 1.0 MK board. */
+	realtek_1283_mars_qa_board	=0x0200, /* 1283 Mars, QA board. */
+	C01_avhdd_board			=0x10001,
+	C01_1262_avhdd_board		=0x11101, /* 1262 Neptune AVHDD Board. */
+	C01_photoviewer_board		=0x10007,
+	C02_avhdd_board			=0x20008,
+	C02_1262_Neptune_avhdd_board	=0x21101,
+	C03_pvr_8m_board		=0x30001,
+	C03_pvr_board			=0x30009,
+	C03_pvr2_board			=0x3000B,
+	C04_pvr_board			=0x40009,
+	C04_pvr2_board			=0x4000B,
+	C05_pvrbox_board		=0x5000A,
+	C05_pvrbox2_board		=0x50001,
+	C06_pvr_board			=0x60009,
+	C07_avhdd_board			=0x70001, //AVHDD with J-Micron SATA.
+	C07_pvrbox_board		=0x7000a, //PVR-BOX with PC Install.
+	C07_pvrbox2_board		=0x7000b, //PVR-BOX without PC Install.
+	C08_pvr_board			=0x80009,
+	C09_pvrbox_board		=0x90001,
+	C09_pvrbox2_board		=0x90002,
+	C0A_pvr_board			=0xa0001, //2MB NOR and 128MB+ NAND.Behavior is the same with C0003.B000b
+	C0B_dvr_board			=0xb1101, //Neptune 1282 DVR Demo Board.
+	C0C_avhdd_board			=0xc0001,
+	C0D_pvr_board			=0xd0001,	//8 MB PVR Module.
+	C0E_dvr_board			=0xe0001,	//1281 2MB DVR (little blue).
+	C0F_1061_avhdd_hdd35_board	=0xf0001,	//1061 AVHDD with 3.5" HDD.
+	C0F_1061_avhdd_board		=0xf0002,	//1061 AVHDD without HDD.
+	C0F_1262_avhdd_hdd35_board	=0xf1101,	//1262 AVHDD with 3.5" HDD.
+	C0F_1262_avhdd_hdd25_board	=0xf1102,	//1262 AVHDD with 2.5" HDD.
+	C10_1071_avhdd_board		=0x100001,	//1071 AVHDD
+} board_id_t;
+
+/* The format of "bootrev" is like "00.00.26c". The first byte of it stands for company id */
+typedef enum {
+	company_realtek		=0x0,
+	company_alpha		=0x1,
+	company_C02		=0x2,
+	company_C03		=0x3,
+	company_C04		=0x4,
+	company_C05		=0x5,
+	company_C06		=0x6,
+	company_C07		=0x7,
+	company_C08		=0x8,
+	company_C09		=0x9,
+	company_C0A		=0xa,
+	company_C0B		=0xb,
+	company_C0C		=0xc,
+	company_C0D		=0xd,
+	company_C0E		=0xe,
+	company_C0F		=0xf,
+	company_C10		=0x10,
+} company_id_t;
+
+/* Defines of CPU ID */
+typedef enum {
+	realtek_venus_cpu	=0x00,
+	realtek_venus2_cpu	=0x10,
+	realtek_venus3_cpu	=0x20,
+	realtek_neptune_cpu	=0x01,
+	realtek_neptuneB_cpu	=0x11,
+	realtek_mars_cpu	=0x02,
+	realtek_marsB_cpu	=0x12,
+	realtek_marsC_cpu	=0x22,
+	realtek_marsD_cpu	=0x32,
+	realtek_jupiter_cpu	=0x03,
+	realtek_jupiterB_cpu    =0x13,
+	realtek_jupiterC_cpu    =0x23,
+	realtek_jupiterD_cpu    =0x33,
+	realtek_saturn_cpu	=0x04,
+	realtek_saturnB_cpu	=0x14,
+	realtek_darwin_cpu	=0x05,
+	realtek_macarthur_cpu	=0x06,
+	realtek_nike_cpu	=0x07,
+} cpu_id_t;
+
+typedef enum {
+	PAL,
+	NTSC,
+} tv_encoding_system_t;
+
+typedef struct {
+	board_id_t		board_id;
+	company_id_t		company_id;
+	cpu_id_t		cpu_id;
+	char			kernel_source_code_info[64];
+	char			bootloader_version[32];
+	char			ethaddr[20];			/* Ethernet Mac address */
+	int			ethtype;			/* Ethernet type. 0 for 100M; 1 for 1G */
+	char			usb_param[20];			/* USB parameter */
+	char			usb1_param[20];			/* USB parameter */
+	char			usb2_param[20];			/* USB parameter */
+	unsigned char		AES_CCMP[AES_CCMP_LEN];		/* maximum size 113. The last one may be '\0' */
+	int			AES_CCMP_len;			/* The stored length of the binary data in AES_CCMP[] */
+#if defined(CONFIG_REALTEK_PCBMGR)
+	unsigned char		panel_parameter[panel_parameter_LEN];		/* maximum size 113. The last one may be '\0' */
+	int			panel_parameter_len;			/* The stored length of the binary data in AES_CCMP[] */
+	char           pcb_enum_parameter[pcb_enum_parameter_LEN];
+	int 		   pcb_enum_parameter_len;
+#endif
+	int			update_mode;
+	char			system_parameters[SYSTEM_PARAMETERS_LEN];
+	tv_encoding_system_t	tv_encoding_system;
+	char			signature[SIGNATURE_LEN];
+	unsigned char 		modelconfig[MODEL_CONFIG_LEN];
+	int			modelconfig_len;
+	int			secure_boot;
+	char			AES_IMG_KEY[AES_IMG_KEY_LEN];
+	char			RSA_KEY_MODULUS[RSA_KEY_MODULUS_LEN];
+	char			_priv_[_PRIV_LEN];
+	char			_custom_param_[_CUSTOM_PARAM_LEN];
+	unsigned		short rtc_base_date_year;	/* The base year of RTC passed from bootloader. The default is 2005 */
+} platform_info_t;
+
+extern platform_info_t platform_info;
+
+static inline int is_venus_cpu(void) {
+/*
+	int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_VENUS
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+	if((cpu_id&0xf) == realtek_venus_cpu)
+		return 1;
+	else
+*/		return 0;
+
+}
+
+static inline int is_neptune_cpu(void) {
+/*	int cpu_id = platform_info.cpu_id;
+
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_NEPTUNE
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+	if((cpu_id&0xf) == realtek_neptune_cpu)
+		return 1;
+	else
+*/		return 0;
+}
+
+static inline int is_mars_cpu(void) {
+/*	int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_MARS
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+	if((cpu_id&0xf) == realtek_mars_cpu)
+		return 1;
+	else
+*/		return 0;
+}
+
+static inline int is_jupiter_cpu(void) {
+/*	int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_JUPITER
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+	if((cpu_id&0xf) == realtek_jupiter_cpu)
+		return 1;
+	else
+*/		return 0;
+}
+
+static inline int is_saturn_cpu(void) {
+/*        int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_SATURN
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+        if((cpu_id&0xf) == realtek_saturn_cpu)
+                return 1;
+        else
+*/                return 0;
+}
+static inline int is_nike_cpu(void) {
+/*        int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_NIKE
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+        if((cpu_id&0xf) == realtek_nike_cpu)
+                return 1;
+        else
+*/                return 0;
+}
+static inline int is_darwin_cpu(void) {
+/*        int cpu_id = platform_info.cpu_id;
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_DARWIN
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+
+        if((cpu_id&0xf) == realtek_darwin_cpu)
+                return 1;
+        else
+*/                return 0;
+}
+
+static inline int is_macarthur_cpu(void) {
+/*
+        int cpu_id = platform_info.cpu_id;
+
+	#ifdef CONFIG_REALTEK_FORCE_CPUID_AS_CHIP
+		#ifdef CONFIG_REALTEK_MACARTHUR
+		       return 1;
+		#else
+			return 0;
+		#endif
+	#endif
+        if((cpu_id&0xf) == realtek_macarthur_cpu)
+                return 1;
+        else
+*/                return 0;
+
+}
+// Return the revision number of Venus/Neptune/Mars/Jupiter... CPUs
+static inline int cpu_rev_num(void) {
+/*	return (platform_info.cpu_id&0xf0)>>4;
+*/                return 0;
+}
+
+#endif /* !(_MACH_PLATFORM_H) */
+
+
-- 
2.25.1

