From e7b37c55cd131ae1d3332598cebf2a39aa97130f Mon Sep 17 00:00:00 2001
From: Celliwig <celliwig@nym.hush.com>
Date: Sat, 8 May 2021 12:38:05 +0100
Subject: Added g2227/g2237 & RTK GPIO regulators.

---
 drivers/regulator/Kconfig                |  34 ++
 drivers/regulator/Makefile               |   4 +
 drivers/regulator/g2227-regulator.c      | 452 +++++++++++++++++++++++
 drivers/regulator/g2237-regulator.c      | 381 +++++++++++++++++++
 drivers/regulator/g22xx-regulator-core.c | 363 ++++++++++++++++++
 drivers/regulator/g22xx-regulator.h      | 109 ++++++
 drivers/regulator/rtkgpio-regulator.c    | 139 +++++++
 include/soc/realtek/rtk_cpu.h            |  61 +++
 8 files changed, 1543 insertions(+)
 create mode 100644 drivers/regulator/g2227-regulator.c
 create mode 100644 drivers/regulator/g2237-regulator.c
 create mode 100644 drivers/regulator/g22xx-regulator-core.c
 create mode 100644 drivers/regulator/g22xx-regulator.h
 create mode 100644 drivers/regulator/rtkgpio-regulator.c
 create mode 100644 include/soc/realtek/rtk_cpu.h

diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 5abdd29fb..255430997 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1317,5 +1317,39 @@ config REGULATOR_QCOM_LABIBB
 	  boost regulator and IBB can be used as a negative boost regulator
 	  for LCD display panel.
 
+config REGULATOR_G22XX_CORE
+	bool
+	depends on I2C
+	help
+	  GMT G2227/G2237 common codes
+
+config REGULATOR_G2227
+	tristate "GMT G2227 Power regulators"
+	depends on I2C
+	select RTK_REGMAP_I2C
+	select REGULATOR_G22XX_CORE
+	default ARCH_RTD129x
+	help
+	  This driver provides support for the voltage regulators on the
+	  GMT G2227 PMIC.
+
+config REGULATOR_G2237
+	tristate "GMT G2237 Power regulators"
+	depends on I2C
+	select RTK_REGMAP_I2C
+	select REGULATOR_G22XX_CORE
+	default n
+	help
+	  This driver provides support for the voltage regulators on the
+	  GMT G2237 PMIC.
+
+config REGULATOR_RTKGPIO
+	tristate "RTK GPIO Power regulators"
+	depends on ARCH_RTD129x
+	default ARCH_RTD129x
+	help
+	  This driver provides support for the voltage regulators on the
+	  RTK GPIO REGULATOR.
+
 endif
 
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 680e539f6..00533857c 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -160,5 +160,9 @@ obj-$(CONFIG_REGULATOR_WM831X) += wm831x-ldo.o
 obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
+obj-$(CONFIG_REGULATOR_G22XX_CORE) += g22xx-regulator-core.o
+obj-$(CONFIG_REGULATOR_G2227) += g2227-regulator.o
+obj-$(CONFIG_REGULATOR_G2237) += g2237-regulator.o
+obj-$(CONFIG_REGULATOR_RTKGPIO) += rtkgpio-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff --git a/drivers/regulator/g2227-regulator.c b/drivers/regulator/g2227-regulator.c
new file mode 100644
index 000000000..7c6d18366
--- /dev/null
+++ b/drivers/regulator/g2227-regulator.c
@@ -0,0 +1,452 @@
+/*
+ * g2227-regulator.c - GMT-G2227 Regulator Driver
+ *
+ * Copyright (C) 2016-2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2016-2018 Cheng-Yu Lee <cylee12@realtek.com>
+ * Copyright (C) 2016 Simon Hsu <simon_hsu@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define pr_fmt(fmt) "g2227: " fmt
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regmap.h>
+#include <linux/suspend.h>
+#include <soc/realtek/rtk_cpu.h>
+#include <soc/realtek/rtk_regmap.h>
+#include <dt-bindings/regulator/gmt,g2227.h>
+#include "g22xx-regulator.h"
+
+/* regulator id */
+enum g2227_regulator_id {
+	G2227_ID_DCDC1 = 0,
+	G2227_ID_DCDC2,
+	G2227_ID_DCDC3,
+	G2227_ID_DCDC4,
+	G2227_ID_DCDC5,
+	G2227_ID_DCDC6,
+	G2227_ID_LDO2,
+	G2227_ID_LDO3,
+	G2227_ID_MAX
+};
+
+/* reg_field id */
+enum {
+	G2227_REG_FIELD_LPOFF_TO_DO = 0,
+	G2227_REG_FIELD_TIME_LPOFF,
+	G2227_REG_FIELD_TIME_LP,
+	G2227_REG_FIELD_TIME_IT,
+	G2227_REG_FIELD_SOFTOFF,
+
+	G2227_REG_FIELD_DCDC1_ON,
+	G2227_REG_FIELD_DCDC1_NMODE,
+	G2227_REG_FIELD_DCDC1_SMODE,
+	G2227_REG_FIELD_DCDC1_NVO,
+	G2227_REG_FIELD_DCDC1_SVO,
+
+	G2227_REG_FIELD_DCDC2_ON,
+	G2227_REG_FIELD_DCDC2_NMODE,
+	G2227_REG_FIELD_DCDC2_SMODE,
+	G2227_REG_FIELD_DCDC2_NVO,
+	G2227_REG_FIELD_DCDC2_SVO,
+
+	G2227_REG_FIELD_DCDC3_ON,
+	G2227_REG_FIELD_DCDC3_NMODE,
+	G2227_REG_FIELD_DCDC3_SMODE,
+	G2227_REG_FIELD_DCDC3_NVO,
+	G2227_REG_FIELD_DCDC3_SVO,
+
+	G2227_REG_FIELD_DCDC4_ON,
+	G2227_REG_FIELD_DCDC4_NMODE,
+	G2227_REG_FIELD_DCDC4_SMODE,
+
+	G2227_REG_FIELD_DCDC5_ON,
+	G2227_REG_FIELD_DCDC5_NMODE,
+	G2227_REG_FIELD_DCDC5_SMODE,
+	G2227_REG_FIELD_DCDC5_NVO,
+	G2227_REG_FIELD_DCDC5_SVO,
+
+	G2227_REG_FIELD_DCDC6_ON,
+	G2227_REG_FIELD_DCDC6_NMODE,
+	G2227_REG_FIELD_DCDC6_SMODE,
+	G2227_REG_FIELD_DCDC6_NVO,
+	G2227_REG_FIELD_DCDC6_SVO,
+
+	G2227_REG_FIELD_LDO2_ON,
+	G2227_REG_FIELD_LDO2_NMODE,
+	G2227_REG_FIELD_LDO2_SMODE,
+	G2227_REG_FIELD_LDO2_NVO,
+	G2227_REG_FIELD_LDO2_SVO,
+
+	G2227_REG_FIELD_LDO3_ON,
+	G2227_REG_FIELD_LDO3_NMODE,
+	G2227_REG_FIELD_LDO3_SMODE,
+	G2227_REG_FIELD_LDO3_NVO,
+	G2227_REG_FIELD_LDO3_SVO,
+
+	G2227_REG_FIELD_CHIP_ID,
+	G2227_REG_FIELD_VERSION,
+
+	G2227_REG_FIELD_MAX
+};
+
+/* reg_field */
+static const struct reg_field regs[G2227_REG_FIELD_MAX] __initconst = {
+	[G2227_REG_FIELD_LPOFF_TO_DO] = REG_FIELD(0x02, 7, 7),
+	[G2227_REG_FIELD_TIME_IT]     = REG_FIELD(0x02, 4, 5),
+	[G2227_REG_FIELD_TIME_LP]     = REG_FIELD(0x02, 2, 3),
+	[G2227_REG_FIELD_TIME_LPOFF]  = REG_FIELD(0x02, 0, 1),
+	[G2227_REG_FIELD_SOFTOFF]     = REG_FIELD(0x04, 7, 7),
+	[G2227_REG_FIELD_DCDC1_ON]    = REG_FIELD(0x05, 7, 7),
+	[G2227_REG_FIELD_DCDC2_ON]    = REG_FIELD(0x05, 6, 6),
+	[G2227_REG_FIELD_DCDC3_ON]    = REG_FIELD(0x05, 5, 5),
+	[G2227_REG_FIELD_DCDC4_ON]    = REG_FIELD(0x05, 4, 4),
+	[G2227_REG_FIELD_DCDC5_ON]    = REG_FIELD(0x05, 3, 3),
+	[G2227_REG_FIELD_DCDC6_ON]    = REG_FIELD(0x05, 2, 2),
+	[G2227_REG_FIELD_LDO2_ON]     = REG_FIELD(0x05, 1, 1),
+	[G2227_REG_FIELD_LDO3_ON]     = REG_FIELD(0x05, 0, 0),
+	[G2227_REG_FIELD_DCDC1_NMODE] = REG_FIELD(0x07, 6, 7),
+	[G2227_REG_FIELD_DCDC1_SMODE] = REG_FIELD(0x07, 4, 5),
+	[G2227_REG_FIELD_DCDC2_NMODE] = REG_FIELD(0x07, 2, 3),
+	[G2227_REG_FIELD_DCDC2_SMODE] = REG_FIELD(0x07, 0, 1),
+	[G2227_REG_FIELD_DCDC3_NMODE] = REG_FIELD(0x08, 6, 7),
+	[G2227_REG_FIELD_DCDC3_SMODE] = REG_FIELD(0x08, 4, 5),
+	[G2227_REG_FIELD_DCDC4_NMODE] = REG_FIELD(0x08, 2, 3),
+	[G2227_REG_FIELD_DCDC4_SMODE] = REG_FIELD(0x08, 0, 1),
+	[G2227_REG_FIELD_DCDC5_NMODE] = REG_FIELD(0x09, 6, 7),
+	[G2227_REG_FIELD_DCDC5_SMODE] = REG_FIELD(0x09, 4, 5),
+	[G2227_REG_FIELD_DCDC6_NMODE] = REG_FIELD(0x09, 2, 3),
+	[G2227_REG_FIELD_DCDC6_SMODE] = REG_FIELD(0x09, 0, 1),
+	[G2227_REG_FIELD_LDO2_NMODE]  = REG_FIELD(0x0A, 6, 7),
+	[G2227_REG_FIELD_LDO2_SMODE]  = REG_FIELD(0x0A, 4, 5),
+	[G2227_REG_FIELD_LDO3_NMODE]  = REG_FIELD(0x0A, 2, 3),
+	[G2227_REG_FIELD_LDO3_SMODE]  = REG_FIELD(0x0A, 0, 1),
+	[G2227_REG_FIELD_DCDC2_NVO]   = REG_FIELD(0x10, 0, 4),
+	[G2227_REG_FIELD_DCDC3_NVO]   = REG_FIELD(0x11, 0, 4),
+	[G2227_REG_FIELD_DCDC5_NVO]   = REG_FIELD(0x12, 0, 4),
+	[G2227_REG_FIELD_DCDC1_NVO]   = REG_FIELD(0x13, 6, 7),
+	[G2227_REG_FIELD_DCDC6_NVO]   = REG_FIELD(0x13, 0, 4),
+	[G2227_REG_FIELD_LDO2_NVO]    = REG_FIELD(0x14, 4, 7),
+	[G2227_REG_FIELD_LDO3_NVO]    = REG_FIELD(0x14, 0, 3),
+	[G2227_REG_FIELD_DCDC2_SVO]   = REG_FIELD(0x15, 0, 4),
+	[G2227_REG_FIELD_DCDC3_SVO]   = REG_FIELD(0x16, 0, 4),
+	[G2227_REG_FIELD_DCDC5_SVO]   = REG_FIELD(0x17, 0, 4),
+	[G2227_REG_FIELD_DCDC1_SVO]   = REG_FIELD(0x18, 6, 7),
+	[G2227_REG_FIELD_DCDC6_SVO]   = REG_FIELD(0x18, 0, 4),
+	[G2227_REG_FIELD_LDO2_SVO]    = REG_FIELD(0x19, 4, 7),
+	[G2227_REG_FIELD_LDO3_SVO]    = REG_FIELD(0x19, 0, 3),
+	[G2227_REG_FIELD_CHIP_ID]     = REG_FIELD(0x20, 3, 7),
+	[G2227_REG_FIELD_VERSION]     = REG_FIELD(0x20, 0, 2),
+};
+
+/* desc initdata */
+static struct g22xx_desc_initdata initdata[G2227_ID_MAX] = {
+	[G2227_ID_DCDC1] = G22XX_DESC_INITDATA(G2227, DCDC1, regs),
+	[G2227_ID_DCDC2] = G22XX_DESC_INITDATA(G2227, DCDC2, regs),
+	[G2227_ID_DCDC3] = G22XX_DESC_INITDATA(G2227, DCDC3, regs),
+	[G2227_ID_DCDC4] = G22XX_DESC_INITDATA_NO_VO(G2227, DCDC4, regs),
+	[G2227_ID_DCDC5] = G22XX_DESC_INITDATA(G2227, DCDC5, regs),
+	[G2227_ID_DCDC6] = G22XX_DESC_INITDATA(G2227, DCDC6, regs),
+	[G2227_ID_LDO2]  = G22XX_DESC_INITDATA(G2227, LDO2, regs),
+	[G2227_ID_LDO3]  = G22XX_DESC_INITDATA(G2227, LDO3, regs),
+};
+
+/* voltage table */
+static const unsigned int dcdc1_vtbl[] = {
+	3000000, 3100000, 3200000, 3300000,
+};
+
+static const unsigned int dcdcx_vtbl[] = {
+	 800000,  812500,  825000,  837500,  850000,  862500,  875000,  887500,
+	 900000,  912500,  925000,  937500,  950000,  962500,  975000,  987500,
+	1000000, 1012500, 1025000, 1037500, 1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500, 1150000, 1162500, 1175000, 1187500,
+};
+
+static const unsigned int dcdc4_vtbl[] = {
+	1800000,
+};
+
+static const unsigned int ldo_vtbl[] = {
+	 800000,  850000,  900000,  950000, 1000000, 1100000, 1200000, 1300000,
+	1500000, 1600000, 1800000, 1900000, 2500000, 2600000, 3000000, 3100000,
+};
+
+/* mode mapping callback */
+static unsigned int g2227_regulator_dc_of_map_mode(unsigned int mode)
+{
+	if (mode == G2227_DC_MODE_FORCE_PWM)
+		return REGULATOR_MODE_FAST;
+	return REGULATOR_MODE_NORMAL;
+}
+
+static unsigned int g2227_regulator_ldo_of_map_mode(unsigned int mode)
+{
+	if (mode == G2227_LDO_MODE_ECO)
+		return REGULATOR_MODE_IDLE;
+	return REGULATOR_MODE_NORMAL;
+}
+
+/* regulator_desc */
+static struct g22xx_desc desc[G2227_ID_MAX] = {
+	[G2227_ID_DCDC1] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC1, "dcdc1", dcdc1_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+	},
+	[G2227_ID_DCDC2] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC2, "dcdc2", dcdcx_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+	},
+	[G2227_ID_DCDC3] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC3, "dcdc3", dcdcx_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+		.delay_volt_up = 40,
+	},
+	[G2227_ID_DCDC4] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC4, "dcdc4", dcdc4_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+	},
+	[G2227_ID_DCDC5] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC5, "dcdc5", dcdcx_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+	},
+	[G2227_ID_DCDC6] = {
+		.desc = G22XX_DESC(G2227_ID_DCDC6, "dcdc6", dcdcx_vtbl),
+		.desc.of_map_mode = g2227_regulator_dc_of_map_mode,
+	},
+	[G2227_ID_LDO2] = {
+		.desc = G22XX_DESC(G2227_ID_LDO2, "ldo2", ldo_vtbl),
+		.desc.of_map_mode = g2227_regulator_ldo_of_map_mode,
+		.flags = G22XX_FLAG_TYPE_LDO,
+	},
+	[G2227_ID_LDO3] = {
+		.desc = G22XX_DESC(G2227_ID_LDO3, "ldo3", ldo_vtbl),
+		.desc.of_map_mode = g2227_regulator_ldo_of_map_mode,
+		.flags = G22XX_FLAG_TYPE_LDO,
+	},
+};
+
+/* regmap */
+static const struct reg_default g2227_regmap_defaults[] = {
+	{ .reg = 0x02, .def = 0xc7, },
+	{ .reg = 0x04, .def = 0x01, },
+	/* on/off */
+	{ .reg = 0x05, .def = 0xff, },
+	/* mode */
+	{ .reg = 0x07, .def = 0x22, },
+	{ .reg = 0x08, .def = 0x22, },
+	{ .reg = 0x09, .def = 0x22, },
+	{ .reg = 0x0a, .def = 0x22, },
+	/* nrm volt */
+	{ .reg = 0x10, .def = 0x10, },
+	{ .reg = 0x11, .def = 0x10, },
+	{ .reg = 0x12, .def = 0x10, },
+	{ .reg = 0x13, .def = 0xd0, },
+	{ .reg = 0x14, .def = 0xa2, },
+	/* slp volt */
+	{ .reg = 0x15, .def = 0x10, },
+	{ .reg = 0x16, .def = 0x10, },
+	{ .reg = 0x17, .def = 0x10, },
+	{ .reg = 0x18, .def = 0xd0, },
+	{ .reg = 0x19, .def = 0xa2, },
+	/* version */
+	{ .reg = 0x20, .def = 0xd8, },
+};
+
+static bool g2227_regmap_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return reg != 0;
+}
+
+static bool g2227_regmap_precious_reg(struct device *dev, unsigned int reg)
+{
+	return reg == 0;
+}
+
+static bool g2227_regmap_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return reg == 0x20;
+}
+
+static const struct regmap_config g2227_regmap_config_no_cache = {
+	.reg_bits         = 8,
+	.val_bits         = 8,
+	.max_register     = 0x20,
+	.writeable_reg    = g2227_regmap_writeable_reg,
+	.precious_reg     = g2227_regmap_precious_reg,
+	.volatile_reg     = g2227_regmap_volatile_reg,
+};
+
+static const struct regmap_config g2227_regmap_config = {
+	.reg_bits         = 8,
+	.val_bits         = 8,
+	.max_register     = 0x20,
+	.cache_type       = REGCACHE_FLAT,
+	.reg_defaults     = g2227_regmap_defaults,
+	.num_reg_defaults = ARRAY_SIZE(g2227_regmap_defaults),
+	.writeable_reg    = g2227_regmap_writeable_reg,
+	.precious_reg     = g2227_regmap_precious_reg,
+	.volatile_reg     = g2227_regmap_volatile_reg,
+};
+
+/* pm */
+static int g2227_regulator_suspend(struct device *dev)
+{
+	int i;
+
+//#ifdef CONFIG_SUSPEND
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY)
+//		goto done;
+//#endif
+
+	dev_info(dev, "Enter %s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(desc); i++)
+		g22xx_prepare_suspend_state(desc[i].rdev, 0);
+
+	regulator_suspend_prepare(PM_SUSPEND_MEM);
+done:
+	dev_info(dev, "Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops g2227_regulator_pm_ops = {
+	.suspend = g2227_regulator_suspend,
+};
+
+static int g2227_regulator_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+	struct g22xx_device *gdev;
+	struct regmap *regmap;
+	const struct regmap_config *cfg;
+	int i, ret;
+	unsigned int val;
+	int chip_rev;
+
+	dev_info(dev, "%s\n", __func__);
+
+	gdev = devm_kzalloc(dev, sizeof(*gdev), GFP_KERNEL);
+	if (!gdev)
+		return -ENOMEM;
+	gdev->maps = devm_kcalloc(dev, G2227_REG_FIELD_MAX,
+		sizeof(*gdev->maps), GFP_KERNEL);
+	if (!gdev->maps)
+		return -ENOMEM;
+
+	/* bootargs: disable regcache */
+	if (g22xx_regcache_disabled()) {
+		dev_info(dev, "no regcache\n");
+		cfg = &g2227_regmap_config_no_cache;
+	} else
+		cfg = &g2227_regmap_config;
+
+	regmap = devm_rtk_regmap_i2c_init(dev, client, cfg);
+	if (IS_ERR(regmap))
+		return -EINVAL;
+
+	/* convert all reg_field to regmap_field */
+	for (i = 0; i < G2227_REG_FIELD_MAX; i++) {
+		struct regmap_field *rf;
+
+		rf = devm_regmap_field_alloc(dev, regmap, regs[i]);
+		if (IS_ERR(rf)) {
+			ret = PTR_ERR(rf);
+			dev_err(dev, "Failed to alloc regmap field %d: %d\n",
+				i, ret);
+			return ret;
+		}
+		gdev->maps[i] = rf;
+	}
+
+	chip_rev = get_rtd129x_cpu_revision();
+	gdev->regmap = regmap;
+	gdev->client = client;
+	gdev->dev    = dev;
+
+	/* workaround */
+	ret = regmap_field_read(gdev->maps[G2227_REG_FIELD_VERSION], &val);
+	if (ret)
+		dev_warn(dev, "failed to reader version: %d\n", ret);
+	else
+		dev_info(dev, "g2227 version %02x\n", val);
+
+	for (i = 0; i < ARRAY_SIZE(desc); i++) {
+		ret = g22xx_regulator_register(gdev, &desc[i], &initdata[i]);
+		if (ret) {
+			dev_err(dev, "Failed to register %s: %d\n",
+				g22xx_desc_name(&desc[i]), ret);
+			return ret;
+		}
+
+		/* workaround */
+		if (desc[i].desc.id == G2227_ID_DCDC6 &&
+			(chip_rev == RTD129x_CHIP_REVISION_A00 ||
+			chip_rev == RTD129x_CHIP_REVISION_B00)) {
+			desc[i].state_mem.enabled  = ENABLE_IN_SUSPEND;
+		}
+	}
+
+	i2c_set_clientdata(client, gdev);
+
+	/* setup pm_power_off */
+	ret = g22xx_setup_pm_power_off(dev,
+		gdev->maps[G2227_REG_FIELD_SOFTOFF]);
+	if (ret == 1)
+		dev_info(dev, "system-power-controller\n");
+	else if (ret <= 0)
+		dev_err(dev, "g22xx_setup_pm_power_off() returns %d\n", ret);
+
+	/* parse dt */
+	if (of_property_read_u32(np, "g2227,lpoff-act", &val))
+		val = G2227_LPOFF_TO_SHUTDOWN;
+	regmap_field_write(gdev->maps[G2227_REG_FIELD_LPOFF_TO_DO], val);
+
+	if (of_property_read_u32(np, "g2227,lpoff-time", &val))
+		val = G2227_TIME_LPOFF_08S;
+	regmap_field_write(gdev->maps[G2227_REG_FIELD_TIME_LPOFF], val);
+
+	return 0;
+}
+
+static void g2227_regulator_shutdown(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int i;
+
+	dev_info(dev, "Enter %s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(desc); i++)
+		g22xx_prepare_suspend_state(desc[i].rdev, 1);
+	regulator_suspend_prepare(PM_SUSPEND_MEM);
+	dev_info(dev, "Exit %s\n", __func__);
+}
+
+static const struct i2c_device_id g2227_regulator_ids[] = {
+	{"gmt-g2227", 0},
+	{"gmt,g2227", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, g2227_regulator_ids);
+
+static struct i2c_driver g2227_regulator_driver = {
+	.driver = {
+		.name = "gmt-g2227",
+		.owner = THIS_MODULE,
+		.pm = &g2227_regulator_pm_ops,
+	},
+	.id_table = g2227_regulator_ids,
+	.probe    = g2227_regulator_probe,
+	.shutdown = g2227_regulator_shutdown,
+};
+module_i2c_driver(g2227_regulator_driver);
+
+MODULE_DESCRIPTION("GMT G2227 PMIC Driver");
+MODULE_AUTHOR("Simon Hsu <simon_hsu@realtek.com>");
+MODULE_AUTHOR("Cheng-Yu Lee <cylee12@realtek.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/regulator/g2237-regulator.c b/drivers/regulator/g2237-regulator.c
new file mode 100644
index 000000000..468ff8f5b
--- /dev/null
+++ b/drivers/regulator/g2237-regulator.c
@@ -0,0 +1,381 @@
+ /*
+ * g2237-regulator.c - GMT-G2237 Regulator driver
+ *
+ * Copyright (C) 2017-2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2017-2018 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define pr_fmt(fmt) "g2237: " fmt
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regmap.h>
+#include <linux/suspend.h>
+#include <soc/realtek/rtk_regmap.h>
+#include <dt-bindings/regulator/gmt,g2237.h>
+#include "g22xx-regulator.h"
+
+/* regulator id */
+enum {
+	G2237_ID_DC1 = 0,
+	G2237_ID_DC2,
+	G2237_ID_DC3,
+	G2237_ID_DC4,
+	G2237_ID_DC5,
+	G2237_ID_LDO1,
+	G2237_ID_MAX
+};
+
+/* reg_field id */
+enum {
+	G2237_REG_FIELD_LPOFF_TO_DO = 0,
+	G2237_REG_FIELD_SOFTOFF,
+	G2237_REG_FIELD_DC4_ON,
+	G2237_REG_FIELD_DC4_NMODE,
+	G2237_REG_FIELD_DC4_SMODE,
+
+	G2237_REG_FIELD_DC1_ON,
+	G2237_REG_FIELD_DC1_NMODE,
+	G2237_REG_FIELD_DC1_SMODE,
+	G2237_REG_FIELD_DC1_NVO,
+	G2237_REG_FIELD_DC1_SVO,
+
+	G2237_REG_FIELD_DC2_ON,
+	G2237_REG_FIELD_DC2_NMODE,
+	G2237_REG_FIELD_DC2_SMODE,
+	G2237_REG_FIELD_DC2_NVO,
+	G2237_REG_FIELD_DC2_SVO,
+
+	G2237_REG_FIELD_DC3_ON,
+	G2237_REG_FIELD_DC3_NMODE,
+	G2237_REG_FIELD_DC3_SMODE,
+	G2237_REG_FIELD_DC3_NVO,
+	G2237_REG_FIELD_DC3_SVO,
+
+	G2237_REG_FIELD_DC5_ON,
+	G2237_REG_FIELD_DC5_NMODE,
+	G2237_REG_FIELD_DC5_SMODE,
+	G2237_REG_FIELD_DC5_NVO,
+	G2237_REG_FIELD_DC5_SVO,
+
+	G2237_REG_FIELD_LDO1_ON,
+	G2237_REG_FIELD_LDO1_NMODE,
+	G2237_REG_FIELD_LDO1_SMODE,
+	G2237_REG_FIELD_LDO1_NVO,
+	G2237_REG_FIELD_LDO1_SVO,
+
+	G2237_REG_FIELD_MAX
+};
+
+/* regmap_field & reg_field */
+static const struct reg_field regs[G2237_REG_FIELD_MAX] __initconst = {
+	[G2237_REG_FIELD_LPOFF_TO_DO] = REG_FIELD(0x02, 7, 7),
+	[G2237_REG_FIELD_SOFTOFF]     = REG_FIELD(0x04, 7, 7),
+	[G2237_REG_FIELD_DC1_ON]      = REG_FIELD(0x05, 7, 7),
+	[G2237_REG_FIELD_DC2_ON]      = REG_FIELD(0x05, 6, 6),
+	[G2237_REG_FIELD_DC3_ON]      = REG_FIELD(0x05, 5, 5),
+	[G2237_REG_FIELD_DC4_ON]      = REG_FIELD(0x05, 4, 4),
+	[G2237_REG_FIELD_DC5_ON]      = REG_FIELD(0x05, 3, 3),
+	[G2237_REG_FIELD_LDO1_ON]     = REG_FIELD(0x05, 0, 0),
+	[G2237_REG_FIELD_DC1_NMODE]   = REG_FIELD(0x07, 6, 7),
+	[G2237_REG_FIELD_DC1_SMODE]   = REG_FIELD(0x07, 4, 5),
+	[G2237_REG_FIELD_DC2_NMODE]   = REG_FIELD(0x07, 2, 3),
+	[G2237_REG_FIELD_DC2_SMODE]   = REG_FIELD(0x07, 0, 1),
+	[G2237_REG_FIELD_DC3_NMODE]   = REG_FIELD(0x08, 6, 7),
+	[G2237_REG_FIELD_DC3_SMODE]   = REG_FIELD(0x08, 4, 5),
+	[G2237_REG_FIELD_DC4_NMODE]   = REG_FIELD(0x08, 2, 3),
+	[G2237_REG_FIELD_DC4_SMODE]   = REG_FIELD(0x08, 0, 1),
+	[G2237_REG_FIELD_DC5_NMODE]   = REG_FIELD(0x09, 6, 7),
+	[G2237_REG_FIELD_DC5_SMODE]   = REG_FIELD(0x09, 4, 5),
+	[G2237_REG_FIELD_LDO1_NMODE]  = REG_FIELD(0x09, 2, 3),
+	[G2237_REG_FIELD_LDO1_SMODE]  = REG_FIELD(0x09, 0, 1),
+	[G2237_REG_FIELD_DC1_NVO]     = REG_FIELD(0x0A, 0, 3),
+	[G2237_REG_FIELD_DC2_NVO]     = REG_FIELD(0x0B, 0, 4),
+	[G2237_REG_FIELD_DC3_NVO]     = REG_FIELD(0x0C, 0, 4),
+	[G2237_REG_FIELD_DC5_NVO]     = REG_FIELD(0x0D, 0, 3),
+	[G2237_REG_FIELD_LDO1_NVO]    = REG_FIELD(0x0E, 0, 3),
+	[G2237_REG_FIELD_DC1_SVO]     = REG_FIELD(0x0F, 0, 3),
+	[G2237_REG_FIELD_DC2_SVO]     = REG_FIELD(0x10, 0, 4),
+	[G2237_REG_FIELD_DC3_SVO]     = REG_FIELD(0x11, 0, 4),
+	[G2237_REG_FIELD_DC5_SVO]     = REG_FIELD(0x12, 0, 3),
+	[G2237_REG_FIELD_LDO1_SVO]    = REG_FIELD(0x13, 0, 3),
+};
+
+/* desc initdata */
+static struct g22xx_desc_initdata initdata[G2237_ID_MAX] = {
+	[G2237_ID_DC1]  = G22XX_DESC_INITDATA(G2237, DC1, regs),
+	[G2237_ID_DC2]  = G22XX_DESC_INITDATA(G2237, DC2, regs),
+	[G2237_ID_DC3]  = G22XX_DESC_INITDATA(G2237, DC3, regs),
+	[G2237_ID_DC4]  = G22XX_DESC_INITDATA_NO_VO(G2237, DC4, regs),
+	[G2237_ID_DC5]  = G22XX_DESC_INITDATA(G2237, DC5, regs),
+	[G2237_ID_LDO1] = G22XX_DESC_INITDATA(G2237, LDO1, regs),
+};
+
+/* voltage table */
+static const unsigned int dc1_vtbl[] = {
+	2200000, 2300000, 2400000, 2500000,
+	2600000, 2700000, 2800000, 2900000,
+	3000000, 3100000, 3200000, 3300000,
+	3400000, 3500000, 3600000, 3700000,
+};
+
+static const unsigned int dcx_vtbl[] = {
+	 800000,  812500,  825000,  837500,
+	 850000,  862500,  875000,  887500,
+	 900000,  912500,  925000,  937500,
+	 950000,  962500,  975000,  987500,
+	1000000, 1012500, 1025000, 1037500,
+	1050000, 1062500, 1075000, 1087500,
+	1100000, 1112500, 1125000, 1137500,
+	1150000, 1162500, 1175000, 1187500,
+};
+
+static const unsigned int dc4_vtbl[] = {
+	1800000,
+};
+
+static const unsigned int dc5_vtbl[] = {
+	 800000,  850000,  900000,  950000,
+	1000000, 1050000, 1100000, 1200000,
+	1300000, 1500000, 1600000, 1700000,
+	1800000, 1900000, 2000000, 2500000,
+};
+
+static const unsigned int ldo1_vtbl[] = {
+	2200000, 2300000, 2400000, 2500000,
+	2600000, 2700000, 2800000, 2900000,
+	3000000, 3000000, 3000000, 3000000,
+	3000000, 3000000, 3000000, 3000000,
+};
+
+/* mode mapping callback */
+static unsigned int g2237_regulator_dc_of_map_mode(unsigned int mode)
+{
+	if (mode == G2237_DC_MODE_FORCE_PWM)
+		return REGULATOR_MODE_FAST;
+	return REGULATOR_MODE_NORMAL;
+}
+
+static unsigned int g2237_regulator_ldo_of_map_mode(unsigned int mode)
+{
+	if (mode == G2237_LDO_MODE_ECO)
+		return REGULATOR_MODE_IDLE;
+	return REGULATOR_MODE_NORMAL;
+}
+
+/* regulator_desc */
+static struct g22xx_desc desc[G2237_ID_MAX] = {
+	[G2237_ID_DC1] = {
+		.desc = G22XX_DESC(G2237_ID_DC1, "dc1", dc1_vtbl),
+		.desc.of_map_mode = g2237_regulator_dc_of_map_mode,
+	},
+	[G2237_ID_DC2] = {
+		.desc = G22XX_DESC(G2237_ID_DC2, "dc2", dcx_vtbl),
+		.desc.of_map_mode = g2237_regulator_dc_of_map_mode,
+		.delay_volt_up = 40,
+	},
+	[G2237_ID_DC3] = {
+		.desc = G22XX_DESC(G2237_ID_DC2, "dc3", dcx_vtbl),
+		.desc.of_map_mode = g2237_regulator_dc_of_map_mode,
+	},
+	[G2237_ID_DC4] = {
+		.desc = G22XX_DESC(G2237_ID_DC2, "dc4", dc4_vtbl),
+		.desc.of_map_mode = g2237_regulator_dc_of_map_mode,
+	},
+	[G2237_ID_DC5] = {
+		.desc = G22XX_DESC(G2237_ID_DC2, "dc5", dc5_vtbl),
+		.desc.of_map_mode = g2237_regulator_dc_of_map_mode,
+	},
+	[G2237_ID_LDO1] = {
+		.desc = G22XX_DESC(G2237_ID_DC2, "ldo1", ldo1_vtbl),
+		.desc.of_map_mode = g2237_regulator_ldo_of_map_mode,
+		.flags = G22XX_FLAG_TYPE_LDO,
+	},
+};
+
+/* regmap */
+static const struct reg_default g2237_reg_defaults[] = {
+	{ .reg = 0x02, .def = 0xC7, },
+	{ .reg = 0x04, .def = 0x00, },
+	/* on/off */
+	{ .reg = 0x05, .def = 0xF9, },
+	/* mode */
+	{ .reg = 0x07, .def = 0x22, },
+	{ .reg = 0x08, .def = 0x22, },
+	{ .reg = 0x09, .def = 0x22, },
+	/* nrm volt */
+	{ .reg = 0x0A, .def = 0x0B, },
+	{ .reg = 0x0B, .def = 0x10, },
+	{ .reg = 0x0C, .def = 0x10, },
+	{ .reg = 0x0D, .def = 0x0C, },
+	{ .reg = 0x0E, .def = 0x03, },
+	/* slp volt */
+	{ .reg = 0x0F, .def = 0x0B, },
+	{ .reg = 0x10, .def = 0x10, },
+	{ .reg = 0x11, .def = 0x10, },
+	{ .reg = 0x12, .def = 0x0C, },
+	{ .reg = 0x13, .def = 0x03, },
+};
+
+static bool g2237_regmap_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return reg != 0;
+}
+
+static bool g2237_regmap_precious_reg(struct device *dev, unsigned int reg)
+{
+	return reg == 0;
+}
+
+static const struct regmap_config g2237_regmap_config_no_cache = {
+	.reg_bits         = 8,
+	.val_bits         = 8,
+	.max_register     = 0x15,
+	.writeable_reg    = g2237_regmap_writeable_reg,
+	.precious_reg     = g2237_regmap_precious_reg,
+};
+
+static const struct regmap_config g2237_regmap_config = {
+	.reg_bits         = 8,
+	.val_bits         = 8,
+	.max_register     = 0x15,
+	.cache_type       = REGCACHE_FLAT,
+	.reg_defaults     = g2237_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(g2237_reg_defaults),
+	.writeable_reg    = g2237_regmap_writeable_reg,
+	.precious_reg     = g2237_regmap_precious_reg,
+};
+
+/* pm */
+static int g2237_regulator_suspend(struct device *dev)
+{
+	int i;
+
+#ifdef CONFIG_SUSPEND
+	if (RTK_PM_STATE == PM_SUSPEND_STANDBY)
+		goto done;
+#endif
+
+	dev_info(dev, "Enter %s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(desc); i++)
+		g22xx_prepare_suspend_state(desc[i].rdev, 0);
+	regulator_suspend_prepare(PM_SUSPEND_MEM);
+done:
+	dev_info(dev, "Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops g2237_regulator_pm_ops = {
+	.suspend = g2237_regulator_suspend,
+};
+
+static int g2237_regulator_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct g22xx_device *gdev;
+	struct regmap *regmap;
+	const struct regmap_config *cfg;
+	int i, ret;
+
+	dev_info(dev, "%s\n", __func__);
+
+	gdev = devm_kzalloc(dev, sizeof(*gdev), GFP_KERNEL);
+	if (!gdev)
+		return -ENOMEM;
+	gdev->maps = devm_kcalloc(dev, G2237_REG_FIELD_MAX,
+		sizeof(*gdev->maps), GFP_KERNEL);
+	if (!gdev->maps)
+		return -ENOMEM;
+
+	/* bootargs: disable regcache */
+	if (g22xx_regcache_disabled()) {
+		dev_info(dev, "no regcache\n");
+		cfg = &g2237_regmap_config_no_cache;
+	} else
+		cfg = &g2237_regmap_config;
+
+	regmap = devm_rtk_regmap_i2c_init(dev, client, cfg);
+	if (IS_ERR(regmap))
+		return -EINVAL;
+
+	/* convert all reg_field to regmap_field */
+	for (i = 0; i < G2237_REG_FIELD_MAX; i++) {
+		struct regmap_field *rf;
+
+		rf = devm_regmap_field_alloc(dev, regmap, regs[i]);
+		if (IS_ERR(rf)) {
+			ret = PTR_ERR(rf);
+			dev_err(dev, "Failed to alloc regmap field %d: %d\n",
+				i, ret);
+			return ret;
+		}
+		gdev->maps[i] = rf;
+	}
+
+	gdev->regmap = regmap;
+	gdev->client = client;
+	gdev->dev    = dev;
+
+	for (i = 0; i < ARRAY_SIZE(desc); i++) {
+		ret = g22xx_regulator_register(gdev, &desc[i], &initdata[i]);
+		if (ret) {
+			dev_err(dev, "Failed to register %s: %d\n",
+				g22xx_desc_name(&desc[i]), ret);
+			return ret;
+		}
+	}
+
+	i2c_set_clientdata(client, gdev);
+
+	/* setup pm_power_off */
+	ret = g22xx_setup_pm_power_off(dev,
+		gdev->maps[G2237_REG_FIELD_SOFTOFF]);
+	if (ret == 1)
+		dev_info(dev, "system-power-controller\n");
+	else if (ret < 0)
+		dev_err(dev, "g22xx_setup_pm_power_off() returns %d\n", ret);
+
+	return 0;
+}
+
+static void g2237_regulator_shutdown(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int i;
+
+	dev_info(dev, "Enter %s\n", __func__);
+	for (i = 0; i < ARRAY_SIZE(desc); i++)
+		g22xx_prepare_suspend_state(desc[i].rdev, 1);
+	regulator_suspend_prepare(PM_SUSPEND_MEM);
+	dev_info(dev, "Exit %s\n", __func__);
+}
+
+static const struct i2c_device_id g2237_regulator_ids[] = {
+	{"gmt-g2237", 0},
+	{"gmt,g2237", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, g2237_regulator_ids);
+
+static struct i2c_driver g2237_regulator_driver = {
+	.driver = {
+		.name = "gmt-g2237",
+		.owner = THIS_MODULE,
+		.pm = &g2237_regulator_pm_ops,
+	},
+	.id_table = g2237_regulator_ids,
+	.probe    = g2237_regulator_probe,
+	.shutdown = g2237_regulator_shutdown,
+};
+module_i2c_driver(g2237_regulator_driver);
+
+MODULE_DESCRIPTION("GMT G2237 PMIC Driver");
+MODULE_AUTHOR("Cheng-Yu Lee <cylee12@realtek.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/regulator/g22xx-regulator-core.c b/drivers/regulator/g22xx-regulator-core.c
new file mode 100644
index 000000000..786edbadc
--- /dev/null
+++ b/drivers/regulator/g22xx-regulator-core.c
@@ -0,0 +1,363 @@
+/*
+ * g22xx-regulator-core.c - GMT-G22xx series Regulator core functions
+ *
+ * Copyright (C) 2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2018 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define pr_fmt(fmt) "g22xx: " fmt
+
+#include <linux/bitops.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/suspend.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include "g22xx-regulator.h"
+
+/* of_parse_cb */
+int g22xx_of_parse_cb(struct device_node *np,
+	const struct regulator_desc *desc, struct regulator_config *config)
+{
+	struct g22xx_desc *gd = config->driver_data;
+	struct device_node *child;
+	unsigned int val;
+
+	child = of_get_child_by_name(np, "regulator-state-coldboot");
+	if (!child)
+		child = of_get_child_by_name(np, "regulator-state-mem");
+	if (child) {
+		struct regulator_state *state = &gd->state_coldboot;
+
+		if (of_property_read_bool(child, "regulator-on-in-suspend"))
+			state->enabled = ENABLE_IN_SUSPEND;
+
+		if (of_property_read_bool(child, "regulator-off-in-suspend"))
+			state->enabled = DISABLE_IN_SUSPEND;
+
+		if (!of_property_read_u32(child, "regulator-suspend-microvolt",
+			&val))
+			state->uV = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(g22xx_of_parse_cb);
+
+/* regulator_ops */
+static int g22xx_regulator_set_mode_regmap(struct regulator_dev *rdev,
+	unsigned int mode)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+	unsigned int val = 0;
+
+	if (g22xx_is_ldo(gd))
+		val = (mode & REGULATOR_MODE_IDLE) ? 2 : 0;
+	else
+		val =  (mode & REGULATOR_MODE_FAST) ? 2 : 0;
+	return regmap_field_write(gd->nmode, val);
+}
+
+static unsigned int g22xx_regulator_get_mode_regmap(struct regulator_dev *rdev)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_field_read(gd->nmode, &val);
+	if (ret)
+		return 0;
+
+	if (g22xx_is_ldo(gd) && val == 2)
+		return REGULATOR_MODE_IDLE;
+	else if (val == 2)
+		return REGULATOR_MODE_FAST;
+	return REGULATOR_MODE_NORMAL;
+}
+
+
+static int g22xx_set_voltage_time_sel(struct regulator_dev *rdev,
+	unsigned int old_selector, unsigned int new_selector)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	if (new_selector > old_selector)
+		return gd->delay_volt_up;
+	return 0;
+}
+
+static int g22xx_set_suspend_enable(struct regulator_dev *rdev)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	dev_dbg(rdev_get_dev(rdev), "%s\n", __func__);
+	regmap_field_write(gd->smode, 0x1);
+	return 0;
+}
+
+static int g22xx_set_suspend_disable(struct regulator_dev *rdev)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	dev_dbg(rdev_get_dev(rdev), "%s\n", __func__);
+	regmap_field_write(gd->smode, 0x3);
+	return 0;
+}
+
+static int g22xx_set_suspend_voltage(struct regulator_dev *rdev,
+	int uV)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+	int vsel;
+
+	dev_dbg(rdev_get_dev(rdev), "%s\n", __func__);
+	vsel = regulator_map_voltage_iterate(gd->rdev, uV, uV);
+	if (vsel < 0)
+		return -EINVAL;
+
+	if (!gd->smode || !gd->svo)
+		return -EINVAL;
+
+	regmap_field_write(gd->smode, 0x2);
+	regmap_field_write(gd->svo, vsel);
+	return 0;
+}
+
+const struct regulator_ops g22xx_regulator_ops = {
+	.list_voltage         = regulator_list_voltage_table,
+	.map_voltage          = regulator_map_voltage_iterate,
+	.set_voltage_sel      = regulator_set_voltage_sel_regmap,
+	.get_voltage_sel      = regulator_get_voltage_sel_regmap,
+	.enable               = regulator_enable_regmap,
+	.disable              = regulator_disable_regmap,
+	.is_enabled           = regulator_is_enabled_regmap,
+	.get_mode             = g22xx_regulator_get_mode_regmap,
+	.set_mode             = g22xx_regulator_set_mode_regmap,
+	.set_voltage_time_sel = g22xx_set_voltage_time_sel,
+	.set_suspend_voltage  = g22xx_set_suspend_voltage,
+	.set_suspend_enable   = g22xx_set_suspend_enable,
+	.set_suspend_disable  = g22xx_set_suspend_disable,
+};
+EXPORT_SYMBOL_GPL(g22xx_regulator_ops);
+
+/* helper function */
+/*
+ * g22xx_prepare_suspend_state - prepare g22xx suspend state, copy the correct
+ *                               state into state_mem of decs, then call
+ *                               regulator_suspend_prepare() to do regulator
+ *                               suspend.
+ *
+ * @rdev:        regulator device
+ * @is_coldboot: state selection
+ */
+void g22xx_prepare_suspend_state(struct regulator_dev *rdev,
+	int is_coldboot)
+{
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+	struct regulator_state *state;
+
+	state = &gd->rdev->constraints->state_mem;
+	*state = is_coldboot ? gd->state_coldboot : gd->state_mem;
+}
+EXPORT_SYMBOL_GPL(g22xx_prepare_suspend_state);
+
+/* sysfs */
+static ssize_t g22xx_print_state(char *buf, int state)
+{
+	if (state > 0)
+		return sprintf(buf, "enabled\n");
+	else if (state == 0)
+		return sprintf(buf, "disabled\n");
+	else
+		return sprintf(buf, "unknown\n");
+}
+
+static ssize_t g22xx_suspend_mem_state_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	return g22xx_print_state(buf, gd->state_mem.enabled);
+}
+static DEVICE_ATTR(g22xx_suspend_mem_state, 0444,
+	g22xx_suspend_mem_state_show, NULL);
+
+static ssize_t g22xx_suspend_coldboot_uV_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	return sprintf(buf, "%d\n", gd->state_coldboot.uV);
+}
+static DEVICE_ATTR(g22xx_suspend_coldboot_microvolts, 0444,
+	g22xx_suspend_coldboot_uV_show, NULL);
+
+static ssize_t g22xx_suspend_coldboot_state_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	return g22xx_print_state(buf, gd->state_coldboot.enabled);
+}
+static DEVICE_ATTR(g22xx_suspend_coldboot_state, 0444,
+	g22xx_suspend_coldboot_state_show, NULL);
+
+static ssize_t g22xx_suspend_mem_uV_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct g22xx_desc *gd = to_g22xx_desc(rdev->desc);
+
+	return sprintf(buf, "%d\n", gd->state_mem.uV);
+}
+static DEVICE_ATTR(g22xx_suspend_mem_microvolts, 0444,
+	g22xx_suspend_mem_uV_show, NULL);
+
+static struct attribute *g22xx_dev_attrs[] = {
+	&dev_attr_g22xx_suspend_mem_state.attr,
+	&dev_attr_g22xx_suspend_mem_microvolts.attr,
+	&dev_attr_g22xx_suspend_coldboot_state.attr,
+	&dev_attr_g22xx_suspend_coldboot_microvolts.attr,
+	NULL
+};
+
+static const struct attribute_group g22xx_dev_group = {
+	.name = "realtek",
+	.attrs = g22xx_dev_attrs,
+};
+
+static int g22xx_add_sysfs(struct device *dev)
+{
+	return sysfs_create_group(&dev->kobj, &g22xx_dev_group);
+}
+
+static inline void g22xx_init_regmap_field_one(struct regmap_field **dst,
+	struct regmap_field *src)
+{
+	if (src)
+		*dst = src;
+}
+
+static inline void g22xx_init_desc(struct g22xx_desc *gd,
+	struct g22xx_desc_initdata *data, struct regmap_field **maps)
+{
+	const struct reg_field *rf;
+
+	g22xx_init_regmap_field_one(&gd->on,    maps[data->idx_on]);
+	g22xx_init_regmap_field_one(&gd->nvo,   maps[data->idx_nvo]);
+	g22xx_init_regmap_field_one(&gd->svo,   maps[data->idx_svo]);
+	g22xx_init_regmap_field_one(&gd->nmode, maps[data->idx_nmode]);
+	g22xx_init_regmap_field_one(&gd->smode, maps[data->idx_smode]);
+
+	if (data->idx_on != G22XX_REG_FIELD_INVALID) {
+		rf = &data->regs[data->idx_on];
+		gd->desc.enable_reg  = rf->reg;
+		gd->desc.enable_mask = GENMASK(rf->msb, rf->lsb);
+	}
+
+	if (data->idx_nvo != G22XX_REG_FIELD_INVALID) {
+		rf = &data->regs[data->idx_nvo];
+		gd->desc.vsel_reg  = rf->reg;
+		gd->desc.vsel_mask = GENMASK(rf->msb, rf->lsb);
+	}
+}
+
+
+int g22xx_regulator_register(struct g22xx_device *gdev, struct g22xx_desc *gd,
+	struct g22xx_desc_initdata *data)
+{
+	struct regulator_config config = {};
+	struct regulation_constraints *c;
+
+	g22xx_init_desc(gd, data, gdev->maps);
+
+	config.dev = gdev->dev;
+	config.driver_data = gd;
+	config.regmap = gdev->regmap;
+
+	gd->rdev = devm_regulator_register(gdev->dev, &gd->desc, &config);
+	if (IS_ERR(gd->rdev))
+		return PTR_ERR(gd->rdev);
+
+	c = gd->rdev->constraints;
+
+	/*
+	 * copy state_mem to gd for mem/coldboot switching. if there is no
+	 * sleep uV and mode, set the state to enable
+	 */
+	gd->state_mem = c->state_mem;
+	if (gd->state_mem.uV == 0 && gd->state_mem.enabled == DO_NOTHING_IN_SUSPEND) {
+		gd->state_mem.enabled = ENABLE_IN_SUSPEND;
+		c->state_mem = gd->state_mem;
+	}
+	if (gd->state_coldboot.uV == 0 && gd->state_coldboot.enabled == DO_NOTHING_IN_SUSPEND)
+		gd->state_coldboot.enabled = ENABLE_IN_SUSPEND;
+
+	/* enable change mode */
+	if (g22xx_is_ldo(gd))
+		c->valid_modes_mask |= REGULATOR_MODE_NORMAL
+			| REGULATOR_MODE_IDLE;
+	else
+		c->valid_modes_mask |= REGULATOR_MODE_NORMAL
+			| REGULATOR_MODE_FAST;
+	c->valid_ops_mask |= REGULATOR_CHANGE_MODE;
+
+	g22xx_add_sysfs(&gd->rdev->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(g22xx_regulator_register);
+
+/* pm_power_off */
+static struct regmap_field *g22xx_softoff;
+
+static void g22xx_pm_power_off(void)
+{
+	if (WARN_ON(g22xx_softoff == NULL))
+		return;
+
+	pr_info("[PMIC] %s\n", __func__);
+	regmap_field_write(g22xx_softoff, 0x1);
+}
+
+int g22xx_setup_pm_power_off(struct device *dev, struct regmap_field *map)
+{
+	if (!dev->of_node)
+		return -ENOENT;
+
+	if (!of_device_is_system_power_controller(dev->of_node))
+		return 0;
+
+	if (pm_power_off && pm_power_off != g22xx_pm_power_off)
+		return -EBUSY;
+
+	g22xx_softoff = map;
+	pm_power_off = g22xx_pm_power_off;
+	return 1;
+}
+EXPORT_SYMBOL_GPL(g22xx_setup_pm_power_off);
+
+/* bootargs */
+static bool g22xx_regcache_disable;
+
+bool g22xx_regcache_disabled(void)
+{
+	return g22xx_regcache_disable;
+}
+EXPORT_SYMBOL_GPL(g22xx_regcache_disabled);
+
+static int __init g22xx_regmap_setup(char *__unused)
+{
+	g22xx_regcache_disable = true;
+	return 1;
+}
+__setup("g22xx_no_regcache", g22xx_regmap_setup);
+
diff --git a/drivers/regulator/g22xx-regulator.h b/drivers/regulator/g22xx-regulator.h
new file mode 100644
index 000000000..9fbe30076
--- /dev/null
+++ b/drivers/regulator/g22xx-regulator.h
@@ -0,0 +1,109 @@
+/*
+ * g22xx-regulator.h - GMT-G22xx series Regulator
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ * Copyright (C) 2017 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __G22XX_REGULATOR_H__
+#define __G22XX_REGULATOR_H__
+
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regmap.h>
+#include <linux/bitops.h>
+
+struct g22xx_device {
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *regmap;
+	struct regmap_field **maps;
+};
+
+struct g22xx_desc {
+	struct regulator_desc desc;
+	unsigned int flags;
+
+	struct regmap_field *on;
+	struct regmap_field *nvo;
+	struct regmap_field *svo;
+	struct regmap_field *nmode;
+	struct regmap_field *smode;
+
+	struct regulator_state state_mem;
+	struct regulator_state state_coldboot;
+	struct regulator_dev *rdev;
+
+	int delay_volt_up;
+};
+
+#define to_g22xx_desc(_desc) container_of(_desc, struct g22xx_desc, desc)
+
+/* flags */
+#define G22XX_FLAG_TYPE_LDO   BIT(0)
+
+#define G22XX_DESC(_id, _name, _vtbl) {      \
+	.owner       = THIS_MODULE,          \
+	.id          = _id,                  \
+	.name        = _name,                \
+	.ops         = &g22xx_regulator_ops, \
+	.type        = REGULATOR_VOLTAGE,    \
+	.of_match    = _name,                \
+	.of_parse_cb = g22xx_of_parse_cb,    \
+	.volt_table  = _vtbl,                \
+	.n_voltages  = ARRAY_SIZE(_vtbl),    \
+}
+
+static inline const char *g22xx_desc_name(struct g22xx_desc *gd)
+{
+	return gd->desc.name;
+}
+
+static inline int g22xx_is_ldo(struct g22xx_desc *gd)
+{
+	return !!(gd->flags & G22XX_FLAG_TYPE_LDO);
+}
+
+struct g22xx_desc_initdata {
+	const struct reg_field *regs;
+	int idx_on;
+	int idx_nvo;
+	int idx_svo;
+	int idx_nmode;
+	int idx_smode;
+};
+
+#define G22XX_REG_FIELD_INVALID -1
+
+#define G22XX_DESC_INITDATA(_chip, _name, _regs) { \
+	.regs      = _regs, \
+	.idx_on    = _chip ## _REG_FIELD_ ## _name ## _ON, \
+	.idx_nvo   = _chip ## _REG_FIELD_ ## _name ## _NVO, \
+	.idx_svo   = _chip ## _REG_FIELD_ ## _name ## _SVO, \
+	.idx_nmode = _chip ## _REG_FIELD_ ## _name ## _NMODE, \
+	.idx_smode = _chip ## _REG_FIELD_ ## _name ## _SMODE, \
+}
+
+#define G22XX_DESC_INITDATA_NO_VO(_chip, _name, _regs) { \
+	.regs      = regs, \
+	.idx_on    = _chip ## _REG_FIELD_ ## _name ## _ON, \
+	.idx_nvo   = G22XX_REG_FIELD_INVALID, \
+	.idx_svo   = G22XX_REG_FIELD_INVALID, \
+	.idx_nmode = _chip ## _REG_FIELD_ ## _name ## _NMODE, \
+	.idx_smode = _chip ## _REG_FIELD_ ## _name ## _SMODE, \
+}
+
+int g22xx_of_parse_cb(struct device_node *np, const struct regulator_desc *desc,
+	struct regulator_config *config);
+extern const struct regulator_ops g22xx_regulator_ops;
+void g22xx_prepare_suspend_state(struct regulator_dev *rdev, int is_coldboot);
+int g22xx_regulator_register(struct g22xx_device *gdev, struct g22xx_desc *gd,
+	struct g22xx_desc_initdata *data);
+int g22xx_setup_pm_power_off(struct device *dev, struct regmap_field *map);
+bool g22xx_regcache_disabled(void);
+
+#endif
diff --git a/drivers/regulator/rtkgpio-regulator.c b/drivers/regulator/rtkgpio-regulator.c
new file mode 100644
index 000000000..c60fc3558
--- /dev/null
+++ b/drivers/regulator/rtkgpio-regulator.c
@@ -0,0 +1,139 @@
+#include <linux/module.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/platform_device.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/of_address.h>
+
+static struct of_regulator_match rtkgpio_matches[] = {
+	{ .name = "rtkgpio_regulator", .driver_data = NULL, },
+};
+
+int gpio0, gpio1, voltage;
+static const unsigned int rtkgpio_dcdc_map[] = {
+	0, 2, 3,
+};
+
+static int rtkgpio_list_voltage(struct regulator_dev *rdev, unsigned int sel)
+{	
+	if (!rdev->desc->volt_table) {
+		BUG_ON(!rdev->desc->volt_table);
+		return -EINVAL;
+	}
+
+	if (sel >= rdev->desc->n_voltages)
+		return -EINVAL;
+
+	return rdev->desc->volt_table[sel];
+}
+static int rtkgpio_get_voltage_sel(struct regulator_dev *rdev)
+{
+	return voltage;
+}
+
+static int rtkgpio_set_voltage_sel(struct regulator_dev *rdev, unsigned sel)
+{
+//	struct rtk_pmic_dev *pmic_dev = rdev_get_drvdata(rdev);
+	unsigned char val;
+
+	val = rtkgpio_dcdc_map[sel];
+	gpio_set_value(gpio0, val&0x1);
+	gpio_set_value(gpio1, (val&0x2)>>1);
+
+	voltage = sel;	
+	return 0;
+}
+
+static struct regulator_ops rtkgpio_regulator_ops = {
+	.list_voltage = rtkgpio_list_voltage,
+	.set_voltage_sel = rtkgpio_set_voltage_sel,
+	.get_voltage_sel = rtkgpio_get_voltage_sel,
+//	.enable = gmt_g2227_enable,
+//	.disable = gmt_g2227_disable,
+//	.is_enabled = regulator_is_enabled_regmap,
+};
+
+static const unsigned int rtkgpio_dcdc1_vtbl[] = {
+	850000, 950000, 1050000,
+};
+
+
+static struct regulator_desc rtkgpio_regulator_desc[] = {
+	{
+		.name = "rtkgpio_regulator",
+		.id = 0,
+		.ops = &rtkgpio_regulator_ops,
+		.n_voltages = ARRAY_SIZE(rtkgpio_dcdc1_vtbl),
+		.volt_table = rtkgpio_dcdc1_vtbl,
+		.type = REGULATOR_VOLTAGE,
+		.owner = THIS_MODULE,
+//		.vsel_reg = 0x13,
+//		.vsel_mask = 0xC0,
+//		.enable_reg = 0x5,
+//		.enable_mask = 1 << 7,
+	},
+};
+
+static int rtkgpio_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_config cfg = { };
+	struct of_regulator_match *match;
+	struct regulator_dev *rdev;
+	struct device *dev = &pdev->dev;
+
+	gpio0 = of_get_gpio(dev->of_node, 0);
+	gpio1 = of_get_gpio(dev->of_node, 1);
+
+	if(gpio_request(gpio0, dev->of_node->name))
+		printk(KERN_ERR "gpio_request gpio0 fail\n");
+
+	if(gpio_request(gpio1, dev->of_node->name))
+		printk(KERN_ERR "gpio_request gpio1 fail\n");
+
+	voltage = 1;	//default 950000
+
+	match = rtkgpio_matches;
+	of_regulator_match(dev, dev->of_node, match, ARRAY_SIZE(rtkgpio_matches));
+	
+	cfg.dev = dev;
+	cfg.init_data = match[0].init_data;
+	cfg.driver_data = dev_get_drvdata(&pdev->dev);
+
+	rdev = devm_regulator_register(dev, &rtkgpio_regulator_desc[0], &cfg);
+	return 0;
+}
+
+
+static struct of_device_id rtkgpio_regulator_id[] = {
+	{ .compatible = "rtkgpio-regulator" },
+	{ /* Sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, rtkgpio_regulator_id);
+
+static struct platform_driver rtkgpio_regulator_driver = {
+	.probe = rtkgpio_regulator_probe,
+//	.remove = rtkgpio_regulator_remove,
+	.driver		= {
+		.name	= "rtkgpio-regulator",
+		.of_match_table = rtkgpio_regulator_id,
+	},
+};
+
+static int __init rtkgpio_regulator_init(void)
+{
+	return platform_driver_register(&rtkgpio_regulator_driver);
+}
+subsys_initcall(rtkgpio_regulator_init);
+
+static void __exit rtkgpio_regulator_exit(void)
+{
+	platform_driver_unregister(&rtkgpio_regulator_driver);
+}
+module_exit(rtkgpio_regulator_exit);
+
+/* Module information */
+MODULE_AUTHOR("Simon Hsu");
+MODULE_DESCRIPTION("RTK GPIO voltage and current regulator driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rtk-gpio-regulator");
diff --git a/include/soc/realtek/rtk_cpu.h b/include/soc/realtek/rtk_cpu.h
new file mode 100644
index 000000000..4dcae4449
--- /dev/null
+++ b/include/soc/realtek/rtk_cpu.h
@@ -0,0 +1,61 @@
+/*
+ * rtk_cpu.h
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _RTD129x_CPU_H_INCLUDED_
+#define _RTD129x_CPU_H_INCLUDED_
+
+#include <linux/io.h>
+
+#define SB2_BASE_ADDR 0x9801A000
+#define CHIP_ID 0x00000200
+#define CHIP_REV 0x00000204
+
+#define EFUSE_ADDR 0x980171d8
+#define CHIP_INFO1 0x98007028
+
+#define RTK1295_CPU_ID 0x00000000
+#define RTK1294_CPU_ID 0x00000001
+#define RTK1296_CPU_ID 0x00000002
+
+#define RTK129x_CPU_MASK 0x00000003
+#define RTK1296_CPU_MASK 0x00000800
+
+static inline int get_rtd129x_cpu_id(void) {
+	int cpu_id = RTK1295_CPU_ID;
+
+	void __iomem *efuse_addr = ioremap(EFUSE_ADDR, 0x4);
+	void __iomem *chip_info1_addr = ioremap(CHIP_INFO1, 0x4);
+
+	if ((readl(efuse_addr) & RTK129x_CPU_MASK) == RTK1294_CPU_ID)
+		cpu_id = RTK1294_CPU_ID;
+	else if (readl(chip_info1_addr) & RTK1296_CPU_MASK)
+		cpu_id = RTK1296_CPU_ID;
+
+	iounmap(efuse_addr);
+	iounmap(chip_info1_addr);
+	return cpu_id;
+}
+
+#define RTD129x_CHIP_REVISION_A00 (0x00000000)
+#define RTD129x_CHIP_REVISION_A01 (0x00010000)
+#define RTD129x_CHIP_REVISION_B00 (0x00020000)
+
+static inline int get_rtd129x_cpu_revision(void) {
+	void __iomem *chip_revision_addr;
+	int val;
+
+	chip_revision_addr = ioremap(SB2_BASE_ADDR + CHIP_REV, 0x4);
+	val = readl(chip_revision_addr);
+	iounmap(chip_revision_addr);
+	return val;
+}
+
+#endif //_RTD129x_CPU_H_INCLUDED_
-- 
2.25.1

