From 46ffb1603139978e05354dc408fcc56f982ee9b5 Mon Sep 17 00:00:00 2001
From: Celliwig <celliwig@nym.hush.com>
Date: Sun, 2 May 2021 11:19:15 +0100
Subject: Added thermal driver.

---
 drivers/thermal/Kconfig                  |   4 +
 drivers/thermal/Makefile                 |   1 +
 drivers/thermal/realtek/Kconfig          |  14 ++
 drivers/thermal/realtek/Makefile         |   5 +
 drivers/thermal/realtek/sensor-rtd129x.c | 108 +++++++++
 drivers/thermal/realtek/sensor.c         | 270 +++++++++++++++++++++++
 drivers/thermal/realtek/sensor.h         | 118 ++++++++++
 7 files changed, 520 insertions(+)
 create mode 100644 drivers/thermal/realtek/Kconfig
 create mode 100644 drivers/thermal/realtek/Makefile
 create mode 100644 drivers/thermal/realtek/sensor-rtd129x.c
 create mode 100644 drivers/thermal/realtek/sensor.c
 create mode 100644 drivers/thermal/realtek/sensor.h

diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 7edc8dc6b..f92f57c44 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -476,6 +476,10 @@ depends on (ARCH_QCOM && OF) || COMPILE_TEST
 source "drivers/thermal/qcom/Kconfig"
 endmenu
 
+menu "Realtek thermal drivers"
+source "drivers/thermal/realtek/Kconfig"
+endmenu
+
 config ZX2967_THERMAL
 	tristate "Thermal sensors on zx2967 SoC"
 	depends on ARCH_ZX || COMPILE_TEST
diff --git a/drivers/thermal/Makefile b/drivers/thermal/Makefile
index b64dd50a6..c6b9094f4 100644
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@ -53,6 +53,7 @@ obj-y				+= intel/
 obj-$(CONFIG_TI_SOC_THERMAL)	+= ti-soc-thermal/
 obj-y				+= st/
 obj-$(CONFIG_QCOM_TSENS)	+= qcom/
+obj-$(CONFIG_RTK_THERMAL)	+= realtek/
 obj-y				+= tegra/
 obj-$(CONFIG_HISI_THERMAL)     += hisi_thermal.o
 obj-$(CONFIG_MTK_THERMAL)	+= mtk_thermal.o
diff --git a/drivers/thermal/realtek/Kconfig b/drivers/thermal/realtek/Kconfig
new file mode 100644
index 000000000..c3a6c7836
--- /dev/null
+++ b/drivers/thermal/realtek/Kconfig
@@ -0,0 +1,14 @@
+config RTK_THERMAL
+	bool "Realtek thermal management"
+	depends on OF && THERMAL_OF
+	help
+	  Enable thermal management with a generic thermal
+	  sensor driver on Realtek SoCs.
+
+	  If you want this support, you should say Y here.
+
+config RTK_THERMAL_RTD129X
+	bool "RTD-129x thermal sensor support"
+	depends on ARCH_RTD129x
+	select RTK_THERMAL
+	default ARCH_RTD129x
diff --git a/drivers/thermal/realtek/Makefile b/drivers/thermal/realtek/Makefile
new file mode 100644
index 000000000..debc7f80f
--- /dev/null
+++ b/drivers/thermal/realtek/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_RTK_THERMAL) += rtk-thermal.o
+
+rtk-thermal-y += sensor.o
+rtk-thermal-$(CONFIG_RTK_THERMAL_RTD129X) += sensor-rtd129x.o
+
diff --git a/drivers/thermal/realtek/sensor-rtd129x.c b/drivers/thermal/realtek/sensor-rtd129x.c
new file mode 100644
index 000000000..a2807e1d5
--- /dev/null
+++ b/drivers/thermal/realtek/sensor-rtd129x.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2018 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include "sensor.h"
+
+/* Thermal sensor offset
+ */
+#define TM_SENSOR_CTRL0    0x00
+#define TM_SENSOR_CTRL1    0x04
+#define TM_SENSOR_CTRL2    0x08
+#define TM_SENSOR_CTRL3    0x0C
+#define TM_SENSOR_CTRL4    0x10
+#define TM_SENSOR_CTRL5    0x14
+#define TM_SENSOR_STATUS1  0x18
+#define TM_SENSOR_STATUS2  0x1C
+
+static void rtd129x_sensor_reset(struct thermal_sensor_device *tdev, int index)
+{
+	struct thermal_sensor *sen = &tdev->sensors[index];
+
+	writel(0x01904001, sen->reg + TM_SENSOR_CTRL2);
+	writel(0x01924001, sen->reg + TM_SENSOR_CTRL2);
+	usleep_range(25000, 26000);
+}
+
+static int rtd129x_sensor_init(struct thermal_sensor_device *tdev, int index)
+{
+	struct thermal_sensor *sen = &tdev->sensors[index];
+
+	sen->reg = of_iomap(tdev->dev->of_node, index);
+	if (!sen->reg)
+		return -ENOMEM;
+	sen->available = true;
+	return 0;
+}
+
+static void rtd129x_sensor_exit(struct thermal_sensor_device *tdev, int index)
+{
+	struct thermal_sensor *sen = &tdev->sensors[index];
+
+	if (!sen->available)
+		return;
+	sen->available = false;
+	iounmap(sen->reg);
+}
+
+static inline int _SIGN_EXT(int sign_bit, unsigned int val)
+{
+	return (0 - (BIT(sign_bit) & val)) | val;
+}
+
+static inline int __hw_get_temp(void *reg)
+{
+	unsigned int val = readl(reg + TM_SENSOR_STATUS1);
+
+	return _SIGN_EXT(18, val) * 1000 / 1024;
+}
+
+static inline int __hw_check_status_error(void *reg)
+{
+	unsigned int val = readl(reg + TM_SENSOR_STATUS2);
+
+	return val == 0 || val == 0x3FFFFF;
+}
+
+static inline int rtd129x_sensor_get_temp(struct thermal_sensor_device *tdev,
+	int index, int *temp)
+{
+	struct thermal_sensor *sen = &tdev->sensors[index];
+	int t = 0;
+
+	t = __hw_get_temp(sen->reg);
+
+	if (t < -3000 || t > 150000 || __hw_check_status_error(sen->reg)) {
+		dev_info(tdev->dev, "reset: temp=%d, status={%08x, %08x}\n",
+			t, readl(sen->reg + TM_SENSOR_STATUS1),
+			readl(sen->reg + TM_SENSOR_STATUS2));
+
+		rtd129x_sensor_reset(tdev, index);
+		t = __hw_get_temp(sen->reg);
+	}
+	*temp = t;
+
+	return 0;
+}
+
+static const struct thermal_sensor_hw_ops rtd129x_hw_ops = {
+	.get_temp = rtd129x_sensor_get_temp,
+	.reset    = rtd129x_sensor_reset,
+	.init     = rtd129x_sensor_init,
+	.exit     = rtd129x_sensor_exit,
+};
+
+const struct thermal_sensor_desc rtd129x_sensor_desc = {
+	.hw_ops = &rtd129x_hw_ops,
+	.num_sensors = 1,
+};
+
diff --git a/drivers/thermal/realtek/sensor.c b/drivers/thermal/realtek/sensor.c
new file mode 100644
index 000000000..017d85e56
--- /dev/null
+++ b/drivers/thermal/realtek/sensor.c
@@ -0,0 +1,270 @@
+/*
+ * sensor.c - Realtek generic thermal sensor driver
+ *
+ * Copyright (C) 2017-2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2017-2018 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/thermal.h>
+#include "../thermal_core.h"
+#include "sensor.h"
+
+static LIST_HEAD(sensor_device_list);
+static const struct thermal_zone_of_device_ops thermal_sensor_ops;
+static const struct of_device_id thermal_sensor_of_match[];
+
+static struct thermal_sensor_device *tz_to_tdev(struct thermal_zone_device *tz)
+{
+	struct thermal_sensor_device *pos;
+
+	list_for_each_entry(pos, &sensor_device_list, list)
+		if (pos->tz == tz)
+			return pos;
+	return NULL;
+}
+
+static int thermal_sensor_change_mode(struct thermal_zone_device *tz,
+	enum thermal_device_mode mode)
+{
+	struct thermal_instance *pos;
+	struct thermal_sensor_device *tdev = tz_to_tdev(tz);
+
+	if (mode  == THERMAL_DEVICE_DISABLED) {
+		/*
+		 * do original of_thermal_ops->set_mode to update its internal
+		 * status and clear polling_delay.
+		 */
+		tdev->set_mode(tz, mode);
+
+		/* clear passive and passive_delay */
+		mutex_lock(&tz->lock);
+		tz->passive = 0;
+		tz->passive_delay = 0;
+		cancel_delayed_work(&tz->poll_queue);
+		mutex_unlock(&tz->lock);
+
+		/* reset cdev state */
+		list_for_each_entry(pos, &tz->thermal_instances, tz_node) {
+			if (pos->target == THERMAL_NO_TARGET)
+				continue;
+			pos->target = THERMAL_NO_TARGET;
+			pos->cdev->updated = false;
+		}
+
+		/* update cdev */
+		list_for_each_entry(pos, &tz->thermal_instances, tz_node)
+			thermal_cdev_update(pos->cdev);
+
+	} else {
+		mutex_lock(&tz->lock);
+		tz->passive_delay = tdev->passive_delay;
+		mutex_unlock(&tz->lock);
+		tdev->set_mode(tz, mode);
+	}
+
+	return 0;
+}
+
+static int thermal_sensor_device_add(struct device *dev,
+	struct thermal_sensor_device *tdev,
+	const struct thermal_sensor_desc *desc)
+{
+	tdev->dev = dev;
+	tdev->ops = &thermal_sensor_ops;
+	tdev->desc = desc;
+
+	tdev->sensors = devm_kcalloc(dev, desc->num_sensors,
+		sizeof(*tdev->sensors), GFP_KERNEL);
+	if (!tdev->sensors)
+		return -ENOMEM;
+
+	thermal_sensor_hw_init(tdev);
+	thermal_sensor_hw_reset(tdev);
+
+	tdev->tz = thermal_zone_of_sensor_register(dev, 0, tdev, tdev->ops);
+	if (IS_ERR(tdev->tz))
+		return PTR_ERR(tdev->tz);
+
+	list_add(&tdev->list, &sensor_device_list);
+	tdev->passive_delay = tdev->tz->passive_delay;
+	tdev->polling_delay = tdev->tz->polling_delay;
+	tdev->set_mode = tdev->tz->ops->change_mode;
+	tdev->tz->ops->change_mode = thermal_sensor_change_mode;
+	return 0;
+}
+
+void thermal_sensor_device_remove(struct thermal_sensor_device *tdev)
+{
+	list_del(&tdev->list);
+	thermal_zone_of_sensor_unregister(tdev->dev, tdev->tz);
+	thermal_sensor_hw_exit(tdev);
+}
+
+static int thermal_sensor_get_temp(void *data, int *temp)
+{
+	struct thermal_sensor_device *tdev = data;
+	int ret;
+
+	ret = thermal_sensor_hw_get_temp(tdev, temp);
+	dev_dbg(tdev->dev, "temp=%d\n", *temp);
+	return ret;
+}
+
+static int thermal_sensor_get_trend(void *data, int i,
+	enum thermal_trend *trend)
+{
+	struct thermal_sensor_device *tdev = data;
+	struct thermal_zone_device *tz = tdev->tz;
+	const struct thermal_trip *trip;
+	int delta;
+
+	/* .get_trend will be call at thermal_zone_register. */
+	if (!tz || !of_thermal_is_trip_valid(tz, i))
+		return -EINVAL;
+
+	trip = of_thermal_get_trip_points(tz) + i;
+	delta = tz->temperature - trip->temperature;
+
+	if (-500 < delta && delta < 500)
+		*trend = THERMAL_TREND_STABLE;
+	else if (delta > 5000)
+		*trend = THERMAL_TREND_RAISE_FULL;
+	else if (delta > 0)
+		*trend = THERMAL_TREND_RAISING;
+	else
+		*trend = THERMAL_TREND_DROPPING;
+
+	dev_dbg(tdev->dev, "trip%d, delta=%d, trend=%d\n", i,
+		delta, *trend);
+	return 0;
+}
+
+static const struct thermal_zone_of_device_ops thermal_sensor_ops = {
+	.get_temp  = thermal_sensor_get_temp,
+	.get_trend = thermal_sensor_get_trend,
+};
+
+static int thermal_sensor_resume(struct device *dev)
+{
+	struct thermal_sensor_device *tdev = dev_get_drvdata(dev);
+
+	dev_info(dev, "Enter %s\n", __func__);
+	thermal_sensor_hw_reset(tdev);
+	dev_info(dev, "Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops thermal_sensor_pm_ops = {
+	.resume = thermal_sensor_resume,
+};
+
+static int thermal_sensor_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct thermal_sensor_device *tdev;
+	int ret = 0;
+	const struct of_device_id *id;
+	const struct thermal_sensor_desc *desc;
+
+	dev_info(dev, "%s\n", __func__);
+
+	id = of_match_node(thermal_sensor_of_match, np);
+	if (id)
+		desc = id->data;
+
+	if (!id || !desc)
+		return -EINVAL;
+
+	tdev = devm_kzalloc(dev, sizeof(*tdev), GFP_KERNEL);
+	if (!tdev)
+		return -ENOMEM;
+
+	ret = thermal_sensor_device_add(dev, tdev, desc);
+	if (ret)
+		dev_err(dev, "thermal_sensor_add() returns %d\n", ret);
+	platform_set_drvdata(pdev, tdev);
+	return 0;
+}
+
+static void thermal_sensor_shutdown(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct thermal_sensor_device *tdev = platform_get_drvdata(pdev);
+
+	// Check if device has been removed
+	if ((tdev != NULL) && (tdev->tz != NULL)) {
+		dev_info(dev, "%s: stopping tz_dev\n", __func__);
+		tdev->tz->ops->change_mode(tdev->tz, THERMAL_DEVICE_DISABLED);
+	}
+}
+
+static int thermal_sensor_remove(struct platform_device *pdev)
+{
+	struct thermal_sensor_device *tdev = platform_get_drvdata(pdev);
+
+	// Shutdown before removing
+	thermal_sensor_shutdown(pdev);
+
+	thermal_sensor_device_remove(tdev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id thermal_sensor_of_match[] = {
+#ifdef CONFIG_RTK_THERMAL_RTD119X
+	{
+		.compatible = "realtek,rtd119x-thermal-sensor",
+		.data = &rtd119x_sensor_desc,
+	},
+#endif
+#ifdef CONFIG_RTK_THERMAL_RTD129X
+	{
+		.compatible = "realtek,rtd129x-thermal-sensor",
+		.data = &rtd129x_sensor_desc,
+	},
+#endif
+#ifdef CONFIG_RTK_THERMAL_RTD139X
+	{
+		.compatible = "realtek,rtd139x-thermal-sensor",
+		.data = &rtd139x_sensor_desc,
+	},
+#endif
+#ifdef CONFIG_RTK_THERMAL_RTD16XX
+	{
+		.compatible = "realtek,rtd16xx-thermal-sensor",
+		.data = &rtd16xx_sensor_desc,
+	},
+#endif
+	{}
+};
+
+static struct platform_driver thermal_sensor_drv = {
+	.driver = {
+		.name   = "rtk-thermal-sensor",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(thermal_sensor_of_match),
+		.pm = &thermal_sensor_pm_ops,
+	},
+	.probe    = thermal_sensor_probe,
+	.remove   = thermal_sensor_remove,
+	.shutdown = thermal_sensor_shutdown,
+};
+
+static int __init thermal_sensor_probe_init(void)
+{
+	return platform_driver_register(&thermal_sensor_drv);
+}
+late_initcall(thermal_sensor_probe_init);
diff --git a/drivers/thermal/realtek/sensor.h b/drivers/thermal/realtek/sensor.h
new file mode 100644
index 000000000..9c18803ba
--- /dev/null
+++ b/drivers/thermal/realtek/sensor.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2018 Realtek Semiconductor Corporation
+ * Copyright (C) 2018 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __REALTEK_THERMAL_H
+#define __REALTEK_THERMAL_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/thermal.h>
+
+struct thermal_sensor_device;
+
+struct thermal_sensor_hw_ops {
+	int (*init)(struct thermal_sensor_device *, int);
+	void (*exit)(struct thermal_sensor_device *, int);
+	void (*reset)(struct thermal_sensor_device *, int);
+	int (*get_temp)(struct thermal_sensor_device *, int, int *);
+};
+
+struct thermal_sensor_desc {
+	int num_sensors;
+	const struct thermal_sensor_hw_ops *hw_ops;
+};
+
+struct thermal_sensor {
+	void __iomem *reg;
+	bool available;
+	int calibration_data;
+	int weight;
+};
+
+struct thermal_sensor_device {
+	struct device *dev;
+	const struct thermal_zone_of_device_ops *ops;
+	struct thermal_zone_device *tz;
+	struct list_head list;
+	int passive_delay;
+	int polling_delay;
+	int (*set_mode)(struct thermal_zone_device *tz,
+		enum thermal_device_mode mode);
+
+	const struct thermal_sensor_desc *desc;
+	struct thermal_sensor *sensors;
+};
+
+static inline void thermal_sensor_hw_init(struct thermal_sensor_device *tdev)
+{
+	const struct thermal_sensor_desc *desc = tdev->desc;
+	int i;
+	int ret;
+
+	if (!desc->hw_ops->init)
+		return;
+
+	for (i = 0; i < desc->num_sensors; i++) {
+		ret = desc->hw_ops->init(tdev, i);
+		if (ret)
+			dev_warn(tdev->dev, "init sensor%d returns %d\n", i, ret);
+	}
+}
+
+static inline void thermal_sensor_hw_exit(struct thermal_sensor_device *tdev)
+{
+	const struct thermal_sensor_desc *desc = tdev->desc;
+	int i;
+
+	if (!desc->hw_ops->exit)
+		return;
+
+	for (i = 0; i < desc->num_sensors; i++) {
+		desc->hw_ops->exit(tdev, i);
+	}
+}
+
+static inline void thermal_sensor_hw_reset(struct thermal_sensor_device *tdev)
+{
+	const struct thermal_sensor_desc *desc = tdev->desc;
+	int i;
+
+	if (!desc->hw_ops->reset)
+		return;
+
+	for (i = 0; i < desc->num_sensors; i++)
+		desc->hw_ops->reset(tdev, i);
+}
+
+static inline int thermal_sensor_hw_get_temp(struct thermal_sensor_device *tdev,
+	int *temp)
+{
+	const struct thermal_sensor_desc *desc = tdev->desc;
+	int ret;
+	int i;
+	int t, max_t = INT_MIN;
+
+	if (!desc->hw_ops->get_temp)
+		return -EINVAL;
+
+	for (i = 0; i < desc->num_sensors; i++) {
+		ret = desc->hw_ops->get_temp(tdev, i, &t);
+		if (ret == 0 && max_t < t)
+			max_t = t;
+	}
+	*temp = max_t;
+	return 0;
+}
+
+extern const struct thermal_sensor_desc rtd119x_sensor_desc;
+extern const struct thermal_sensor_desc rtd129x_sensor_desc;
+extern const struct thermal_sensor_desc rtd139x_sensor_desc;
+extern const struct thermal_sensor_desc rtd16xx_sensor_desc;
+
+#endif
-- 
2.25.1

