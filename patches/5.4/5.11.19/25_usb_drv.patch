From c3da426cbf16ec52d8e36171dd401718458a6f54 Mon Sep 17 00:00:00 2001
From: Celliwig <celliwig@nym.hush.com>
Date: Sat, 8 May 2021 13:10:38 +0100
Subject: Added USB driver.

---
 drivers/soc/realtek/rtd129x/Makefile  |    1 +
 drivers/soc/realtek/rtd129x/rtk_usb.c |  446 +++
 drivers/usb/Kconfig                   |    4 +
 drivers/usb/core/driver.c             |   18 +
 drivers/usb/core/hub.c                |  171 ++
 drivers/usb/core/sysfs.c              |  188 ++
 drivers/usb/dwc3/Kconfig              |   24 +
 drivers/usb/dwc3/Makefile             |    4 +
 drivers/usb/dwc3/core.c               |  177 ++
 drivers/usb/dwc3/core.h               |   15 +
 drivers/usb/dwc3/debugfs.c            |    3 +
 drivers/usb/dwc3/dwc3-rtk-drd.c       |  208 ++
 drivers/usb/dwc3/dwc3-rtk-drd.h       |   24 +
 drivers/usb/dwc3/dwc3-rtk-type_c.c    | 2134 +++++++++++++
 drivers/usb/dwc3/dwc3-rtk.c           |  462 +++
 drivers/usb/dwc3/gadget.c             |   73 +
 drivers/usb/dwc3/host.c               |   14 +
 drivers/usb/dwc3/io.h                 |   25 +
 drivers/usb/dwc3/rtk-rts5400.c        |  735 +++++
 drivers/usb/gadget/composite.c        |   14 +
 drivers/usb/gadget/configfs.c         |   39 +-
 drivers/usb/gadget/udc/Kconfig        |   16 +
 drivers/usb/gadget/udc/Makefile       |    1 +
 drivers/usb/gadget/udc/core.c         |   21 +
 drivers/usb/gadget/udc/rtk-hsotg.c    | 4075 +++++++++++++++++++++++++
 drivers/usb/gadget/udc/rtk-hsotg.h    |  380 +++
 drivers/usb/host/Kconfig              |   38 +
 drivers/usb/host/Makefile             |    3 +
 drivers/usb/host/ehci-dbg.c           |   22 +
 drivers/usb/host/ehci-q.c             |   59 +
 drivers/usb/host/ehci-rtk.c           |  396 +++
 drivers/usb/host/ehci-sched.c         |   13 +
 drivers/usb/host/ehci.h               |    3 +
 drivers/usb/host/ohci-hcd.c           |    5 +
 drivers/usb/host/ohci-hub.c           |   39 +-
 drivers/usb/host/ohci-rtk.c           |  440 +++
 drivers/usb/host/ohci.h               |   35 +
 drivers/usb/host/rtk-usb-manager.c    | 1757 +++++++++++
 drivers/usb/host/xhci-hub.c           |   23 +
 drivers/usb/host/xhci-mem.c           |   65 +
 drivers/usb/host/xhci-plat.c          |   39 +
 drivers/usb/host/xhci.c               |   12 +
 drivers/usb/host/xhci.h               |   11 +
 include/soc/realtek/power-control.h   |  100 +
 include/soc/realtek/reset-helper.h    |   38 +
 include/soc/realtek/rtk_usb.h         |   40 +
 46 files changed, 12408 insertions(+), 2 deletions(-)
 create mode 100644 drivers/soc/realtek/rtd129x/rtk_usb.c
 create mode 100644 drivers/usb/dwc3/dwc3-rtk-drd.c
 create mode 100644 drivers/usb/dwc3/dwc3-rtk-drd.h
 create mode 100644 drivers/usb/dwc3/dwc3-rtk-type_c.c
 create mode 100644 drivers/usb/dwc3/dwc3-rtk.c
 create mode 100644 drivers/usb/dwc3/rtk-rts5400.c
 create mode 100644 drivers/usb/gadget/udc/rtk-hsotg.c
 create mode 100644 drivers/usb/gadget/udc/rtk-hsotg.h
 create mode 100644 drivers/usb/host/ehci-rtk.c
 create mode 100644 drivers/usb/host/ohci-rtk.c
 create mode 100644 drivers/usb/host/rtk-usb-manager.c
 create mode 100644 include/soc/realtek/power-control.h
 create mode 100644 include/soc/realtek/reset-helper.h
 create mode 100644 include/soc/realtek/rtk_usb.h

diff --git a/drivers/soc/realtek/rtd129x/Makefile b/drivers/soc/realtek/rtd129x/Makefile
index cae36dc76..d79567a1c 100644
--- a/drivers/soc/realtek/rtd129x/Makefile
+++ b/drivers/soc/realtek/rtd129x/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_ARCH_RTD129x)	+= rtk_chip.o
 obj-$(CONFIG_RTK_SW_LOCK_API)	+= rtd129x_lockapi.o
+obj-$(CONFIG_ARCH_RTD129x)	+= rtk_usb.o
diff --git a/drivers/soc/realtek/rtd129x/rtk_usb.c b/drivers/soc/realtek/rtd129x/rtk_usb.c
new file mode 100644
index 000000000..8451f4097
--- /dev/null
+++ b/drivers/soc/realtek/rtd129x/rtk_usb.c
@@ -0,0 +1,446 @@
+/*
+ * rtk_usb.c
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <soc/realtek/power-control.h>
+#include <soc/realtek/rtk_usb.h>
+#include <soc/realtek/rtk_chip.h>
+
+struct rtk_usb {
+	struct power_ctrl_reg {
+		u32 usb_ctrl;
+		/* Port 0~2 */
+		u32 usb0_sram_pwr;
+		u32 usb0_sram_pwr_ctrl;
+		/* Port 3 */
+		u32 usb1_sram_pwr;
+		u32 usb1_sram_pwr_ctrl;
+		/* l4_icg */
+		u32 p0_l4_icg;
+		u32 p1_l4_icg;
+		u32 p2_l4_icg;
+		u32 p3_l4_icg;
+
+		/* for power cut */
+		u32 usb_phy_ctrl;
+
+		u32 p0_utmi_reset;
+		u32 p1_utmi_reset;
+		u32 p2_utmi_reset;
+		u32 p3_utmi_reset;
+
+		u32 p0_pipe_reset;
+		u32 p1_pipe_reset;
+		u32 p2_pipe_reset;
+		u32 p3_pipe_reset;
+
+		/* for suspend */
+		u32 p0_gusb2phycfg;
+		u32 p0_gusb3pipectl;
+
+		u32 p1_gusb2phycfg;
+		u32 p1_gusb3pipectl;
+
+		u32 p2_gusb2phycfg;
+		u32 p2_gusb3pipectl;
+
+		u32 p3_gusb2phycfg;
+		u32 p3_gusb3pipectl;
+
+		u32 usb_charger;
+	} power_ctrl_reg;
+
+	bool usb_power_cut;
+};
+
+static struct rtk_usb *rtk_usb;
+
+/* set usb charger power */
+void rtk_usb_set_charger_power(struct rtk_usb *rtk_usb, unsigned int val)
+{
+	void __iomem *reg_charger;
+
+	if (!rtk_usb || !rtk_usb->power_ctrl_reg.usb_charger) return;
+
+	reg_charger  = ioremap(rtk_usb->power_ctrl_reg.usb_charger, 0x4);
+
+	pr_debug("set usb_charger to 0x%08x\n", val);
+
+	writel(val, reg_charger);
+
+	iounmap(reg_charger);
+}
+
+int rtk_usb_set_hw_l4icg_on_off(struct rtk_usb *rtk_usb,
+	    enum usb_port_num port_num, bool on)
+{
+	void __iomem *reg;
+
+	if (!rtk_usb)
+		return 0;
+
+	switch (port_num) {
+	case USB_PORT_0:
+		if (rtk_usb->power_ctrl_reg.p0_l4_icg) {
+			reg = ioremap(rtk_usb->power_ctrl_reg.p0_l4_icg, 0x4);
+			writel((on&BIT(0)) | readl(reg), reg);
+			iounmap(reg);
+		}
+		break;
+	case USB_PORT_1:
+		if (rtk_usb->power_ctrl_reg.p1_l4_icg) {
+			reg = ioremap(rtk_usb->power_ctrl_reg.p1_l4_icg, 0x4);
+			writel((on&BIT(0)) | readl(reg), reg);
+			iounmap(reg);
+		}
+		break;
+	case USB_PORT_2:
+		if (rtk_usb->power_ctrl_reg.p2_l4_icg) {
+			reg = ioremap(rtk_usb->power_ctrl_reg.p3_l4_icg, 0x4);
+			writel((on&BIT(0)) | readl(reg), reg);
+			iounmap(reg);
+		}
+		break;
+	case USB_PORT_3:
+		if (rtk_usb->power_ctrl_reg.p3_l4_icg) {
+			reg = ioremap(rtk_usb->power_ctrl_reg.p3_l4_icg, 0x4);
+			writel((on&BIT(0)) | readl(reg), reg);
+			iounmap(reg);
+		}
+		break;
+	default:
+		pr_err("%s Error Port num %d\n", __func__, port_num);
+		break;
+	}
+
+	return 0;
+}
+
+static int __isolate_phy_from_a_to_d(struct rtk_usb *rtk_usb)
+{
+	void __iomem *reg;
+
+	/* isolate UPHY A->D */
+	if (!rtk_usb) return 0;
+
+	pr_debug("%s START\n", __func__);
+
+	pr_debug("set USB Analog phy power off\n");
+
+	if (rtk_usb->power_ctrl_reg.usb_phy_ctrl) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.usb_phy_ctrl, 0x4);
+		writel(BIT(0) | BIT(1) | readl(reg), reg);
+		iounmap(reg);
+	}
+	if (rtk_usb->power_ctrl_reg.p0_utmi_reset) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.p0_utmi_reset, 0x4);
+		writel(BIT(0) | readl(reg), reg);
+		iounmap(reg);
+	}
+	if (rtk_usb->power_ctrl_reg.p1_utmi_reset) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.p1_utmi_reset, 0x4);
+		writel(BIT(0) | readl(reg), reg);
+		iounmap(reg);
+	}
+	if (rtk_usb->power_ctrl_reg.p2_utmi_reset) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.p2_utmi_reset, 0x4);
+		writel(BIT(0) | readl(reg), reg);
+		iounmap(reg);
+	}
+	if (get_rtd_chip_id() == CHIP_ID_RTD1296 &&
+		    rtk_usb->power_ctrl_reg.p3_utmi_reset) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.p3_utmi_reset, 0x4);
+		writel(BIT(0) | readl(reg), reg);
+		iounmap(reg);
+	}
+	if (rtk_usb->power_ctrl_reg.usb_ctrl) {
+		reg = ioremap(rtk_usb->power_ctrl_reg.usb_ctrl, 0x4);
+		writel(~(BIT(4) | BIT(5) | BIT(6)) & readl(reg), reg);
+
+		iounmap(reg);
+	}
+	pr_debug("%s END\n", __func__);
+
+	return 0;
+}
+
+static inline void __power_control_set_power(const char *name, bool power_on)
+{
+	struct power_control * pctrl = power_control_get(name);
+	if (!pctrl) {
+		pr_debug("%s: Failed to get power_control %s\n",  __func__, name);
+		return;
+	}
+
+	if (power_on)
+		power_control_power_on(pctrl);
+	else
+		power_control_power_off(pctrl);
+}
+
+int rtk_usb_iso_power_ctrl(struct rtk_usb *rtk_usb,
+	    bool power_on)
+{
+	if (!rtk_usb) return 0;
+
+	pr_debug("%s START\n", __func__);
+
+	if (rtk_usb->power_ctrl_reg.usb_ctrl &&
+		    rtk_usb->power_ctrl_reg.usb0_sram_pwr &&
+		    rtk_usb->power_ctrl_reg.usb0_sram_pwr_ctrl &&
+		    rtk_usb->power_ctrl_reg.usb1_sram_pwr &&
+		    rtk_usb->power_ctrl_reg.usb1_sram_pwr_ctrl) {
+		void __iomem *usb_ctrl =
+			    ioremap(rtk_usb->power_ctrl_reg.usb_ctrl, 0x4);
+		void __iomem *usb0_sram_pwr =
+			    ioremap(rtk_usb->power_ctrl_reg.usb0_sram_pwr, 0x4);
+		void __iomem *usb0_sram_pwr_ctrl =
+			    ioremap(rtk_usb->power_ctrl_reg.usb0_sram_pwr_ctrl, 0x4);
+		void __iomem *usb1_sram_pwr =
+			    ioremap(rtk_usb->power_ctrl_reg.usb1_sram_pwr, 0x4);
+		void __iomem *usb1_sram_pwr_ctrl =
+			   ioremap(rtk_usb->power_ctrl_reg.usb1_sram_pwr_ctrl, 0x4);
+
+		pr_info("%s power_%s ([0x%x=0x%08x)\n", __func__, power_on?"on":"off",
+			    rtk_usb->power_ctrl_reg.usb_ctrl, readl(usb_ctrl));
+
+		if (power_on) {
+			pr_debug("%s power_on\n", __func__);
+
+			pr_debug("set usb_power_domain/p0 on\n");
+#if 1
+			/* set power gating control */
+				writel((BIT(0) | BIT(4) | BIT(6)) |
+				     readl(usb_ctrl), usb_ctrl);
+			/* port0-port2 sram power */
+			//writel(0, usb0_sram_pwr);
+			writel(0x00000f00, usb0_sram_pwr_ctrl);
+			/* port3 sram power */
+			if (get_rtd_chip_id() == CHIP_ID_RTD1296) {
+				pr_info("set usb_power_domain/p3 on\n");
+				writel((BIT(1) | BIT(5)) |
+				     readl(usb_ctrl), usb_ctrl);
+				//writel(0, usb1_sram_pwr);
+				if (get_rtd_chip_revision() < RTD_CHIP_A01)
+					writel(0x00000f05, usb1_sram_pwr_ctrl);
+				else
+					writel(0x00000f00, usb1_sram_pwr_ctrl);
+			}
+			/* disable isolation cell */
+			writel(~(BIT(8) | BIT(9)) & readl(usb_ctrl), usb_ctrl);
+#else
+			__power_control_set_power("pctrl_usb_p0_mac", 1);
+			__power_control_set_power("pctrl_usb_p0_phy", 1);
+			__power_control_set_power("pctrl_usb_p0_iso", 0);
+			if (get_rtd_chip_id() == CHIP_ID_RTD1296) {
+				pr_info("set usb_power_domain/p3 on\n");
+				__power_control_set_power("pctrl_usb_p3_phy", 1);
+				__power_control_set_power("pctrl_usb_p3_mac", 1);
+				__power_control_set_power("pctrl_usb_p3_iso", 0);
+			}
+#endif
+		} else {
+			pr_debug("%s power_off\n", __func__);
+			__isolate_phy_from_a_to_d(rtk_usb);
+			if (rtk_usb->usb_power_cut &&
+				    get_rtd_chip_revision() >= RTD_CHIP_B00) {
+				writel((BIT(8) | BIT(9)) | readl(usb_ctrl), usb_ctrl);
+				// port0-port2 sram
+				writel(0, usb0_sram_pwr);
+				writel(0x00000f01, usb0_sram_pwr_ctrl);
+				// port3 sram
+				writel(0, usb1_sram_pwr);
+				if (get_rtd_chip_revision() < RTD_CHIP_A01)
+					writel(0x00000f06, usb1_sram_pwr_ctrl);
+				else
+					writel(0x00000f01, usb1_sram_pwr_ctrl);
+
+				writel(~(BIT(0) | BIT(1) | BIT(4) | BIT(5) |BIT(6)) &
+				     readl(usb_ctrl), usb_ctrl);
+			}
+		}
+		pr_info("set power_domain %s ([0x%x]=0x%08x)\n", power_on?"on":"off",
+			    rtk_usb->power_ctrl_reg.usb_ctrl, readl(usb_ctrl));
+		iounmap(usb_ctrl);
+		iounmap(usb0_sram_pwr);
+		iounmap(usb0_sram_pwr_ctrl);
+		iounmap(usb1_sram_pwr);
+		iounmap(usb1_sram_pwr_ctrl);
+	}
+	pr_debug("%s END\n", __func__);
+
+	return 0;
+}
+
+int rtk_usb_port_suspend_resume(struct rtk_usb *rtk_usb,
+	    enum usb_port_num port_num, bool is_suspend)
+{
+	void __iomem *reg_u3_port;
+	void __iomem *reg_u2_port;
+
+	if (!rtk_usb) return 0;
+
+	pr_debug("%s START\n", __func__);
+	switch (port_num) {
+	case USB_PORT_0:
+		pr_debug("set port 0 phy suspend\n");
+		if (rtk_usb->power_ctrl_reg.p0_gusb3pipectl) {
+			reg_u3_port = ioremap(rtk_usb->power_ctrl_reg.p0_gusb3pipectl, 0x4);
+			if (is_suspend)
+				writel(readl(reg_u3_port) | BIT(17), reg_u3_port);
+			else
+				writel(readl(reg_u3_port) & ~BIT(17), reg_u3_port);
+			iounmap(reg_u3_port);
+		}
+		if (rtk_usb->power_ctrl_reg.p0_gusb2phycfg) {
+			reg_u2_port = ioremap(rtk_usb->power_ctrl_reg.p0_gusb2phycfg, 0x4);
+			if (is_suspend)
+				writel(readl(reg_u2_port) | BIT(6), reg_u2_port);
+			else
+				writel(readl(reg_u2_port) & ~BIT(6), reg_u2_port);
+			iounmap(reg_u2_port);
+		}
+	break;
+	case USB_PORT_1:
+		pr_debug("set port 1 phy suspend\n");
+		if (rtk_usb->power_ctrl_reg.p1_gusb3pipectl) {
+			reg_u3_port = ioremap(rtk_usb->power_ctrl_reg.p1_gusb3pipectl, 0x4);
+			writel(readl(reg_u3_port) | BIT(17), reg_u3_port);
+			iounmap(reg_u3_port);
+		}
+		if (rtk_usb->power_ctrl_reg.p1_gusb2phycfg) {
+			reg_u2_port = ioremap(rtk_usb->power_ctrl_reg.p1_gusb2phycfg, 0x4);
+			writel(readl(reg_u2_port) | BIT(6), reg_u2_port);
+			iounmap(reg_u2_port);
+		}
+	break;
+	case USB_PORT_2:
+		pr_debug("TODO set port 2 phy suspend\n");
+	break;
+	case USB_PORT_3:
+		pr_debug("set port 3 phy suspend\n");
+		if (rtk_usb->power_ctrl_reg.p3_gusb3pipectl) {
+			reg_u3_port = ioremap(rtk_usb->power_ctrl_reg.p3_gusb3pipectl, 0x4);
+			writel(readl(reg_u3_port) | BIT(17), reg_u3_port);
+			iounmap(reg_u3_port);
+		}
+		if (rtk_usb->power_ctrl_reg.p3_gusb2phycfg) {
+			reg_u2_port = ioremap(rtk_usb->power_ctrl_reg.p3_gusb2phycfg, 0x4);
+			writel(readl(reg_u2_port) | BIT(6), reg_u2_port);
+			iounmap(reg_u2_port);
+		}
+	break;
+	default:
+		pr_err("Error port num %d\n", port_num);
+	}
+	pr_debug("%s END\n", __func__);
+	return 0;
+}
+
+struct rtk_usb *rtk_usb_soc_init(struct device_node *sub_node)
+{
+	if (!rtk_usb)
+		rtk_usb = kzalloc(sizeof(struct rtk_usb), GFP_KERNEL);
+
+	pr_debug("%s START\n", __func__);
+	if (sub_node) {
+		pr_debug("%s sub_node %s\n", __func__, sub_node->name);
+		of_property_read_u32(sub_node,
+			    "usb_ctrl", &rtk_usb->power_ctrl_reg.usb_ctrl);
+		/* Port 0~2 */
+		of_property_read_u32(sub_node,
+			    "usb0_sram_pwr", &rtk_usb->power_ctrl_reg.usb0_sram_pwr);
+		of_property_read_u32(sub_node,
+			    "usb0_sram_pwr_ctrl",
+			    &rtk_usb->power_ctrl_reg.usb0_sram_pwr_ctrl);
+		/* Port 3 */
+		of_property_read_u32(sub_node,
+			    "usb1_sram_pwr", &rtk_usb->power_ctrl_reg.usb1_sram_pwr);
+		of_property_read_u32(sub_node,
+			    "usb1_sram_pwr_ctrl",
+			    &rtk_usb->power_ctrl_reg.usb1_sram_pwr_ctrl);
+
+		of_property_read_u32(sub_node,
+			    "p0_l4_icg", &rtk_usb->power_ctrl_reg.p0_l4_icg);
+		of_property_read_u32(sub_node,
+			    "p1_l4_icg", &rtk_usb->power_ctrl_reg.p1_l4_icg);
+		of_property_read_u32(sub_node,
+			    "p2_l4_icg", &rtk_usb->power_ctrl_reg.p2_l4_icg);
+		of_property_read_u32(sub_node,
+			    "p3_l4_icg", &rtk_usb->power_ctrl_reg.p3_l4_icg);
+
+		/* for power cut */
+		of_property_read_u32(sub_node,
+			    "usb_phy_ctrl", &rtk_usb->power_ctrl_reg.usb_phy_ctrl);
+
+		of_property_read_u32(sub_node,
+			    "p0_utmi_reset", &rtk_usb->power_ctrl_reg.p0_utmi_reset);
+		of_property_read_u32(sub_node,
+			    "p1_utmi_reset", &rtk_usb->power_ctrl_reg.p1_utmi_reset);
+		of_property_read_u32(sub_node,
+			    "p2_utmi_reset", &rtk_usb->power_ctrl_reg.p2_utmi_reset);
+		of_property_read_u32(sub_node,
+			    "p3_utmi_reset", &rtk_usb->power_ctrl_reg.p3_utmi_reset);
+
+		of_property_read_u32(sub_node,
+			    "p0_pipe_reset", &rtk_usb->power_ctrl_reg.p0_pipe_reset);
+		of_property_read_u32(sub_node,
+			    "p1_pipe_reset", &rtk_usb->power_ctrl_reg.p1_pipe_reset);
+		of_property_read_u32(sub_node,
+			    "p2_pipe_reset", &rtk_usb->power_ctrl_reg.p2_pipe_reset);
+		of_property_read_u32(sub_node,
+			    "p3_pipe_reset", &rtk_usb->power_ctrl_reg.p3_pipe_reset);
+
+		/* for suspend */
+		of_property_read_u32(sub_node,
+			    "p0_gusb2phycfg", &rtk_usb->power_ctrl_reg.p0_gusb2phycfg);
+		of_property_read_u32(sub_node,
+			    "p0_gusb3pipectl", &rtk_usb->power_ctrl_reg.p0_gusb3pipectl);
+
+		of_property_read_u32(sub_node,
+			    "p1_gusb2phycfg", &rtk_usb->power_ctrl_reg.p1_gusb2phycfg);
+		of_property_read_u32(sub_node,
+			    "p1_gusb3pipectl", &rtk_usb->power_ctrl_reg.p1_gusb3pipectl);
+
+		of_property_read_u32(sub_node,
+			    "p2_gusb2phycfg", &rtk_usb->power_ctrl_reg.p2_gusb2phycfg);
+		of_property_read_u32(sub_node,
+			    "p2_gusb3pipectl", &rtk_usb->power_ctrl_reg.p2_gusb3pipectl);
+
+		of_property_read_u32(sub_node,
+			    "p3_gusb2phycfg", &rtk_usb->power_ctrl_reg.p3_gusb2phycfg);
+		of_property_read_u32(sub_node,
+			    "p3_gusb3pipectl", &rtk_usb->power_ctrl_reg.p3_gusb3pipectl);
+
+		of_property_read_u32(sub_node,
+			    "usb_charger", &rtk_usb->power_ctrl_reg.usb_charger);
+
+		if (of_property_read_bool(sub_node, "usb_power_cut"))
+			rtk_usb->usb_power_cut = true;
+		else
+			rtk_usb->usb_power_cut = false;
+
+	}
+	pr_debug("%s END\n", __func__);
+
+	return rtk_usb;
+}
+
+int rtk_usb_soc_free(struct rtk_usb **rtk_usb)
+{
+	if (*rtk_usb) {
+		kfree(*rtk_usb);
+		*rtk_usb = NULL;
+	}
+	return 0;
+}
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 26475b409..4afd6df53 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -164,6 +164,10 @@ source "drivers/usb/misc/Kconfig"
 
 source "drivers/usb/atm/Kconfig"
 
+config USB_PATCH_ON_RTK
+	bool
+	default y if USB_OHCI_RTK || USB_EHCI_RTK || USB_DWC3_RTK
+
 endif # USB
 
 source "drivers/usb/phy/Kconfig"
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 4dfa44d6c..8ceaab5d6 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -299,6 +299,15 @@ static int usb_probe_device(struct device *dev)
 	return error;
 }
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+int RTK_usb_probe_device(struct device *dev)
+{
+	int ret = 0;
+	ret = usb_probe_device(dev);
+	return ret;
+}
+#endif
+
 /* called from driver core with dev locked */
 static int usb_unbind_device(struct device *dev)
 {
@@ -314,6 +323,15 @@ static int usb_unbind_device(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+int RTK_usb_unbind_device(struct device *dev)
+{
+	int ret = 0;
+	ret = usb_unbind_device(dev);
+	return ret;
+}
+#endif
+
 /* called from driver core with dev locked */
 static int usb_probe_interface(struct device *dev)
 {
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7f71218cc..3003b463d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,6 +30,11 @@
 #include <linux/random.h>
 #include <linux/pm_qos.h>
 #include <linux/kobject.h>
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#include <linux/platform_device.h>
+#include <linux/timer.h>
+#include <linux/syscalls.h>
+#endif
 
 #include <linux/uaccess.h>
 #include <asm/byteorder.h>
@@ -46,6 +51,22 @@
 #define USB_TP_TRANSMISSION_DELAY	40	/* ns */
 #define USB_TP_TRANSMISSION_DELAY_MAX	65535	/* ns */
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_DWC3_RTK
+extern void RTK_dwc3_usb3_phy_toggle(struct device *dwc3_dev, bool isConnect, int port);
+extern int RTK_dwc3_usb2_phy_toggle(struct device *dwc3_dev, bool isConnect, int port);
+#endif
+#ifdef CONFIG_USB_EHCI_RTK
+extern int RTK_ehci_usb2_phy_toggle(struct device *ehci_dev, bool isConnect);
+#endif
+#endif
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_RTK_CTRL_MANAGER
+extern int RTK_usb_reprobe_usb_storage(struct usb_device *udev);
+#endif
+#endif
+
 /* Protect struct usb_device->state and ->children members
  * Note: Both are also protected by ->dev.sem, except that ->state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
@@ -405,6 +426,26 @@ static int get_hub_descriptor(struct usb_device *hdev,
 	return -EINVAL;
 }
 
+#ifdef CONFIG_USB_RTK_HCD_TEST_MODE
+int get_hub_descriptor_port(struct usb_device *hdev, void *data, int size, int port1)
+{
+	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	struct usb_device *dev = hub->ports[port1 - 1]->child;
+
+	if (dev) {
+		memset(data, 0, size);
+
+		return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+				USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
+				(USB_DT_DEVICE << 8), 0, data, size,
+				USB_CTRL_GET_TIMEOUT);
+
+	} else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(get_hub_descriptor_port);
+#endif //CONFIG_USB_RTK_HCD_TEST_MODE
+
 /*
  * USB 2.0 spec Section 11.24.2.1
  */
@@ -3618,6 +3659,39 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 
 	status = check_port_resume_type(udev,
 			hub, port1, status, portchange, portstatus);
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* [DEV_FIX] Disconnect usb port at resume.
+	 * commit 1a50dacafca108bd258f28755e2f4ad9ba4bc8d4
+	 * [BUG_FIX]: ID 46792 [ROOT_CAUSE]: can't recognize usb hub
+	 * commit cd7a079f0a82876abcdbe3e6a0b9409441c94294
+	 * [DEV_FIX]check udev reset_resume flag to disconnect
+	 * the device while resume back .
+	 * commit 8185a91ad51e2fe115d8d7a60d8b1ed4b8eb6c9f
+	 * [DEV_FIX]cant recognize hub after unplug/plug & suspend/resume
+	 * commit 3bbc65af52a4b27ac41114a998ad942aa613c078
+	 * [DEV_FIX]2. force  CONFIG_USB_HUB_DISCONNECT_AT_RESUME
+	 * commit 3e6a470b06ea6e37edded163aa814c8c24f04ced
+	 */
+	if (udev->reset_resume) {
+		int i;
+		if (udev->descriptor.bDeviceClass == USB_CLASS_MASS_STORAGE)
+			status = -1;
+		else
+			for (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {
+				struct usb_host_config *config = udev->actconfig;
+				struct usb_interface *intf = config->interface[i];
+				struct usb_interface_descriptor *desc;
+				desc = &intf->cur_altsetting->desc;
+
+				dev_notice(&udev->dev , "%s bInterfaceClass = %d \n", __func__, desc->bInterfaceClass);//hcy test
+				if (desc->bInterfaceClass == USB_CLASS_MASS_STORAGE){
+					status = -1;
+					break;
+				}
+			}
+	}
+#endif
 	if (status == 0)
 		status = finish_port_resume(udev);
 	if (status < 0) {
@@ -4643,11 +4717,31 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	else
 		driver_name = udev->bus->sysdev->driver->name;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (udev->speed < USB_SPEED_SUPER)
+		dev_notice(&udev->dev,
+				"%s %s USB device number %d using %s\n",
+				(udev->config) ? "reset" : "new", speed,
+				devnum, udev->bus->controller->driver->name);
+
+	/* add for debug reset*/
+	if (udev->speed < USB_SPEED_SUPER && udev->config) {
+		dev_dbg(&udev->dev,
+				"Start print dump_stack for %s %s USB device number %d "
+				"using %s (%s)\n",
+				(udev->config) ? "reset" : "new", speed,
+				devnum, udev->bus->controller->driver->name,
+				dev_name(udev->bus->controller->parent));
+		dev_dbg(&udev->dev, "End print dump_stack for USB dev number %d",
+				({dump_stack(); devnum;}));
+	}
+#else
 	if (udev->speed < USB_SPEED_SUPER)
 		dev_info(&udev->dev,
 				"%s %s USB device number %d using %s\n",
 				(udev->config) ? "reset" : "new", speed,
 				devnum, driver_name);
+#endif
 
 	/* Set up TT records, if needed  */
 	if (hdev->tt) {
@@ -4777,6 +4871,28 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			}
 			if (udev->speed >= USB_SPEED_SUPER) {
 				devnum = udev->devnum;
+#ifdef CONFIG_USB_PATCH_ON_RTK
+				dev_notice(&udev->dev,
+						"%s SuperSpeed%s USB device number %d using %s\n",
+						(udev->config) ? "reset" : "new",
+						(udev->speed == USB_SPEED_SUPER_PLUS) ? "Plus" : "",
+						devnum, udev->bus->controller->driver->name);
+
+				/* add for debug reset*/
+				if (udev->config) {
+					dev_dbg(&udev->dev,
+						"Start print dump_stack for %s SuperSpeed%s "
+						"USB device number %d "
+						"using %s (%s)\n",
+						(udev->config) ? "reset" : "new",
+						(udev->speed == USB_SPEED_SUPER_PLUS) ? "Plus" : "",
+						devnum, udev->bus->controller->driver->name,
+						dev_name(udev->bus->controller->parent));
+					dev_dbg(&udev->dev,
+						"End print dump_stack for USB dev number %d",
+						({dump_stack(); devnum;}));
+				}
+#else
 				dev_info(&udev->dev,
 						"%s SuperSpeed%s%s USB device number %d using %s\n",
 						(udev->config) ? "reset" : "new",
@@ -4785,6 +4901,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 					 (udev->rx_lanes == 2 && udev->tx_lanes == 2) ?
 							"x2" : "",
 					 devnum, driver_name);
+#endif
 			}
 
 			/* cope with hardware quirkiness:
@@ -5221,6 +5338,12 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		/* Run it through the hoops (find a driver, etc) */
 		if (!status) {
 			status = usb_new_device(udev);
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_RTK_CTRL_MANAGER
+			if (!status)
+				RTK_usb_reprobe_usb_storage(udev);
+#endif
+#endif
 			if (status) {
 				mutex_lock(&usb_port_peer_mutex);
 				spin_lock_irq(&device_state_lock);
@@ -5296,8 +5419,13 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	int status = -ENODEV;
 	int retval;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dev_notice(&port_dev->dev, "port %d, status %04x, change %04x, %s\n",
+			port1, portstatus, portchange, portspeed(hub, portstatus));
+#else
 	dev_dbg(&port_dev->dev, "status %04x, change %04x, %s\n", portstatus,
 			portchange, portspeed(hub, portstatus));
+#endif
 
 	if (hub->has_indicators) {
 		set_port_led(hub, port1, HUB_LED_AUTO);
@@ -5505,6 +5633,49 @@ static void port_event(struct usb_hub *hub, int port1)
 		}
 	}
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (connect_change) {
+		struct usb_device *hub_usb_dev = hub->hdev;
+		struct usb_bus *bus = hub_usb_dev->bus;
+		struct usb_device *root_hub_usb_dev = bus->root_hub;
+		struct usb_hcd *hcd = bus_to_hcd(bus);
+		bool isConnect = (portstatus & USB_PORT_STAT_CONNECTION)?true:false;
+		int _port = port1 - 1;
+
+		if (hub_is_superspeed(hub_usb_dev)
+				&& hub_usb_dev == root_hub_usb_dev
+				&& hcd != NULL) {
+#ifdef CONFIG_USB_DWC3_RTK
+			dev_info(hcd->self.controller, "%s to call RTK_dwc3_usb3_phy_toggle "
+					"(port=%d)\n",
+					__func__, _port);
+			RTK_dwc3_usb3_phy_toggle(hcd->self.controller, isConnect, _port);
+#else
+			dev_info(hcd->self.controller, "%s NO build CONFIG_USB_DWC3_RTK\n",
+					__func__);
+#endif
+		} else if (hub_usb_dev == root_hub_usb_dev
+					&& hcd != NULL) {
+			int ret = -1;
+#ifdef CONFIG_USB_DWC3_RTK
+			dev_info(hcd->self.controller, "%s call RTK_usb2_phy_toggle (port=%d)\n",
+					__func__, _port);
+			ret = RTK_dwc3_usb2_phy_toggle(hcd->self.controller, isConnect, _port);
+#else
+			dev_info(hcd->self.controller, "%s NO build CONFIG_USB_DWC3_RTK\n",
+					__func__);
+#endif
+#ifdef CONFIG_USB_EHCI_RTK
+			if (ret < 0)
+				RTK_ehci_usb2_phy_toggle(hcd->self.controller, isConnect);
+#else
+			dev_info(hcd->self.controller, "%s NO build CONFIG_USB_DWC3_RTK\n",
+					__func__);
+#endif
+		}
+	}
+#endif
+
 	if (connect_change)
 		hub_port_connect_change(hub, port1, portstatus, portchange);
 }
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index d85699bee..786e30c37 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -795,6 +795,191 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_IGNORE_LOCKDEP(remove, S_IWUSR, NULL, remove_store);
 
+#ifdef CONFIG_USB_RTK_HCD_TEST_MODE
+#include <linux/slab.h>
+#include <linux/usb/ch11.h>
+#include <linux/usb/hcd.h>
+
+extern int get_hub_descriptor_port(struct usb_device *hdev, void *data, int size, int port1);
+
+// copy from hub.c and rename
+/*
+ * USB 2.0 spec Section 11.24.2.2
+ */
+static int hub_clear_port_feature(struct usb_device *hdev, int port1, int feature)
+{
+	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
+			ClearPortFeature, USB_RT_PORT, feature, port1,
+			NULL, 0, 1000);
+}
+
+/*
+ * USB 2.0 spec Section 11.24.2.13
+ */
+static int hub_set_port_feature(struct usb_device *hdev, int port1, int feature)
+{
+	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
+			SetPortFeature, USB_RT_PORT, feature, port1,
+			NULL, 0, 1000);
+}
+
+/* use a short timeout for hub/port status fetches */
+#define        USB_STS_TIMEOUT         1000
+#define        USB_STS_RETRIES         5
+
+static int get_port_status(struct usb_device *hdev, int port1,
+		struct usb_port_status *data)
+{
+	int i, status = -ETIMEDOUT;
+
+	for (i = 0; i < USB_STS_RETRIES &&
+			(status == -ETIMEDOUT || status == -EPIPE); i++) {
+		printk("get_port_status at port %d ...\n", port1);
+		status = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+			USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port1,
+			data, sizeof(*data), USB_STS_TIMEOUT);
+	}
+	return status;
+}
+
+enum {
+	TEST_RESET = 0,
+	TEST_TEST_J,
+	TEST_TEST_K,
+	TEST_TEST_SE0_NAK,
+	TEST_TEST_PACKET,
+	TEST_TEST_FORCE_ENABLE,
+	TEST_SUSPEND_RESUME,
+	TEST_SINGLE_STEP_GET_DEVICE_DESCRIPTOR,
+	TEST_PORT_RESET,
+	MAX_CTS_TEST_CASE,
+};
+
+static ssize_t  show_runTestMode (struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = udev = to_usb_device (dev);
+	struct usb_host_config *actconfig;
+
+	if(udev->descriptor.bDeviceClass != USB_CLASS_HUB)
+		return sprintf (buf, "This node is not a HUB\n");
+
+	return sprintf (buf, "%s to runTestMode\n"
+			"echo \"1 %d\" to run port1 HC_RESET command\n"
+			"echo \"1 %d\" to run port1 TEST_J command\n"
+			"echo \"1 %d\" ro run port1 TEST_K command\n"
+			"echo \"1 %d\" to run port1 TEST_SE0_NAK command\n"
+			"echo \"1 %d\" to run port1 TEST_PACKET command\n"
+			"echo \"1 %d\" to run port1 TEST_FORCE_ENABLE command\n"
+			"echo \"1 %d\" to run port1 SUSPEND/RESUME command\n"
+			"echo \"1 %d\" to run port1 "
+			"SINGLE_STEP_GET_DEVICE_DESCRIPTOR command\n"
+			"echo \"1 %d\" to run port1 PORT_RESET command\n",
+			dev_name(dev),
+			TEST_RESET, TEST_TEST_J, TEST_TEST_K, TEST_TEST_SE0_NAK,
+			TEST_TEST_PACKET,
+			TEST_TEST_FORCE_ENABLE, TEST_SUSPEND_RESUME,
+			TEST_SINGLE_STEP_GET_DEVICE_DESCRIPTOR,
+			TEST_PORT_RESET);
+
+	return 0;
+}
+
+static ssize_t
+set_runTestMode (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct usb_device       *udev = udev = to_usb_device (dev);
+	int value, test_case;
+	unsigned int            port1 = 1;
+
+	if ((value = sscanf (buf, "%u", &port1)) != 1)
+		return -EINVAL;
+
+	buf += 2;
+
+	if ((value = sscanf (buf, "%u", &test_case)) != 1)
+		return -EINVAL;
+
+	if(udev->descriptor.bDeviceClass != USB_CLASS_HUB)
+		return value;
+
+	switch (test_case) {
+	case TEST_RESET:
+		printk("run HC_RESET (%d) to port %d ...\n", test_case, port1);
+		if (udev->bus != NULL) {
+			struct usb_hcd *hcd = bus_to_hcd(udev->bus);
+			int ret;
+			if (hcd != NULL && hcd->driver != NULL && hcd->driver->reset)
+				ret = hcd->driver->reset(hcd);
+			if (ret)
+				printk("run HC_RESET fail ...\n");
+		}
+
+	break;
+	case TEST_TEST_J:
+	case TEST_TEST_K:
+	case TEST_TEST_SE0_NAK:
+	case TEST_TEST_PACKET:
+	case TEST_TEST_FORCE_ENABLE:
+		printk("run USB_PORT_FEAT_TEST mode %d to port %d ...\n", test_case, port1);
+		hub_set_port_feature(udev,(test_case << 8) | port1, USB_PORT_FEAT_TEST);
+
+	break;
+	case TEST_SUSPEND_RESUME:
+		printk("run TEST_SUSPEND_RESUME to the port %d of the hub ...\n", port1);
+		msleep(15000);
+		printk("set USB_PORT_FEAT_SUSPEND to the port %d of the hub ...\n", port1);
+		hub_set_port_feature(udev, port1, USB_PORT_FEAT_SUSPEND);
+		printk("set OK !!!\n");
+		msleep(15000);
+		printk("clear USB_PORT_FEAT_SUSPEND to the port %d of the hub ...\n", port1);
+		hub_clear_port_feature(udev, port1, USB_PORT_FEAT_SUSPEND);
+		printk("clear OK !!!\n");
+		{
+			printk("get_port_status port %d of the hub ...\n", port1);
+			struct usb_port_status data;
+			msleep(USB_RESUME_TIMEOUT);
+			get_port_status(udev, port1, &data);
+		}
+	break;
+	case TEST_SINGLE_STEP_GET_DEVICE_DESCRIPTOR:
+		printk("run SINGLE_STEP_GET_DEVICE_DESCRIPTOR to the port %d of the hub ...\n", port1);
+		int i, size = 0x12;
+		unsigned char	*data;
+		data = (unsigned char*)kmalloc(size, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+		memset (data, 0, size);
+		get_hub_descriptor_port(udev, data, size, port1);
+
+		printk(" get device descriptor\n");
+		for( i = 0; i < size; i++)
+		{
+			printk(" %.2x", data[i]);
+			if((i % 15) == 0 && (i != 0))
+				printk("\n<1>");
+		}
+		printk("\n");
+
+		kfree(data);
+
+	break;
+	case TEST_PORT_RESET:
+		printk("run PORT_RESET (%d) to port %d ...\n", test_case, port1);
+		hub_clear_port_feature(udev, port1, USB_PORT_FEAT_POWER);
+		msleep(1000);
+		hub_set_port_feature(udev, port1, USB_PORT_FEAT_POWER);
+
+	break;
+	default:
+		printk("error test_case %d !!!\n", test_case);
+	break;
+	}
+
+	return (value < 0) ? value : count;
+}
+static DEVICE_ATTR(runTestMode, S_IRUGO | S_IWUSR,
+		show_runTestMode, set_runTestMode);
+#endif /* CONFIG_USB_RTK_HCD_TEST_MODE */
 
 static struct attribute *dev_attrs[] = {
 	/* current configuration's attributes */
@@ -830,6 +1015,9 @@ static struct attribute *dev_attrs[] = {
 #ifdef CONFIG_OF
 	&dev_attr_devspec.attr,
 #endif
+#ifdef CONFIG_USB_RTK_HCD_TEST_MODE
+	&dev_attr_runTestMode.attr,
+#endif // CONFIG_USB_RTK_HCD_TEST_MODE
 	NULL,
 };
 static const struct attribute_group dev_attr_grp = {
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index 7a2304565..f33e944db 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -53,6 +53,30 @@ endchoice
 
 comment "Platform Glue Driver Support"
 
+config USB_DWC3_RTK
+	tristate "Realtek DWC3 Platform Driver"
+	select RTK_USB2PHY
+	select RTK_USB3PHY
+	select USB_RTK_CTRL_MANAGER
+	default ARCH_RTD129x
+	help
+	  RTK SoCs with DesignWare Core USB3 IP inside,
+	  say 'Y' or 'M' if you have such device.
+
+config USB_RTK_DWC3_DRD_MODE
+	bool "RTK DWC3 DRD (dynamical host/device mode switch)"
+	depends on USB_DWC3_DUAL_ROLE
+	default ARCH_RTD129x
+	help
+	  Support Realtek dwc3 drd type c dynamical host/device mode switch
+
+config USB_TYPE_C_RTK_RTS5400
+	bool "RTK Type C Controller RTS5400"
+	depends on USB_RTK_DWC3_DRD_MODE
+	default ARCH_RTD129x
+	help
+	  Support Realtek type c controller via RTS5400
+
 config USB_DWC3_OMAP
 	tristate "Texas Instruments OMAP5 and similar Platforms"
 	depends on ARCH_OMAP2PLUS || COMPILE_TEST
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index ae86da0dc..04756ba16 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -51,3 +51,7 @@ obj-$(CONFIG_USB_DWC3_MESON_G12A)	+= dwc3-meson-g12a.o
 obj-$(CONFIG_USB_DWC3_OF_SIMPLE)	+= dwc3-of-simple.o
 obj-$(CONFIG_USB_DWC3_ST)		+= dwc3-st.o
 obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
+obj-$(CONFIG_USB_DWC3_RTK)		+= dwc3-rtk.o
+obj-$(CONFIG_USB_DWC3_RTK)		+= dwc3-rtk-type_c.o
+obj-$(CONFIG_USB_RTK_DWC3_DRD_MODE)	+= dwc3-rtk-drd.o
+obj-$(CONFIG_USB_TYPE_C_RTK_RTS5400)	+= rtk-rts5400.o
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index 3101f0dcf..d63dc65fb 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -32,6 +32,14 @@
 #include <linux/usb/of.h>
 #include <linux/usb/otg.h>
 
+#ifdef CONFIG_USB_DWC3_RTK
+#include <linux/of_address.h>
+#endif
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#include <linux/suspend.h>
+#endif
+
 #include "core.h"
 #include "gadget.h"
 #include "io.h"
@@ -240,7 +248,12 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 	int		retries = 1000;
 	int		ret;
 
+#ifndef CONFIG_USB_DWC3_RTK
+	/* fixed kernel panic when init usb2_phy
+	 * move to the end of function
+	 */
 	usb_phy_init(dwc->usb2_phy);
+#endif
 	usb_phy_init(dwc->usb3_phy);
 	ret = phy_init(dwc->usb2_generic_phy);
 	if (ret < 0)
@@ -252,6 +265,12 @@ static int dwc3_core_soft_reset(struct dwc3 *dwc)
 		return ret;
 	}
 
+#ifdef CONFIG_USB_DWC3_RTK
+	dev_dbg(dwc->dev, "[bug fixed] late to init usb2_phy");
+	usb_phy_init(dwc->usb2_phy);
+	mdelay(100);
+#endif
+
 	/*
 	 * We're resetting only the device side because, if we're in host mode,
 	 * XHCI driver will reset the host block. If dwc3 was configured for
@@ -425,6 +444,18 @@ int dwc3_event_buffers_setup(struct dwc3 *dwc)
 	return 0;
 }
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+int rtk_dwc3_drd_core_soft_reset(struct dwc3 *dwc)
+{
+	return dwc3_core_soft_reset(dwc);
+}
+
+int rtk_dwc3_drd_event_buffers_setup(struct dwc3 *dwc)
+{
+	return dwc3_event_buffers_setup(dwc);
+}
+#endif
+
 void dwc3_event_buffers_cleanup(struct dwc3 *dwc)
 {
 	struct dwc3_event_buffer	*evt;
@@ -1083,6 +1114,44 @@ static int dwc3_core_init(struct dwc3 *dwc)
 		}
 	}
 
+#ifdef CONFIG_USB_DWC3_RTK
+	/* workaround: to avoid transaction error and cause port reset
+	 * we enable threshold control for TX/RX
+	 * [Dev_Fix] Enable DWC3 threshold control for USB compatibility issue
+	 * commit 77f116ba77cc089ee2a6ceca1d2aa496b39c98ba
+	 * [Dev_Fix] change RX threshold packet count from 1 to 3, it will get better performance
+	 * commit fe8905c2112f899f9ec3ddbfd83e0f183d3fbf7d
+	 * [DEV_FIX] In case there may have transaction error once system bus busy
+	 * commit b36294740c5cf66932c0fec429f4c5399e26f591
+	 * */
+#define RX_THRESHOLD_EN			(1<<29)
+#define RX_PKT_CNT(n)			(n<<24)
+#define RX_MAX_BURST_SZ(n)		(n<<19)
+
+	dwc3_writel(dwc->regs, DWC3_GTXTHRCFG, 0x01010000);
+	dwc3_writel(dwc->regs, DWC3_GRXTHRCFG,  RX_THRESHOLD_EN	|
+						RX_PKT_CNT(3)	|
+						RX_MAX_BURST_SZ(3));
+	dwc3_writel(dwc->regs, DWC3_GUCTL,
+				dwc3_readl(dwc->regs, DWC3_GUCTL) | (1<<14));   // enable auto retry
+
+	/* disable SS park modde */
+	if (dwc->dis_ss_park_mode)
+		dwc3_writel(dwc->regs, DWC3_GUCTL1,
+				dwc3_readl(dwc->regs, DWC3_GUCTL1) | (1<<17));
+
+	if (dwc->dis_hs_park_mode)
+		dwc3_writel(dwc->regs, DWC3_GUCTL1,
+				dwc3_readl(dwc->regs, DWC3_GUCTL1) | (1<<16));
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (dwc->revision >= DWC3_REVISION_300A)
+		dwc3_writel(dwc->regs, DWC3_DEV_IMOD(0),
+				dwc3_readl(dwc->regs, DWC3_DEV_IMOD(0)) | DWC3_DEVICE_IMODI(0x1));
+#endif
+
+#endif
+
 	return 0;
 
 err4:
@@ -1342,6 +1411,12 @@ static void dwc3_get_properties(struct dwc3 *dwc)
 				"snps,dis-tx-ipgap-linecheck-quirk");
 	dwc->parkmode_disable_ss_quirk = device_property_read_bool(dev,
 				"snps,parkmode-disable-ss-quirk");
+#ifdef CONFIG_USB_DWC3_RTK
+	dwc->dis_ss_park_mode = device_property_read_bool(dev,
+				"snps,dis_ss_park_mode");
+	dwc->dis_hs_park_mode = device_property_read_bool(dev,
+				"snps,dis_hs_park_mode");
+#endif
 
 	dwc->tx_de_emphasis_quirk = device_property_read_bool(dev,
 				"snps,tx_de_emphasis_quirk");
@@ -1481,12 +1556,28 @@ static int dwc3_probe(struct platform_device *pdev)
 	dwc_res = *res;
 	dwc_res.start += DWC3_GLOBALS_REGS_START;
 
+#ifdef CONFIG_USB_DWC3_RTK
+	/* due to rtk dwc3 ip DWC3_GLOBALS_REGS_START is not standard (0xc100)
+	 * we need to fixed it
+	 */
+	regs = of_iomap(dev->of_node, 0);
+	regs += 0x8100;
+	dev_info(dev, "rtk dwc3 fixed dwc3 globals register start address 0x%p\n", regs);
+#else
 	regs = devm_ioremap_resource(dev, &dwc_res);
+#endif
 	if (IS_ERR(regs))
 		return PTR_ERR(regs);
 
 	dwc->regs	= regs;
+#ifdef CONFIG_USB_DWC3_RTK
+	/* due to rtk dwc3 ip DWC3_GLOBALS_REGS_START is not standard (0xc100)
+	 * we need to fixed it
+	 */
+	dwc->regs_size  = resource_size(res) - 0x8100;
+#else
 	dwc->regs_size	= resource_size(&dwc_res);
+#endif
 
 	dwc3_get_properties(dwc);
 
@@ -1864,25 +1955,107 @@ static int dwc3_runtime_idle(struct device *dev)
 #endif /* CONFIG_PM */
 
 #ifdef CONFIG_PM_SLEEP
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* [DEV_FIX]implement New USB reset mechanism with CRT reset to workaround any HW or IP issues
+ * commit 319ff9f5c298b94517a10d4ced59812b54994347
+ */
+static int dwc3_suspend(struct device *dev);
+int RTK_dwc3_suspend(struct device *dev)
+{
+	return dwc3_suspend(dev);
+}
+#endif
+
 static int dwc3_suspend(struct device *dev)
 {
 	struct dwc3	*dwc = dev_get_drvdata(dev);
 	int		ret;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		return 0;
+//	}
+	//For suspend mode
+	dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+
+#endif
+
 	ret = dwc3_suspend_common(dwc, PMSG_SUSPEND);
 	if (ret)
 		return ret;
 
 	pinctrl_pm_select_sleep_state(dev);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dev_info(dev, "[USB] Exit %s", __func__);
+#endif
+
 	return 0;
 }
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* [DEV_FIX]implement New USB reset mechanism with CRT reset to workaround any HW or IP issues
+ * commit 319ff9f5c298b94517a10d4ced59812b54994347
+ */
+static int dwc3_resume(struct device *dev);
+int RTK_dwc3_resume(struct device *dev)
+{
+	return dwc3_resume(dev);
+}
+#endif
+
 static int dwc3_resume(struct device *dev)
 {
 	struct dwc3	*dwc = dev_get_drvdata(dev);
 	int		ret;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		return 0;
+//	}
+	//For suspend mode
+	dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+#endif
+
+#ifdef CONFIG_USB_DWC3_RTK
+	/* workaround: to avoid transaction error and cause port reset
+	 * we enable threshold control for TX/RX
+	 * [Dev_Fix] Enable DWC3 threshold control for USB compatibility issue
+	 * commit 77f116ba77cc089ee2a6ceca1d2aa496b39c98ba
+	 * [Dev_Fix] change RX threshold packet count from 1 to 3,
+	 * it will get better performance
+	 * commit fe8905c2112f899f9ec3ddbfd83e0f183d3fbf7d
+	 * [DEV_FIX] In case there may have transaction error once system bus busy
+	 * commit b36294740c5cf66932c0fec429f4c5399e26f591
+	 * */
+#define RX_THRESHOLD_EN                        (1<<29)
+#define RX_PKT_CNT(n)                  (n<<24)
+#define RX_MAX_BURST_SZ(n)             (n<<19)
+
+	dwc3_writel(dwc->regs, DWC3_GTXTHRCFG, 0x01010000);
+	dwc3_writel(dwc->regs, DWC3_GRXTHRCFG,  RX_THRESHOLD_EN	|
+						RX_PKT_CNT(3)	|
+						RX_MAX_BURST_SZ(3));
+	// enable auto retry
+	dwc3_writel(dwc->regs, DWC3_GUCTL,
+			dwc3_readl(dwc->regs, DWC3_GUCTL) | (1<<14));
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (dwc->revision >= DWC3_REVISION_300A)
+		dwc3_writel(dwc->regs, DWC3_DEV_IMOD(0),
+				dwc3_readl(dwc->regs, DWC3_DEV_IMOD(0)) |
+				DWC3_DEVICE_IMODI(0x1));
+#endif
+
+#endif
+
 	pinctrl_pm_select_default_state(dev);
 
 	ret = dwc3_resume_common(dwc, PMSG_RESUME);
@@ -1893,6 +2066,10 @@ static int dwc3_resume(struct device *dev)
 	pm_runtime_set_active(dev);
 	pm_runtime_enable(dev);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+#endif
 	return 0;
 }
 
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index 1b241f937..fda56896c 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -375,6 +375,9 @@
 #define DWC3_GHWPARAMS7_RAM1_DEPTH(n)	((n) & 0xffff)
 #define DWC3_GHWPARAMS7_RAM2_DEPTH(n)	(((n) >> 16) & 0xffff)
 
+/* Global GEVNTCOUNT EVNT_HANDLER_BUSY*/
+#define DWC3_EVNT_HANDLER_BUSY		(1 << 31)
+
 /* Global Frame Length Adjustment Register */
 #define DWC3_GFLADJ_30MHZ_SDBND_SEL		BIT(7)
 #define DWC3_GFLADJ_30MHZ_MASK			0x3f
@@ -552,6 +555,8 @@
 #define DWC3_DEV_IMOD_COUNT_MASK	(0xffff << 16)
 #define DWC3_DEV_IMOD_INTERVAL_SHIFT	0
 #define DWC3_DEV_IMOD_INTERVAL_MASK	(0xffff << 0)
+#define DWC3_DEVICE_IMODC(n)		((0xffff & (n)) << 16)
+#define DWC3_DEVICE_IMODI(n)		((0xffff & (n)))
 
 /* OTG Configuration Register */
 #define DWC3_OCFG_DISPWRCUTTOFF		BIT(5)
@@ -1119,6 +1124,12 @@ struct dwc3 {
 
 	u32			fladj;
 	u32			irq_gadget;
+
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	bool has_gadget;
+	bool has_xhci;
+#endif
+
 	u32			otg_irq;
 	u32			current_otg_role;
 	u32			desired_otg_role;
@@ -1246,6 +1257,10 @@ struct dwc3 {
 	unsigned		dis_del_phy_power_chg_quirk:1;
 	unsigned		dis_tx_ipgap_linecheck_quirk:1;
 	unsigned		parkmode_disable_ss_quirk:1;
+#ifdef CONFIG_USB_DWC3_RTK
+	unsigned                dis_ss_park_mode:1;
+	unsigned                dis_hs_park_mode:1;
+#endif
 
 	unsigned		tx_de_emphasis_quirk:1;
 	unsigned		tx_de_emphasis:2;
diff --git a/drivers/usb/dwc3/debugfs.c b/drivers/usb/dwc3/debugfs.c
index 5da4f6082..170593254 100644
--- a/drivers/usb/dwc3/debugfs.c
+++ b/drivers/usb/dwc3/debugfs.c
@@ -236,6 +236,9 @@ static const struct debugfs_reg32 dwc3_regs[] = {
 	dump_register(DGCMDPAR),
 	dump_register(DGCMD),
 	dump_register(DALEPENA),
+#ifdef CONFIG_USB_DWC3_RTK
+	dump_register(DEV_IMOD(0)),
+#endif
 
 	dump_ep_register_set(0),
 	dump_ep_register_set(1),
diff --git a/drivers/usb/dwc3/dwc3-rtk-drd.c b/drivers/usb/dwc3/dwc3-rtk-drd.c
new file mode 100644
index 000000000..14fa4877f
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-rtk-drd.c
@@ -0,0 +1,208 @@
+/**
+ * dwc3-rtk-drd.c - Realtek DWC3 Specific Glue layer
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/composite.h>
+
+#include "core.h"
+#include "gadget.h"
+#include "io.h"
+#include "dwc3-rtk-drd.h"
+
+extern int rtk_dwc3_drd_core_soft_reset(struct dwc3 *dwc);
+extern int rtk_dwc3_drd_event_buffers_setup(struct dwc3 *dwc);
+extern int dwc3_gadget_restart(struct dwc3 *dwc);
+extern int dwc3_gadget_stop_on_switch(struct dwc3 *dwc);
+
+
+struct usb_gadget_driver *rtk_dwc3_set_and_get_usb_gadget_driver(
+	    struct usb_gadget_driver *driver)
+{
+	static struct usb_gadget_driver *gadget_driver = NULL;
+	struct usb_gadget_driver *local_driver = gadget_driver;
+
+	gadget_driver = driver;
+
+	return local_driver;
+}
+EXPORT_SYMBOL_GPL(rtk_dwc3_set_and_get_usb_gadget_driver);
+
+int dwc3_drd_to_host(struct dwc3 *dwc)
+{
+	int ret;
+	unsigned long timeout;
+	//unsigned long flags = 0;
+	u32 reg;
+
+	dev_info(dwc->dev, "%s START....", __func__);
+	if (dwc->has_gadget) {
+		if (dwc->gadget_driver != NULL) {
+			rtk_dwc3_set_and_get_usb_gadget_driver(dwc->gadget_driver);
+			usb_gadget_unregister_driver(dwc->gadget_driver);
+		}
+		dwc3_gadget_exit(dwc);
+	}
+	wmb();
+
+	if (dwc->has_xhci) {
+		dev_info(dwc->dev, "%s Now is host", __func__);
+		return 0;
+	}
+
+	/* issue device SoftReset too */
+	timeout = jiffies + msecs_to_jiffies(500);
+	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		if (!(reg & DWC3_DCTL_CSFTRST))
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			dev_err(dwc->dev, "Reset Timed Out\n");
+			ret = -ETIMEDOUT;
+			goto err0;
+		}
+
+		cpu_relax();
+	} while (true);
+
+	dev_info(dwc->dev, "%s: call dwc3_core_soft_reset\n", __func__);
+	ret = rtk_dwc3_drd_core_soft_reset(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "soft reset failed\n");
+		goto err0;
+	}
+
+//	spin_lock_irqsave(&dwc->lock, flags);
+	ret = rtk_dwc3_drd_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto err0;
+	}
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_HOST);
+
+	ret = dwc3_host_init(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to init host\n");
+		goto err0;
+	}
+err0:
+//	spin_unlock_irqrestore(&dwc->lock, flags);
+	dev_info(dwc->dev, "%s END....", __func__);
+	return ret;
+}
+
+int dwc3_drd_to_device(struct dwc3 *dwc)
+{
+	int ret;
+	unsigned long timeout, flags = 0;
+	u32 reg;
+
+	dev_info(dwc->dev, "%s START....", __func__);
+
+	if (dwc->has_xhci) {
+		dev_info(dwc->dev, "%s dwc3_host_exit", __func__);
+		dwc3_host_exit(dwc);
+	}
+	wmb();
+
+	if (dwc->has_gadget) {
+		dev_info(dwc->dev, "%s Now is gadget", __func__);
+		return 0;
+	}
+
+	/* issue device SoftReset too */
+	timeout = jiffies + msecs_to_jiffies(500);
+	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		if (!(reg & DWC3_DCTL_CSFTRST))
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			dev_err(dwc->dev, "Reset Timed Out\n");
+			ret = -ETIMEDOUT;
+			goto err0;
+		}
+
+		cpu_relax();
+	} while (true);
+
+	ret = rtk_dwc3_drd_core_soft_reset(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "soft reset failed\n");
+		goto err0;
+	}
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	ret = rtk_dwc3_drd_event_buffers_setup(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to setup event buffers\n");
+		goto err0;
+	}
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	ret = dwc3_gadget_init(dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to init gadget\n");
+		goto err0;
+	} else {
+		struct usb_gadget_driver *driver =
+			    rtk_dwc3_set_and_get_usb_gadget_driver(NULL);
+		if (driver)
+			ret = usb_gadget_probe_driver(driver);
+	}
+	if (ret) {
+		dev_err(dwc->dev, "failed to usb_gadget probe gadget_driver\n");
+		goto err0;
+	}
+err0:
+	dev_info(dwc->dev, "%s END....", __func__);
+	return ret;
+}
+
+int dwc3_drd_to_stop_all(struct dwc3 *dwc)
+{
+	int ret = 0;
+
+	dev_info(dwc->dev, "%s START....", __func__);
+	if (dwc->has_xhci)
+		dwc3_host_exit(dwc);
+	if (dwc->has_gadget) {
+		if (dwc->gadget_driver != NULL) {
+			rtk_dwc3_set_and_get_usb_gadget_driver(dwc->gadget_driver);
+			usb_gadget_unregister_driver(dwc->gadget_driver);
+		}
+		dwc3_gadget_exit(dwc);
+	}
+	wmb();
+	dev_info(dwc->dev, "%s END....", __func__);
+	return ret;
+}
diff --git a/drivers/usb/dwc3/dwc3-rtk-drd.h b/drivers/usb/dwc3/dwc3-rtk-drd.h
new file mode 100644
index 000000000..9a9bb3b4a
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-rtk-drd.h
@@ -0,0 +1,24 @@
+/**
+ * dwc3-rtk-drd.h - Realtek DWC3 Specific Glue layer
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __DRIVERS_USB_DWC3_RTK_DRD_H
+#define __DRIVERS_USB_DWC3_RTK_DRD_H
+
+#include "core.h"
+#include "gadget.h"
+#include "io.h"
+
+extern int dwc3_drd_to_host(struct dwc3 *dwc);
+extern int dwc3_drd_to_device(struct dwc3 *dwc);
+extern int dwc3_drd_to_stop_all(struct dwc3 *dwc);
+
+#endif /* __DRIVERS_USB_DWC3_RTK_CORE_H */
+
diff --git a/drivers/usb/dwc3/dwc3-rtk-type_c.c b/drivers/usb/dwc3/dwc3-rtk-type_c.c
new file mode 100644
index 000000000..f03109377
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-rtk-type_c.c
@@ -0,0 +1,2134 @@
+/**
+ *  * dwc3-rtk-type_c.c - Realtek DWC3 Type C driver
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_gpio.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/usb/otg.h>
+#include <linux/syscalls.h>
+#include <linux/suspend.h>
+#include <soc/realtek/rtk_chip.h>
+
+#include "core.h"
+#include "dwc3-rtk-drd.h"
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+#include <linux/usb/class-dual-role.h>
+#endif
+
+#ifdef CONFIG_USB_TYPE_C_RTK_RTS5400
+extern bool rtk_rts5400_is_UFP_attached(void);
+extern bool rtk_rts5400_is_enabled(void);
+extern int rtk_rts5400_set_type_c_soft_reset(void);
+#endif
+
+extern int rtk_usb_type_c_power_on_off(struct device *usb_dev, bool on);
+extern int rtk_usb_set_type_c_switch_gpio(struct device *type_c_dev, bool high);
+
+struct type_c_data {
+	void __iomem *wrap_base;
+	void __iomem *type_c_reg_base;
+	struct device *dev;
+
+	enum rtd_chip_id chip_id;
+	enum rtd_chip_revision chip_revision;
+
+	/*GPIO*/
+	unsigned int rd_ctrl_gpio;
+
+	/*Parameters*/
+	u32 cc1_rp;
+	u32 cc1_rp_code;
+	u32 cc1_rd_code;
+	u32 cc1_vref_ufp;
+	u32 cc1_vref_dfp_usb;
+	u32 cc1_vref_dfp_1_5;
+	u32 cc1_vref_dfp_3_0;
+	u32 cc2_rp;
+	u32 cc2_rp_code;
+	u32 cc2_rd_code;
+	u32 cc2_vref_ufp;
+	u32 cc2_vref_dfp_usb;
+	u32 cc2_vref_dfp_1_5;
+	u32 cc2_vref_dfp_3_0;
+	u32 debounce_val;// 1b,1us 7f,4.7us
+	int rd_config;
+#define INTERNAL_Rd 1
+#define EXTERNAL_Rd 0
+	int cc_dfp_mode;
+
+	struct dwc3 *dwc;
+	int dwc3_mode;
+	int cur_mode;
+	bool is_drd_mode;
+
+	// type_c state
+	int connect_change;
+#define CONNECT_CHANGE 1
+#define CONNECT_NO_CHANGE 0
+	int in_host_mode;
+#define IN_HOST_MODE 1
+#define IN_DEVICE_MODE 0
+	int is_attach;
+#define IN_ATTACH 1
+#define TO_ATTACH 1
+#define IN_DETACH 0
+#define TO_DETACH 0
+	int at_cc1;
+#define AT_CC1 1
+#define AT_CC2 0
+
+	u32 int_status;
+	u32 cc_status;
+	spinlock_t		lock;
+	struct delayed_work   delayed_work;
+
+	struct work_struct start_work;
+
+	/* boot time check device mode transfer to host mode*/
+	bool check_at_boot;
+	int boot_check_time;
+	struct delayed_work boot_check_work;
+
+	bool debug;
+#ifdef CONFIG_DYNAMIC_DEBUG
+	struct dentry		*debug_dir;
+#endif
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	struct dual_role_phy_instance *drp;
+#endif
+};
+
+// wrapper register offset for USB2 PHY
+#define USB2_PHY_reg  0x70
+#define USB2_PHY_SWITCH_MASK 0x707
+#define USB2_PHY_SWITCH_DEVICE 0x0
+#define USB2_PHY_SWITCH_HOST 0x606
+
+// Type C register offset
+#define USB_TYPEC_CTRL_CC1_0 0x0
+#define USB_TYPEC_CTRL_CC1_1 0x4
+#define USB_TYPEC_CTRL_CC2_0 0x8
+#define USB_TYPEC_CTRL_CC2_1 0xC
+#define USB_TYPEC_STS        0x10
+#define USB_TYPEC_CTRL       0x14
+#define USB_DBUS_PWR_CTRL    0x18
+
+// Bit mapping USB_TYPEC_CTRL_CC1_0 and USB_TYPEC_CTRL_CC2_0
+#define EN_EXTERNAL_RD BIT(29) /* only for rtd1395 */
+#define EN_SWITCH BIT(29)
+#define Txout_sel BIT(28)
+#define Rxin_sel BIT(27)
+#define SWITCH_MASK (EN_SWITCH | Txout_sel | Rxin_sel)
+#define enable_cc1 EN_SWITCH
+#define enable_cc2 (EN_SWITCH | Txout_sel | Rxin_sel)
+#define disable_cc ~SWITCH_MASK
+#define rp4pk_code(val) ((0x1f & val) << 22)
+#define code_rp4pk(val) ((val >> 22) & 0x1f)
+#define rp36k_code(val) ((0x1f & val) << 17)
+#define code_rp36k(val) ((val >> 17) & 0x1f)
+#define rp12k_code(val) ((0x1f & val) << 12)
+#define code_rp12k(val) ((val >> 12) & 0x1f)
+#define rd_code(val) ((0x1f & val) << 7)
+#define code_rd(val) ((val >> 7) & 0x1f)
+#define cc_mode(val) ((0x3 & val) << 5)
+#define En_rp4p7k BIT(4)
+#define En_rp36k BIT(3)
+#define En_rp12k BIT(2)
+#define En_rd BIT(1)
+#define En_cc_det BIT(0)
+
+#define CC_MODE_UFP 0x0
+#define CC_MODE_DFP_USB 0x1
+#define CC_MODE_DFP_1_5 0x2
+#define CC_MODE_DFP_3_0 0x3
+
+// Bit mapping USB_TYPEC_CTRL_CC1_1 and USB_TYPEC_CTRL_CC2_1
+#define vref_2p6v(val) ((0x7 & val) << 26)
+#define vref_1p23v(val) ((0xf & val) << 22)
+#define vref_0p8v(val) ((0xf & val) << 18)
+#define vref_0p66v(val) ((0xf & val) << 14)
+#define vref_0p4v(val) ((0x7 & val) << 11)
+#define vref_0p2v(val) ((0x7 & val) << 8)
+#define vref_1_1p6v(val) ((0xf & val) << 4)
+#define vref_0_1p6v(val) ((0xf & val) << 0)
+
+#define decode_2p6v(val) ((val >> 26) & 0x7)
+#define decode_1p23v(val) ((val >> 22) & 0xf)
+#define decode_0p8v(val) ((val >> 18) & 0xf)
+#define decode_0p66v(val) ((val >> 14) & 0xf)
+#define decode_0p4v(val) ((val >> 11) & 0x7)
+#define decode_0p2v(val) ((val >> 8) & 0x7)
+#define decode_1_1p6v(val) ((val >> 4) & 0xf)
+#define decode_0_1p6v(val) ((val >> 0) & 0xf)
+// Bit mapping USB_TYPEC_STS
+#define det_sts 0x7
+#define cc1_det_sts (det_sts)
+#define cc2_det_sts (det_sts << 3)
+#define det_sts_ra 0x1
+#define det_sts_rd 0x3
+#define det_sts_rp 0x1
+#define cc1_det_sts_ra (det_sts_ra)
+#define cc1_det_sts_rd (det_sts_rd)
+#define cc1_det_sts_rp (det_sts_rp)
+#define cc2_det_sts_ra (det_sts_ra << 3)
+#define cc2_det_sts_rd (det_sts_rd << 3)
+#define cc2_det_sts_rp (det_sts_rp << 3)
+
+// Bit mapping USB_TYPEC_CTRL
+#define cc2_int_en BIT(11)
+#define cc1_int_en BIT(10)
+#define cc2_int_sts BIT(9)
+#define cc1_int_sts BIT(8)
+#define debounce_time_MASK 0xff
+#define ENABLE_TYPE_C_DETECT (cc1_int_en | cc2_int_en)
+#define all_cc_int_sts (cc1_int_sts | cc2_int_sts)
+
+// Parameter
+#define DETECT_TIME 50 //ms
+
+static void enable_writel(int value, void __iomem *addr)
+{
+	writel(value | readl(addr),  addr);
+}
+
+static void disable_writel(int value, void __iomem *addr)
+{
+	writel(~value & readl(addr),  addr);
+}
+
+static void init_type_c_mode(struct type_c_data *type_c)
+{
+	if (type_c->chip_id == CHIP_ID_RTD1619) {
+		void __iomem *drd_wrap_base = type_c->wrap_base;
+		void __iomem *u3host_u3port_dis = ioremap(0x98013e60, 0x4);
+		int cc_set_offect = 0x194;
+
+		dev_info(type_c->dev, "%s: disable u3host u3phy for CHIP_ID_RTD1619\n",
+				    __func__);
+		enable_writel(BIT(8), u3host_u3port_dis);
+		enable_writel(BIT(0), drd_wrap_base + cc_set_offect);
+
+		iounmap(u3host_u3port_dis);
+	}
+}
+
+static void switch_type_c_plug_side(struct type_c_data *type_c, int cc)
+{
+	if ((type_c->chip_id & 0xFFF0) == CHIP_ID_RTD129X) {
+		void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+		int value;
+
+		value = (~SWITCH_MASK & readl(type_c_reg_base));
+		value |= cc;
+		writel(value, type_c_reg_base);
+	} else if (type_c->chip_id == CHIP_ID_RTD1619) {
+		void __iomem *drd_wrap_base = type_c->wrap_base;
+		void __iomem *u3host_wrap_base = ioremap(0x98013e00, 0xf);
+		int clock_offset = 0xc;
+		int cc_set_offect = 0x194;
+
+		if (cc == disable_cc) {
+			dev_info(type_c->dev, "%s: disable drd u3phy for CHIP_ID_RTD1619\n",
+				__func__);
+		} else {
+			disable_writel(BIT(1), drd_wrap_base + clock_offset);
+			disable_writel(BIT(1), u3host_wrap_base + clock_offset);
+			if (cc == enable_cc1) {
+				disable_writel(BIT(1), drd_wrap_base + cc_set_offect);
+				dev_info(type_c->dev, "%s: enable_cc1 drd u3phy for "
+					    "CHIP_ID_RTD1619\n", __func__);
+			} else if (cc == enable_cc2) {
+				enable_writel(BIT(1), drd_wrap_base + cc_set_offect);
+				dev_info(type_c->dev, "%s: enable_cc2 drd u3phy for "
+					    "CHIP_ID_RTD1619\n", __func__);
+			}
+			enable_writel(BIT(1), drd_wrap_base + clock_offset);
+			enable_writel(BIT(1), u3host_wrap_base + clock_offset);
+		}
+		iounmap(u3host_wrap_base);
+	}
+}
+
+static void switch_dwc3_mode(struct type_c_data *type_c, int dr_mode)
+{
+	if (!type_c->is_drd_mode)
+		dr_mode = type_c->dwc3_mode;
+	dev_dbg(type_c->dev, "%s START....", __func__);
+
+	type_c->cur_mode = dr_mode;
+	type_c->dwc->dr_mode = dr_mode;
+
+	switch (dr_mode) {
+	case USB_DR_MODE_PERIPHERAL:
+		dev_info(type_c->dev, "%s dr_mode=USB_DR_MODE_PERIPHERAL\n",
+			    __func__);
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+		dwc3_drd_to_device(type_c->dwc);
+#else
+		dev_err(type_c->dev, "NO add config CONFIG_USB_RTK_DWC3_DRD_MODE");
+#endif
+		mdelay(10);
+		writel(USB2_PHY_SWITCH_DEVICE |
+			    (~USB2_PHY_SWITCH_MASK &
+			    readl(type_c->wrap_base + USB2_PHY_reg)),
+			    type_c->wrap_base + USB2_PHY_reg);
+
+		break;
+	case USB_DR_MODE_HOST:
+		dev_info(type_c->dev, "%s dr_mode=USB_DR_MODE_HOST\n", __func__);
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+		dwc3_drd_to_host(type_c->dwc);
+#else
+		dev_err(type_c->dev, "NO add config CONFIG_USB_RTK_DWC3_DRD_MODE");
+#endif
+		mdelay(10);
+		writel(USB2_PHY_SWITCH_HOST |
+			    (~USB2_PHY_SWITCH_MASK &
+			    readl(type_c->wrap_base + USB2_PHY_reg)),
+			    type_c->wrap_base + USB2_PHY_reg);
+		break;
+	default:
+		dev_info(type_c->dev, "%s dr_mode=%d\n", __func__, dr_mode);
+		//mdelay(10);
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+		dwc3_drd_to_stop_all(type_c->dwc);
+#else
+		dev_err(type_c->dev, "NO add config CONFIG_USB_RTK_DWC3_DRD_MODE");
+#endif
+	}
+	dev_dbg(type_c->dev, "%s END....", __func__);
+}
+
+/* device attached / detached */
+int device_attached(struct type_c_data *type_c, u32 enable_cc)
+{
+	struct device		*dev = type_c->dev;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+
+	cancel_delayed_work(&type_c->delayed_work);
+
+	switch_dwc3_mode(type_c, USB_DR_MODE_HOST);
+
+	switch_type_c_plug_side(type_c, enable_cc);
+
+	dev_info(dev, "%s to enable power\n", __func__);
+	if (rtk_usb_type_c_power_on_off(dev, true))
+		dev_err(dev, "%s to enable type c power Fail\n", __func__);
+	else
+		dev_dbg(dev, "%s to enable type c power OK\n", __func__);
+
+	if (rtk_usb_set_type_c_switch_gpio(dev, true))
+		dev_info(dev, "%s to set switch_ctrl_gpio GPIO to high "
+			    "for 1395 QA board\n", __func__);
+
+	enable_writel(ENABLE_TYPE_C_DETECT, type_c_reg_base + USB_TYPEC_CTRL);
+	return 0;
+}
+
+int device_detached(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+
+	disable_writel(ENABLE_TYPE_C_DETECT, type_c_reg_base + USB_TYPEC_CTRL);
+
+	dev_info(dev, "%s to disable power\n", __func__);
+	if (rtk_usb_type_c_power_on_off(dev, false))
+		dev_err(dev, "%s to disable type c power Fail\n", __func__);
+	else
+		dev_dbg(dev, "%s to disable type c power OK\n", __func__);
+
+	switch_type_c_plug_side(type_c, disable_cc);
+
+	msleep(1000);
+
+	switch_dwc3_mode(type_c, 0);
+
+	dev_dbg(dev, "%s start new schedule_delayed_work\n", __func__);
+	schedule_delayed_work(&type_c->delayed_work,
+			msecs_to_jiffies(DETECT_TIME));
+	dev_dbg(dev, "%s ok new schedule_delayed_work\n", __func__);
+
+	return 0;
+}
+
+/* host connect /disconnect*/
+int host_connected(struct type_c_data *type_c, u32 enable_cc)
+{
+	struct device		*dev = type_c->dev;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+
+	dev_info(dev, "%s: a Host connect\n", __func__);
+
+	cancel_delayed_work(&type_c->delayed_work);
+
+	switch_dwc3_mode(type_c, USB_DR_MODE_PERIPHERAL);
+
+	switch_type_c_plug_side(type_c, enable_cc);
+
+	enable_writel(ENABLE_TYPE_C_DETECT, type_c_reg_base + USB_TYPEC_CTRL);
+	return 0;
+}
+
+int host_disconnected(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+
+	dev_info(dev, "%s: a Host disconnect\n", __func__);
+
+	disable_writel(ENABLE_TYPE_C_DETECT, type_c_reg_base + USB_TYPEC_CTRL);
+
+	switch_type_c_plug_side(type_c, disable_cc);
+
+	msleep(1000);
+
+	switch_dwc3_mode(type_c, 0);
+
+	schedule_delayed_work(&type_c->delayed_work, msecs_to_jiffies(DETECT_TIME));
+
+	return 0;
+}
+
+/* detect host device switch */
+static int detect_device(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	//struct device_node	*node = dev->of_node;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+	unsigned int gpio = type_c->rd_ctrl_gpio;
+	u32 cc1_config, cc2_config, default_ctrl;
+	int cc_mode_sel = type_c->cc_dfp_mode;
+
+	default_ctrl = readl(type_c_reg_base + USB_TYPEC_CTRL) & debounce_time_MASK;
+	writel(default_ctrl, type_c_reg_base + USB_TYPEC_CTRL);
+
+	disable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	disable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+
+	if (gpio != -1 && gpio_is_valid(gpio)) {
+		if (gpio_direction_output(gpio, 1))
+			dev_err(dev, "%s ERROR rd_ctrl_gpio=1 fail\n", __func__);
+	}
+
+	switch (cc_mode_sel) {
+	case CC_MODE_DFP_USB:
+		writel(type_c->cc1_vref_dfp_usb, type_c_reg_base + USB_TYPEC_CTRL_CC1_1);
+		writel(type_c->cc2_vref_dfp_usb, type_c_reg_base + USB_TYPEC_CTRL_CC2_1);
+		break;
+	case CC_MODE_DFP_1_5:
+		writel(type_c->cc1_vref_dfp_1_5, type_c_reg_base + USB_TYPEC_CTRL_CC1_1);
+		writel(type_c->cc2_vref_dfp_1_5, type_c_reg_base + USB_TYPEC_CTRL_CC2_1);
+		break;
+	case CC_MODE_DFP_3_0:
+		writel(type_c->cc1_vref_dfp_3_0, type_c_reg_base + USB_TYPEC_CTRL_CC1_1);
+		writel(type_c->cc2_vref_dfp_3_0, type_c_reg_base + USB_TYPEC_CTRL_CC2_1);
+		break;
+	default:
+		dev_err(dev, "%s ERROR cc_mode_sel=%d\n", __func__, cc_mode_sel);
+		break;
+	}
+	cc1_config = type_c->cc1_rp | type_c->cc1_rp_code | cc_mode(cc_mode_sel);
+	cc2_config = type_c->cc2_rp | type_c->cc2_rp_code | cc_mode(cc_mode_sel);
+
+	writel(cc1_config, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	writel(cc2_config, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+
+	wmb();
+
+	mdelay(1);
+	enable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	enable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+
+	return 0;
+}
+
+static int detect_host(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	//struct device_node	*node = dev->of_node;
+	void __iomem *type_c_reg_base = type_c->type_c_reg_base;
+	unsigned int gpio = type_c->rd_ctrl_gpio;
+	u32 cc1_config, cc2_config, default_ctrl;
+	u32 cc_rd = En_rd;
+
+	if (type_c->check_at_boot || (type_c->rd_config == EXTERNAL_Rd)) {
+		if ((type_c->chip_id & 0xFFF0) == CHIP_ID_RTD129X) {
+			cc_rd = 0;
+		} else {
+			dev_info(dev, "%s external Rd is build on chip, "
+				    "set EN_EXTERNAL_RD Bit 29\n", __func__);
+			cc_rd = EN_EXTERNAL_RD;
+		}
+	}
+
+	default_ctrl = readl(type_c_reg_base + USB_TYPEC_CTRL) & debounce_time_MASK;
+	writel(default_ctrl, type_c_reg_base + USB_TYPEC_CTRL);
+
+	disable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	disable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+
+	writel(type_c->cc1_vref_ufp, type_c_reg_base + USB_TYPEC_CTRL_CC1_1);
+	writel(type_c->cc2_vref_ufp, type_c_reg_base + USB_TYPEC_CTRL_CC2_1);
+
+	cc1_config = cc_rd | type_c->cc1_rd_code | cc_mode(CC_MODE_UFP);
+	cc2_config = cc_rd | type_c->cc2_rd_code | cc_mode(CC_MODE_UFP);
+
+	writel(cc1_config, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	writel(cc2_config, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+
+	if (cc_rd && gpio != -1 && gpio_is_valid(gpio)) {
+		// use internal Rd
+		if (gpio_direction_output(gpio, 1))
+			dev_err(dev, "%s ERROR rd_ctrl_gpio=1 fail\n", __func__);
+	} else if (gpio != -1 && gpio_is_valid(gpio)) {
+		// use external Rd
+		if (gpio_direction_output(gpio, 0))
+			dev_err(dev, "%s ERROR rd_ctrl_gpio=0 fail\n", __func__);
+	}
+	wmb();
+
+	mdelay(1);
+	enable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC1_0);
+	mdelay(2); // add a delay to avoid error cc2 interrupt on cc_status=0x0
+	enable_writel(En_cc_det, type_c_reg_base + USB_TYPEC_CTRL_CC2_0);
+	mdelay(1); // add a delay to avoid error cc2 interrupt on cc_status=0x0
+
+	return 0;
+}
+
+int host_device_switch_detection(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	int ret = 0;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+	if (type_c->debug)
+		dev_dbg(dev, "ENTER %s", __func__);
+	if (type_c->in_host_mode) {
+		type_c->in_host_mode = IN_DEVICE_MODE;
+		detect_host(type_c);
+		if (type_c->debug)
+			dev_dbg(dev, "Now device mode $$$$");
+	} else {
+		type_c->in_host_mode = IN_HOST_MODE;
+		detect_device(type_c);
+		if (type_c->debug)
+			dev_dbg(dev, "Now host mode   ####");
+	}
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	return ret;
+}
+
+int detect_type_c_state(struct type_c_data *type_c)
+{
+	struct device *dev = type_c->dev;
+	u32 int_status, cc_status, cc_status_check;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+
+	int_status = readl(type_c->type_c_reg_base + USB_TYPEC_CTRL);
+	cc_status = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+
+	type_c->connect_change = CONNECT_NO_CHANGE;
+
+	switch (type_c->in_host_mode) {
+	case IN_HOST_MODE:
+		switch (type_c->is_attach) {
+		case IN_ATTACH:
+			if (((cc_status & cc1_det_sts) == cc1_det_sts) &&
+				    (type_c->at_cc1 == AT_CC1)) {
+				dev_dbg(dev, "IN host mode and cc1 device detach "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_DETACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			} else if (((cc_status & cc2_det_sts) == cc2_det_sts) &&
+				    (type_c->at_cc1 == AT_CC2)) {
+				dev_dbg(dev, "IN host mode and cc2 device detach "
+				    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_DETACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			}
+		break;
+		case IN_DETACH:
+			cc_status_check = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			if (cc_status_check != (cc1_det_sts | cc2_det_sts)) {
+				if (in_interrupt()) {
+					mdelay(300);
+				} else {
+					spin_unlock_irqrestore(&type_c->lock, flags);
+					msleep(300);
+					spin_lock_irqsave(&type_c->lock, flags);
+				}
+				cc_status_check = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			}
+			if (cc_status != cc_status_check) {
+				dev_warn(dev, "IN_HOST_MODE: cc_status (0x%x) != "
+					    "cc_status_check (0x%x)\n",
+					    cc_status, cc_status_check);
+				cc_status = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			}
+
+			if ((cc_status & cc1_det_sts) == cc1_det_sts_rd) {
+				dev_dbg(dev, "IN host mode and cc1 device attach "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_ATTACH;
+				type_c->at_cc1 = AT_CC1;
+				type_c->connect_change = CONNECT_CHANGE;
+			} else if ((cc_status & cc2_det_sts) == cc2_det_sts_rd) {
+				dev_dbg(dev, "In host mode and cc2 device attach "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_ATTACH;
+				type_c->at_cc1 = AT_CC2;
+				type_c->connect_change = CONNECT_CHANGE;
+			}
+		break;
+		default:
+			dev_err(dev, "IN host_mode and error attach state (is_attach=%d)",
+				    type_c->is_attach);
+		}
+	break;
+	case IN_DEVICE_MODE:
+		switch (type_c->is_attach) {
+		case IN_ATTACH:
+			if ((cc_status & cc1_det_sts) < cc1_det_sts_rp &&
+				    type_c->at_cc1 == AT_CC1) {
+				dev_dbg(dev,"IN device mode and cc1 host disconnect "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_DETACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			} else if ((cc_status & cc2_det_sts) < cc2_det_sts_rp &&
+				    type_c->at_cc1 == AT_CC2) {
+				dev_dbg(dev,"IN device mode and cc2 host connect "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->is_attach = TO_DETACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			}
+		break;
+		case IN_DETACH:
+			cc_status_check = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			if (cc_status_check != 0x0) {
+				if (in_interrupt()) {
+					mdelay(300);
+				} else {
+					spin_unlock_irqrestore(&type_c->lock, flags);
+					msleep(300);
+					spin_lock_irqsave(&type_c->lock, flags);
+				}
+				cc_status_check = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			}
+			if (cc_status != cc_status_check) {
+				dev_warn(dev, "IN_DEVICE_MODE: cc_status (0x%x) != "
+					    "cc_status_check (0x%x)\n",
+					    cc_status, cc_status_check);
+				cc_status = readl(type_c->type_c_reg_base + USB_TYPEC_STS);
+			}
+
+			if ((cc_status & cc1_det_sts) >= cc1_det_sts_rp) {
+				dev_dbg(dev,"IN device mode and cc1 host connect "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->at_cc1 = AT_CC1;
+				type_c->is_attach = TO_ATTACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			} else if ((cc_status & cc2_det_sts) >= cc2_det_sts_rp) {
+				dev_dbg(dev,"IN device mode and cc2 host connect "
+					    "(cc_status=0x%x)", cc_status);
+				type_c->at_cc1 = AT_CC2;
+				type_c->is_attach = TO_ATTACH;
+				type_c->connect_change = CONNECT_CHANGE;
+			}
+		break;
+		default:
+			dev_err(dev, "IN device_mode and error attach state (is_attach=%d)",
+				    type_c->is_attach);
+		}
+	break;
+	default:
+		dev_err(dev, "error host or device mode (in_host_mode=%d)",
+			    type_c->in_host_mode);
+	}
+
+	type_c->int_status = int_status;
+	type_c->cc_status = cc_status;
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+	return 0;
+}
+
+void host_device_switch(struct work_struct *work)
+{
+	struct type_c_data *type_c = container_of(work,
+		    struct type_c_data, delayed_work.work);
+	struct device		*dev = type_c->dev;
+	unsigned long		flags;
+	int connect_change = 0;
+	int in_host_mode = 0;
+	int is_attach = 0;
+	int at_cc1 = 0;
+
+	if (type_c->debug) dev_dbg(type_c->dev, "ENTER %s", __func__);
+
+	if (type_c->is_attach == IN_DETACH && !type_c->connect_change) {
+		if (type_c->is_drd_mode)
+			host_device_switch_detection(type_c);
+		detect_type_c_state(type_c);
+	}
+
+	spin_lock_irqsave(&type_c->lock, flags);
+	if (type_c->connect_change) {
+		connect_change = type_c->connect_change;
+		in_host_mode = type_c->in_host_mode;
+		is_attach = type_c->is_attach;
+		at_cc1 = type_c->at_cc1;
+		type_c->connect_change = CONNECT_NO_CHANGE;
+	} else {
+		schedule_delayed_work(&type_c->delayed_work,
+			    msecs_to_jiffies(DETECT_TIME));
+	}
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	if (connect_change) {
+		dev_info(dev, "%s: usb cable connection change\n", __func__);
+#ifdef CONFIG_USB_TYPE_C_RTK_RTS5400
+		if (type_c->check_at_boot
+				&& rtk_rts5400_is_enabled()
+				&& rtk_rts5400_is_UFP_attached()) {
+			u32 enable_cc = at_cc1?enable_cc1:enable_cc2;
+			dev_info(dev, "%s: In Device mode, role swap to Host mode\n",
+				    __func__);
+			switch_dwc3_mode(type_c, USB_DR_MODE_HOST);
+			switch_type_c_plug_side(type_c, enable_cc);
+
+			rtk_rts5400_set_type_c_soft_reset();
+
+			type_c->check_at_boot = false;
+		} else
+#endif //CONFIG_USB_TYPE_C_RTK_RTS5400
+		if (in_host_mode) {
+			if (is_attach && at_cc1)
+				device_attached(type_c, enable_cc1);
+			else if (is_attach && !at_cc1)
+				device_attached(type_c, enable_cc2);
+			else
+				device_detached(type_c);
+		} else {
+			if (is_attach && at_cc1)
+				host_connected(type_c, enable_cc1);
+			else if (is_attach && !at_cc1)
+				host_connected(type_c, enable_cc2);
+			else
+				host_disconnected(type_c);
+		}
+		dev_err(dev, "Connection change OK: IN %s mode to %s %s at %s "
+			    "(cc_status=0x%x)\n",
+			    in_host_mode?"host":"device",
+			    in_host_mode?
+			        (is_attach?"attach":"detach"):
+			        (is_attach?"connect":"disconnect"),
+			    in_host_mode?"device":"host",
+			    at_cc1?"cc1":"cc2", type_c->cc_status);
+
+	}
+
+	/* For special case, some boards use type c power and need use host mode.
+	 * After 30s, We switch to host mode if in device mode but no host connect.
+	 */
+	if (type_c->check_at_boot) {
+		if (type_c->is_drd_mode && connect_change &&
+			(in_host_mode == IN_DEVICE_MODE) && is_attach) {
+			dev_info(dev, "%s: In Device mode check connection at boot time\n",
+				    __func__);
+			schedule_delayed_work(&type_c->boot_check_work,
+				    msecs_to_jiffies(type_c->boot_check_time));
+		}
+		type_c->check_at_boot = false;
+	}
+}
+
+void boot_time_check(struct work_struct *work)
+{
+	struct type_c_data *type_c = container_of(work,
+		    struct type_c_data, boot_check_work.work);
+	struct device		*dev = type_c->dev;
+	int at_cc1, in_host_mode, is_attach;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+
+	at_cc1 = type_c->at_cc1;
+	in_host_mode = type_c->in_host_mode;
+	is_attach = type_c->is_attach;
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	if (type_c->is_drd_mode &&
+			(in_host_mode == IN_DEVICE_MODE) && is_attach) {
+		int no_host_connect = 0;
+		int no_run_gadget = 0;
+		u32 enable_cc = at_cc1?enable_cc1:enable_cc2;
+		u32 dsts = dwc3_readl(type_c->dwc->regs, DWC3_DSTS);
+		u32 dctl = dwc3_readl(type_c->dwc->regs, DWC3_DCTL);
+
+		dev_info(dev, "%s: Device mode check DSTS=%x DCTL=%x\n", __func__,
+				dsts, dctl);
+		no_host_connect = (dsts & 0x0003FFF8) == BIT(17);
+		no_run_gadget = (dctl & BIT(31)) == 0x0;
+		if (no_host_connect || no_run_gadget) {
+			switch_type_c_plug_side(type_c, disable_cc);
+			mdelay(100);
+			dev_info(dev, "%s: In Device mode, NO host connect at boot time "
+				    "(After %dms), switch to Host mode\n",
+				    __func__, type_c->boot_check_time);
+			switch_dwc3_mode(type_c, USB_DR_MODE_HOST);
+			switch_type_c_plug_side(type_c, enable_cc);
+			/* for rtd1395 lion-skin*/
+			if (rtk_usb_set_type_c_switch_gpio(dev, false)) {
+				rtk_usb_type_c_power_on_off(dev, true);
+			}
+		}
+	}
+}
+
+irqreturn_t type_c_detect_irq(int irq, void *__data)
+{
+	struct type_c_data 	*type_c = (struct type_c_data *) __data;
+	struct device 		*dev = type_c->dev;
+	unsigned long		flags;
+	//u32 int_status, cc_status;
+
+	detect_type_c_state(type_c);
+
+	spin_lock_irqsave(&type_c->lock, flags);
+
+	if (type_c->connect_change) {
+		dev_info(dev, "%s: IN %s mode to %s %s (at %s interrupt) "
+			    "int_status=0x%x, cc_status=0x%x",
+			    __func__,
+			    type_c->in_host_mode?"host":"device",
+			    type_c->in_host_mode?
+			        (type_c->is_attach?"attach":"detach"):
+			        (type_c->is_attach?"connect":"disconnect"),
+			    type_c->in_host_mode?"device":"host",
+			    type_c->at_cc1?"cc1":"cc2",
+			    type_c->int_status, type_c->cc_status);
+
+		//clear interrupt status
+		disable_writel(all_cc_int_sts,
+			    type_c->type_c_reg_base + USB_TYPEC_CTRL);
+
+		cancel_delayed_work(&type_c->delayed_work);
+		schedule_delayed_work(&type_c->delayed_work, msecs_to_jiffies(0));
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+		if (type_c->drp)
+			dual_role_instance_changed(type_c->drp);
+#endif
+	} else {
+		static int local_count = 0;
+		if (local_count++ > 10) {
+			//clear interrupt status
+			disable_writel(all_cc_int_sts,
+			    type_c->type_c_reg_base + USB_TYPEC_CTRL);
+			local_count = 0;
+		}
+		if (type_c->debug)
+			dev_dbg(dev, "%s: ###NO change### Status: IN %s mode %s %s "
+				    "(at %s interrupt) int_status=0x%x, cc_status=0x%x",
+				__func__,
+				type_c->in_host_mode?"host":"device",
+				type_c->in_host_mode?
+					(type_c->is_attach?"attach":"detach"):
+					(type_c->is_attach?"connect":"disconnect"),
+				type_c->in_host_mode?"device":"host",
+				type_c->at_cc1?"cc1":"cc2", type_c->int_status, type_c->cc_status);
+	}
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+static int type_c_parameter_show(struct seq_file *s, void *unused)
+{
+	struct type_c_data		*type_c = s->private;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+
+	seq_printf(s, "Rd control gpio: %d\n", type_c->rd_ctrl_gpio);
+	seq_printf(s, "cc_dfp_mode %s\n",
+		    ({ char *tmp;
+		     switch (type_c->cc_dfp_mode) {
+		     case CC_MODE_DFP_USB: tmp = "CC_MODE_DFP_USB"; break;
+		     case CC_MODE_DFP_1_5: tmp = "CC_MODE_DFP_1_5"; break;
+		     case CC_MODE_DFP_3_0: tmp = "CC_MODE_DFP_3_0"; break;
+		     default: tmp = "?"; break;
+		     } tmp;}));
+	seq_printf(s, "cc1_rp 0x%x\n", type_c->cc1_rp);
+	seq_printf(s, "cc1_rp_code 0x%x\n",
+		    ({ int tmp;
+		     switch (type_c->cc_dfp_mode) {
+		     case CC_MODE_DFP_USB:
+		        tmp = code_rp12k(type_c->cc1_rp_code); break;
+		     case CC_MODE_DFP_1_5:
+		        tmp = code_rp36k(type_c->cc1_rp_code); break;
+		     case CC_MODE_DFP_3_0:
+		        tmp = code_rp4pk(type_c->cc1_rp_code); break;
+		     default: tmp = -1; break;
+		    } tmp;}));
+	seq_printf(s, "cc1_rd_code 0x%x (using %s Rd)\n",
+		    code_rd(type_c->cc1_rd_code),
+		    type_c->rd_config?"internal":"external");
+	seq_printf(s, "cc1_vref_ufp     vref_1p23v 0x%x vref_0p66v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_1p23v(type_c->cc1_vref_ufp),
+		    decode_0p66v(type_c->cc1_vref_ufp),
+		    decode_0p2v(type_c->cc1_vref_ufp));
+	seq_printf(s, "cc1_vref_dfp_usb vref_0_1p6v 0x%x vref_0p2v 0x%x\n",
+		    decode_0_1p6v(type_c->cc1_vref_dfp_usb),
+		    decode_0p2v(type_c->cc1_vref_dfp_usb));
+	seq_printf(s, "cc1_vref_dfp_1_5 vref_1_1p6v 0x%x vref_0p4v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_1_1p6v(type_c->cc1_vref_dfp_1_5),
+		    decode_0p4v(type_c->cc1_vref_dfp_1_5),
+		    decode_0p2v(type_c->cc1_vref_dfp_1_5));
+	seq_printf(s, "cc1_vref_dfp_3_0 vref_2p6v   0x%x vref_0p8v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_2p6v(type_c->cc1_vref_dfp_3_0),
+		    decode_0p8v(type_c->cc1_vref_dfp_3_0),
+		    decode_0p2v(type_c->cc1_vref_dfp_3_0));
+	seq_printf(s, "cc2_rp 0x%x\n", type_c->cc2_rp);
+	seq_printf(s, "cc2_rp_code 0x%x\n",
+		    ({ int tmp;
+		     switch (type_c->cc_dfp_mode) {
+		     case CC_MODE_DFP_USB: tmp = code_rp12k(type_c->cc2_rp_code); break;
+		     case CC_MODE_DFP_1_5: tmp = code_rp36k(type_c->cc2_rp_code); break;
+		     case CC_MODE_DFP_3_0: tmp = code_rp4pk(type_c->cc2_rp_code); break;
+		     default: tmp = -1; break;
+		    } tmp;}));
+	seq_printf(s, "cc2_rd_code 0x%x (using %s Rd)\n",
+		    code_rd(type_c->cc2_rd_code),
+		    type_c->rd_config?"internal":"external");
+	seq_printf(s, "cc2_vref_ufp     vref_1p23v 0x%x vref_0p66v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_1p23v(type_c->cc2_vref_ufp),
+		    decode_0p66v(type_c->cc2_vref_ufp),
+		    decode_0p2v(type_c->cc2_vref_ufp));
+	seq_printf(s, "cc2_vref_dfp_usb vref_0_1p6v 0x%x vref_0p2v 0x%x\n",
+		    decode_0_1p6v(type_c->cc2_vref_dfp_usb),
+		    decode_0p2v(type_c->cc2_vref_dfp_usb));
+	seq_printf(s, "cc2_vref_dfp_1_5 vref_1_1p6v 0x%x vref_0p4v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_1_1p6v(type_c->cc2_vref_dfp_1_5),
+		    decode_0p4v(type_c->cc2_vref_dfp_1_5),
+		    decode_0p2v(type_c->cc2_vref_dfp_1_5));
+	seq_printf(s, "cc2_vref_dfp_3_0 vref_2p6v   0x%x vref_0p8v 0x%x "
+		    "vref_0p2v 0x%x\n",
+		    decode_2p6v(type_c->cc2_vref_dfp_3_0),
+		    decode_0p8v(type_c->cc2_vref_dfp_3_0),
+		    decode_0p2v(type_c->cc2_vref_dfp_3_0));
+	seq_printf(s, "debounce_val 0x%x\n", type_c->debounce_val);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "dwc3_mode %s (%s)\n",
+		    ({ char *tmp;
+		     switch (type_c->dwc3_mode) {
+		     case USB_DR_MODE_PERIPHERAL: tmp = "USB_DR_MODE_PERIPHERAL"; break;
+		     case USB_DR_MODE_HOST: tmp = "USB_DR_MODE_HOST"; break;
+		     default: tmp = "USB_DR_MODE_UNKNOWN"; break;
+		    } tmp;}),
+		    type_c->is_drd_mode?"is DRD":"Not DRD");
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	return 0;
+}
+
+static int type_c_parameter_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, type_c_parameter_show, inode->i_private);
+}
+
+static const struct file_operations type_c_parameter_fops = {
+	.open			= type_c_parameter_open,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int type_c_set_parameter_show(struct seq_file *s, void *unused)
+{
+	//struct type_c_data		*type_c = s->private;
+
+	seq_printf(s, "cc_dfp_mode [CC_MODE_DFP_USB|CC_MODE_DFP_1_5|"
+		    "CC_MODE_DFP_3_0]\n");
+	seq_printf(s, "rd_config [internal|external]");
+	seq_printf(s, "cc1_rp_code 0x_value\n");
+	seq_printf(s, "cc1_rd_code 0x_value\n");
+	seq_printf(s, "cc1_vref_ufp_vref_1p23v 0x_value\n");
+	seq_printf(s, "cc1_vref_ufp_vref_0p66v 0x_value\n");
+	seq_printf(s, "cc1_vref_ufp_vref_0p2v  0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_usb_vref_1p6v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_usb_vref_0p2v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_1_5_vref_1p6v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_1_5_vref_0p4v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_1_5_vref_0p2v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_3_0_vref_2p6v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_3_0_vref_0p8v 0x_value\n");
+	seq_printf(s, "cc1_vref_dfp_3_0_vref_0p2v 0x_value\n");
+	seq_printf(s, "cc2_rp_code 0x_value\n");
+	seq_printf(s, "cc2_rd_code 0x_value\n");
+	seq_printf(s, "cc2_vref_ufp_vref_1p23v 0x_value\n");
+	seq_printf(s, "cc2_vref_ufp_vref_0p66v 0x_value\n");
+	seq_printf(s, "cc2_vref_ufp_vref_0p2v  0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_usb_vref_1p6v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_usb_vref_0p2v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_1_5_vref_1p6v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_1_5_vref_0p4v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_1_5_vref_0p2v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_3_0_vref_2p6v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_3_0_vref_0p8v 0x_value\n");
+	seq_printf(s, "cc2_vref_dfp_3_0_vref_0p2v 0x_value\n");
+	seq_printf(s, "debounce_val value\n");
+
+	return 0;
+}
+
+static int type_c_set_parameter_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, type_c_set_parameter_show, inode->i_private);
+}
+
+static ssize_t type_c_set_parameter_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct type_c_data		*type_c = s->private;
+	unsigned long		flags;
+	char			buffer[40];
+	char *buf = buffer;
+	u32 value;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+	if (!strncmp(buf, "cc_dfp_mode", 11)) {
+		buf = buf + 11;
+		buf = skip_spaces(buf);
+		if (!strncmp(buf, "CC_MODE_DFP_USB", 15)) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_USB;
+			type_c->cc1_rp = En_rp12k;
+			type_c->cc2_rp = En_rp12k;
+		} else if (!strncmp(buf, "CC_MODE_DFP_1_5", 15)) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_1_5;
+			type_c->cc1_rp = En_rp36k;
+			type_c->cc2_rp = En_rp36k;
+		} else if (!strncmp(buf, "CC_MODE_DFP_3_0", 15)) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_3_0;
+			type_c->cc1_rp = En_rp4p7k;
+			type_c->cc2_rp = En_rp4p7k;
+		} else {
+			dev_err(type_c->dev, "cc_dfp_mode UNKNOWN (%s)", buf);
+		}
+	} else if (!strncmp(buf, "rd_config", 9)) {
+		buf = buf + 9;
+		buf = skip_spaces(buf);
+		if (!strncmp(buf, "internal", 8))
+			type_c->rd_config = INTERNAL_Rd;
+		else if (!strncmp(buf, "external", 8))
+			type_c->rd_config = EXTERNAL_Rd;
+		else
+			dev_err(type_c->dev, "rd_config UNKNOWN (%s)", buf);
+
+	} else if (!strncmp(buf, "cc1_rp_code", 11)) {
+		buf = buf + 11;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		if (type_c->cc_dfp_mode == CC_MODE_DFP_USB)
+			type_c->cc1_rp_code = rp12k_code(value);
+		else if (type_c->cc_dfp_mode == CC_MODE_DFP_1_5)
+			type_c->cc1_rp_code = rp36k_code(value);
+		else if (type_c->cc_dfp_mode == CC_MODE_DFP_3_0)
+			type_c->cc1_rp_code = rp4pk_code(value);
+	} else if (!strncmp(buf, "cc1_rd_code", 11)) {
+		buf = buf + 11;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_rd_code = rd_code(value);
+	} else if (!strncmp(buf, "cc1_vref_ufp_vref_1p23v", 23)) {
+		buf = buf + 23;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_ufp = (type_c->cc1_vref_ufp & (~vref_1p23v(0xf))) |
+			    vref_1p23v(value);
+	} else if (!strncmp(buf, "cc1_vref_ufp_vref_0p66v", 23)) {
+		buf = buf + 23;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_ufp = (type_c->cc1_vref_ufp & (~vref_0p66v(0xf))) |
+			    vref_0p66v(value);
+	} else if (!strncmp(buf, "cc1_vref_ufp_vref_0p2v", 22)) {
+		buf = buf + 22;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_ufp = (type_c->cc1_vref_ufp & (~vref_0p2v(0x7))) |
+			    vref_0p2v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_usb_vref_1p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_usb = (type_c->cc1_vref_dfp_usb &
+			    (~vref_0_1p6v(0xf))) | vref_0_1p6v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_usb_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_usb = (type_c->cc1_vref_dfp_usb &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_1_5_vref_1p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_1_5 = (type_c->cc1_vref_dfp_1_5 &
+			    (~vref_1_1p6v(0xf))) | vref_1_1p6v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_1_5_vref_0p4v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_1_5 = (type_c->cc1_vref_dfp_1_5 &
+			    (~vref_0p4v(0x7))) | vref_0p4v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_1_5_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_1_5 = (type_c->cc1_vref_dfp_1_5 &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_3_0_vref_2p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_ufp = (type_c->cc1_vref_dfp_1_5 & (~vref_2p6v(0x7))) |
+			    vref_2p6v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_3_0_vref_0p8v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_3_0 = (type_c->cc1_vref_dfp_3_0 &
+			    (~vref_0p8v(0xf))) | vref_0p8v(value);
+	} else if (!strncmp(buf, "cc1_vref_dfp_3_0_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc1_vref_dfp_3_0 = (type_c->cc1_vref_dfp_3_0 &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "cc2_rp_code", 11)) {
+		buf = buf + 11;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%d", &value);
+		if (type_c->cc_dfp_mode == CC_MODE_DFP_USB)
+			type_c->cc2_rp_code = rp12k_code(value);
+		else if (type_c->cc_dfp_mode == CC_MODE_DFP_1_5)
+			type_c->cc2_rp_code = rp36k_code(value);
+		else if (type_c->cc_dfp_mode == CC_MODE_DFP_3_0)
+			type_c->cc2_rp_code = rp4pk_code(value);
+	} else if (!strncmp(buf, "cc2_rd_code", 11)) {
+		buf = buf + 11;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%d", &value);
+		type_c->cc2_rd_code = rd_code(value);
+	} else if (!strncmp(buf, "cc2_vref_ufp_vref_1p23v", 23)) {
+		buf = buf + 23;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_ufp = (type_c->cc2_vref_ufp & (~vref_1p23v(0xf))) |
+			    vref_1p23v(value);
+	} else if (!strncmp(buf, "cc2_vref_ufp_vref_0p66v", 23)) {
+		buf = buf + 23;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_ufp = (type_c->cc2_vref_ufp & (~vref_0p66v(0xf))) |
+			    vref_0p66v(value);
+	} else if (!strncmp(buf, "cc2_vref_ufp_vref_0p2v", 22)) {
+		buf = buf + 22;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_ufp = (type_c->cc2_vref_ufp & (~vref_0p2v(0x7))) |
+			    vref_0p2v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_usb_vref_1p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_usb = (type_c->cc2_vref_dfp_usb &
+			    (~vref_0_1p6v(0xf))) | vref_0_1p6v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_usb_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_usb = (type_c->cc2_vref_dfp_usb &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_1_5_vref_1p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_1_5 = (type_c->cc2_vref_dfp_1_5 &
+			    (~vref_1_1p6v(0xf))) | vref_1_1p6v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_1_5_vref_0p4v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_1_5 = (type_c->cc2_vref_dfp_1_5 &
+			    (~vref_0p4v(0x7))) | vref_0p4v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_1_5_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_1_5 = (type_c->cc2_vref_dfp_1_5 &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_3_0_vref_2p6v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_3_0 = (type_c->cc2_vref_dfp_3_0 &
+			    (~vref_2p6v(0x7))) | vref_2p6v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_3_0_vref_0p8v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_3_0 = (type_c->cc2_vref_dfp_3_0 &
+			    (~vref_0p8v(0xf))) | vref_0p8v(value);
+	} else if (!strncmp(buf, "cc2_vref_dfp_3_0_vref_0p2v", 26)) {
+		buf = buf + 26;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->cc2_vref_dfp_3_0 = (type_c->cc2_vref_dfp_3_0 &
+			    (~vref_0p2v(0x7))) | vref_0p2v(value);
+	} else if (!strncmp(buf, "debounce_val", 12)) {
+		buf = buf + 12;
+		buf = skip_spaces(buf);
+		sscanf(buf, "%x", &value);
+		type_c->debounce_val = value;
+	} else
+		dev_err(type_c->dev, "UNKNOWN input (%s)", buf);
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+	return count;
+}
+
+static const struct file_operations type_c_set_parameter_fops = {
+	.open			= type_c_set_parameter_open,
+	.write			= type_c_set_parameter_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int type_c_status_show(struct seq_file *s, void *unused)
+{
+	struct type_c_data		*type_c = s->private;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&type_c->lock, flags);
+
+	seq_printf(s, "cur_mode %s\n",
+		    ({ char *tmp;
+		     switch (type_c->cur_mode) {
+		     case USB_DR_MODE_PERIPHERAL:
+		        tmp = "USB_DR_MODE_PERIPHERAL"; break;
+		     case USB_DR_MODE_HOST: tmp = "USB_DR_MODE_HOST"; break;
+		     default: tmp = "USB_DR_MODE_UNKNOWN"; break;
+		    } tmp;}));
+
+	seq_printf(s, "In %s mode %s %s at %s (cc_status=0x%x)\n",
+		    type_c->in_host_mode?"host":"device",
+		    type_c->in_host_mode?
+		        (type_c->is_attach?"attach":"detach"):
+		        (type_c->is_attach?"connect":"disconnect"),
+		    type_c->in_host_mode?"device":"host",
+		    type_c->at_cc1?"cc1":"cc2", type_c->cc_status);
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	return 0;
+}
+
+static int type_c_status_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, type_c_status_show, inode->i_private);
+}
+
+static const struct file_operations type_c_status_fops = {
+	.open			= type_c_status_open,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int type_c_debug_show(struct seq_file *s, void *unused)
+{
+	struct type_c_data		*type_c = s->private;
+
+	seq_printf(s, "Debug: %s\n",
+				type_c->debug?"Enable":"disable");
+
+	return 0;
+}
+
+static int type_c_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, type_c_debug_show, inode->i_private);
+}
+
+static ssize_t type_c_debug_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct type_c_data		*type_c = s->private;
+	char			buf[32];
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "enable", 6))
+		type_c->debug = true;
+	else if (!strncmp(buf, "disable", 7))
+		type_c->debug = false;
+
+	return count;
+}
+
+static const struct file_operations type_c_debug_fops = {
+	.open			= type_c_debug_open,
+	.write			= type_c_debug_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static inline void create_debug_files(struct type_c_data *type_c)
+{
+	dev_err(type_c->dev, "%s", __func__);
+
+	type_c->debug_dir = debugfs_create_dir("type_c", usb_debug_root);
+	if (!type_c->debug_dir) {
+		dev_err(type_c->dev, "%s Error debug_dir is NULL", __func__);
+		return;
+	}
+
+	if (!debugfs_create_file("parameter", S_IRUGO, type_c->debug_dir, type_c,
+		    &type_c_parameter_fops))
+		goto file_error;
+
+	if (!debugfs_create_file("set_parameter", S_IRUGO | S_IWUSR,
+		    type_c->debug_dir, type_c,
+		    &type_c_set_parameter_fops))
+		goto file_error;
+
+	if (!debugfs_create_file("status", S_IRUGO, type_c->debug_dir, type_c,
+		    &type_c_status_fops))
+		goto file_error;
+
+	if (!debugfs_create_file("debug", S_IRUGO | S_IWUSR,
+		    type_c->debug_dir, type_c,
+		    &type_c_debug_fops))
+		goto file_error;
+
+	return;
+
+file_error:
+	debugfs_remove_recursive(type_c->debug_dir);
+}
+#endif //CONFIG_DYNAMIC_DEBUG
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+static enum dual_role_property fusb_drp_properties[] = {
+	DUAL_ROLE_PROP_MODE,
+	DUAL_ROLE_PROP_PR,
+	DUAL_ROLE_PROP_DR,
+};
+
+static int dual_role_get_local_prop(struct dual_role_phy_instance *drp,
+				enum dual_role_property prop,
+				unsigned int *val)
+{
+	struct type_c_data *type_c = dual_role_get_drvdata(drp);
+
+	if (!type_c) {
+		pr_err("driver data not ready\n");
+		return -1;
+	}
+	detect_type_c_state(type_c);
+
+	if(type_c->cur_mode == USB_DR_MODE_PERIPHERAL) {
+		if (prop == DUAL_ROLE_PROP_MODE)
+			*val = DUAL_ROLE_PROP_MODE_UFP;
+		else if(prop == DUAL_ROLE_PROP_PR)
+			*val = DUAL_ROLE_PROP_PR_SNK;
+		else if(prop == DUAL_ROLE_PROP_DR)
+			*val = DUAL_ROLE_PROP_DR_DEVICE;
+		else
+			return -EINVAL;
+	} else if(type_c->cur_mode == USB_DR_MODE_HOST) {
+		if (prop == DUAL_ROLE_PROP_MODE)
+			*val = DUAL_ROLE_PROP_MODE_DFP;
+		else if (prop == DUAL_ROLE_PROP_PR)
+			*val = DUAL_ROLE_PROP_PR_SRC;
+		else if (prop == DUAL_ROLE_PROP_DR)
+			*val = DUAL_ROLE_PROP_DR_HOST;
+		else
+			return -EINVAL;
+	} else {
+		if (prop == DUAL_ROLE_PROP_MODE)
+			*val = DUAL_ROLE_PROP_MODE_NONE;
+		else if (prop == DUAL_ROLE_PROP_PR)
+			*val = DUAL_ROLE_PROP_PR_NONE;
+		else if (prop == DUAL_ROLE_PROP_DR)
+			*val = DUAL_ROLE_PROP_DR_NONE;
+		else
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dual_role_is_writeable(struct dual_role_phy_instance *drp,
+				enum dual_role_property prop)
+{
+	if (prop == DUAL_ROLE_PROP_MODE)
+		return 1;
+	else
+		return 0;
+}
+#if 0
+static int dual_role_set_mode_prop(struct dual_role_phy_instance *drp,
+				enum dual_role_property prop,
+				const unsigned int *val)
+{
+	pr_err("%s\n", __func__);
+	return 0;
+}
+
+static int dual_role_set_prop(struct dual_role_phy_instance *drp,
+				enum dual_role_property prop,
+				const unsigned int *val)
+{
+	if (prop == DUAL_ROLE_PROP_MODE)
+		return dual_role_set_mode_prop(drp, prop, val);
+	else
+		return -EINVAL;
+}
+#endif
+#endif
+
+/* Init and probe */
+static int dwc3_rtk_type_c_init(struct type_c_data *type_c)
+{
+	struct device		*dev = type_c->dev;
+	u32 debounce_val = type_c->debounce_val;// 1b,1us 7f,4.7us
+
+	enable_writel(debounce_val<<1,
+		    type_c->type_c_reg_base + USB_TYPEC_CTRL);
+	dev_info(dev, "%s set debounce = 0x%x (check--> 0x%x)\n",
+		    __func__, debounce_val,
+		    readl(type_c->type_c_reg_base + USB_TYPEC_CTRL));
+
+	if ((type_c->rd_ctrl_gpio != -1) &&
+		    gpio_request(type_c->rd_ctrl_gpio, dev->of_node->name))
+		dev_err(dev, "%s ERROR Request rd_ctrl_gpio  (id=%d) fail\n",
+			   __func__, type_c->rd_ctrl_gpio);
+
+	init_type_c_mode(type_c);
+
+	if (type_c->cur_mode == USB_DR_MODE_UNKNOWN)
+		switch_dwc3_mode(type_c, 0);
+
+	if (type_c->dwc3_mode == USB_DR_MODE_HOST) {
+		unsigned long		flags;
+
+		spin_lock_irqsave(&type_c->lock, flags);
+
+		dev_info(dev, "DWC3_DRD run in USB_DR_MODE_HOST");
+		type_c->in_host_mode = IN_HOST_MODE;
+		type_c->is_attach = IN_DETACH;
+		type_c->connect_change = CONNECT_NO_CHANGE;
+		type_c->cur_mode = USB_DR_MODE_HOST;
+
+		detect_device(type_c);
+
+		spin_unlock_irqrestore(&type_c->lock, flags);
+
+		detect_type_c_state(type_c);
+
+		schedule_delayed_work(&type_c->delayed_work,
+			    msecs_to_jiffies(0));
+	} else if (type_c->dwc3_mode == USB_DR_MODE_PERIPHERAL) {
+		unsigned long		flags;
+
+		spin_lock_irqsave(&type_c->lock, flags);
+
+		dev_info(dev, "DWC3_DRD run in USB_DR_MODE_PERIPHERAL%s",
+				type_c->is_drd_mode?" at DRD mode":"");
+		type_c->in_host_mode = IN_DEVICE_MODE;
+		type_c->is_attach = IN_DETACH;
+		type_c->connect_change = CONNECT_NO_CHANGE;
+		type_c->cur_mode = USB_DR_MODE_PERIPHERAL;
+		type_c->check_at_boot = true;
+
+		detect_host(type_c);
+
+		spin_unlock_irqrestore(&type_c->lock, flags);
+
+		detect_type_c_state(type_c);
+
+		schedule_delayed_work(&type_c->delayed_work,
+			    msecs_to_jiffies(0));
+	} else {
+		dev_err(dev, "DWC3_DRD is USB_DR_MODE_UNKNOWN");
+	}
+	return 0;
+}
+
+extern int rtk_usb_manager_schedule_work(struct device *usb_dev,
+	    struct work_struct *work);
+
+static void dwc3_rtk_type_c_probe_work(struct work_struct *work)
+{
+	struct type_c_data *type_c = container_of(work,
+		    struct type_c_data, start_work);
+	struct device		*dev = type_c->dev;
+	int    ret = 0;
+
+	unsigned long probe_time = jiffies;
+
+	dev_info(dev, "%s Start ...\n", __func__);
+
+	ret = dwc3_rtk_type_c_init(type_c);
+
+	if (ret)
+		dev_err(dev, "%s failed to init type_c\n", __func__);
+
+	dev_info(dev, "%s End ... ok! (take %d ms)\n", __func__,
+		    jiffies_to_msecs(jiffies - probe_time));
+}
+
+static int dwc3_rtk_type_c_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*node = dev->of_node;
+	struct type_c_data 	*type_c;
+	unsigned int gpio;
+	int irq;
+	int ret = 0;
+	unsigned long probe_time = jiffies;
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	struct dual_role_phy_desc *desc;
+	struct dual_role_phy_instance *dual_role;
+#endif
+
+
+	dev_info(dev, "ENTER %s", __func__);
+	type_c = devm_kzalloc(dev, sizeof(*type_c), GFP_KERNEL);
+	if (!type_c)
+		return -ENOMEM;
+
+	type_c->wrap_base = of_iomap(pdev->dev.of_node, 0);
+	if (type_c->wrap_base == NULL) {
+		dev_err(&pdev->dev, "error mapping memory for wrap_base\n");
+		ret = -EFAULT;
+		goto err1;
+	}
+
+	type_c->type_c_reg_base = of_iomap(pdev->dev.of_node, 1);
+	if (type_c->type_c_reg_base == NULL) {
+		type_c->type_c_reg_base = type_c->wrap_base + 0x14C; // for Kylin case
+		dev_warn(&pdev->dev, "No mapping memory for type_c_reg_base!\n");
+		dev_warn(&pdev->dev, "Let type_c_reg_base = %p\n",
+			    type_c->type_c_reg_base);
+	}
+
+	type_c->dev = dev;
+
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev, "Type C driver with no IRQ. Check %s setup!\n",
+				dev_name(&pdev->dev));
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	ret = request_irq(irq, type_c_detect_irq,
+			IRQF_SHARED, "type_c_detect", type_c);
+
+	if (node && of_device_is_available(node)) {
+		gpio = of_get_named_gpio(node, "realtek,rd_ctrl-gpio", 0);
+
+		if (gpio_is_valid(gpio)) {
+			type_c->rd_ctrl_gpio = gpio;
+			dev_info(dev, "%s get rd_ctrl-gpio (id=%d) OK\n", __func__, gpio);
+		} else {
+			dev_err(dev, "Error rd_ctrl-gpio no found");
+			type_c->rd_ctrl_gpio = -1;
+		}
+
+		ret = of_property_read_u32(node, "boot_check_time",
+			&type_c->boot_check_time);
+		if (ret) {
+			type_c->boot_check_time = 30000; //ms
+		}
+		dev_info(dev, "Set device mode boot_check_time %d ms\n",
+			    type_c->boot_check_time);
+	}
+
+	type_c->chip_id = get_rtd_chip_id();
+	type_c->chip_revision = get_rtd_chip_revision();
+
+	if (node && of_device_is_available(node)) {
+		const char *str;
+		u32 val;
+		struct device_node *sub_node;
+		u8 array_vals[3];
+		u32 u32_vals[3];
+		u32 default_revision;
+		char revision[4] = {0};
+
+		ret = of_property_read_u32(node, "default_revision",
+			    &default_revision);
+		if (ret) {
+			default_revision = 0xA00;
+			dev_info(dev, "%s: No set default_revision (use %x)\n",
+				    __func__, default_revision);
+		}
+
+		if (type_c->chip_revision > default_revision)
+			snprintf(revision, 4, "%X", default_revision);
+		else
+			snprintf(revision, 4, "%X", type_c->chip_revision);
+		dev_info(dev, "Chip %x revision is %x (support revision %x) "
+			    "to load %s parameter\n",
+			    type_c->chip_id, type_c->chip_revision,
+			    default_revision, revision);
+		sub_node = of_get_child_by_name(node, revision);
+
+		ret = of_property_read_string(sub_node, "cc_dfp_mode", &str);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc_dfp_mode error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		if (!strcmp(str, "dfp_usb")) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_USB;
+			type_c->cc1_rp = En_rp12k;
+			type_c->cc2_rp = En_rp12k;
+		} else if (!strcmp(str, "dfp_1_5")) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_1_5;
+			type_c->cc1_rp = En_rp36k;
+			type_c->cc2_rp = En_rp36k;
+		} else if (!strcmp(str, "dfp_3_0")) {
+			type_c->cc_dfp_mode = CC_MODE_DFP_3_0;
+			type_c->cc1_rp = En_rp4p7k;
+			type_c->cc2_rp = En_rp4p7k;
+		} else {
+			dev_err(&pdev->dev, "%s: unknown cc_dfp_mode %s\n", __func__, str);
+		}
+
+		//cc1 parameters
+		ret = of_property_read_u32(sub_node, "cc1_rp_4p7k_code", &u32_vals[0]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_rp_4p7k_code error(%d)\n",
+				    __func__, u32_vals[0]);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc1_rp_36k_code", &u32_vals[1]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_rp_36k_code error(%d)\n", __func__,
+				    u32_vals[1]);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc1_rp_12k_code", &u32_vals[2]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_rp_12k_code error(%d)\n",
+				    __func__, u32_vals[2]);
+			goto err1;
+		}
+		type_c->cc1_rp_code = rp4pk_code(u32_vals[0])
+				| rp36k_code(u32_vals[1])
+				| rp12k_code(u32_vals[2]);
+
+		ret = of_property_read_string(sub_node, "rd_config", &str);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: rd_config error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc1_rd_code", &val);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_rd_code error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		if (!strcmp(str, "internal")) {
+			type_c->rd_config = INTERNAL_Rd;
+			type_c->cc1_rd_code = rd_code(val);
+		} else if (!strcmp(str, "external")) {
+			type_c->rd_config = EXTERNAL_Rd;
+			type_c->cc1_rd_code = 0x0;
+		} else {
+			dev_err(&pdev->dev, "%s: unknown rd_config %s, cc1_rd_code=%d\n",
+				    __func__, str, val);
+		}
+		ret = of_property_read_u8_array(sub_node, "cc1_vref_ufp",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_vref_ufp error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		type_c->cc1_vref_ufp = vref_1p23v(array_vals[0]) |
+			    vref_0p66v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		ret = of_property_read_u8_array(sub_node, "cc1_vref_dfp_usb",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_vref_dfp_usb error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc1_vref_dfp_usb = vref_0_1p6v(array_vals[0]) |
+			    vref_0p2v(array_vals[1]);
+
+		ret = of_property_read_u8_array(sub_node, "cc1_vref_dfp_1_5",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_vref_dfp_1_5 error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc1_vref_dfp_1_5 = vref_1_1p6v(array_vals[0]) |
+			     vref_0p4v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		ret = of_property_read_u8_array(sub_node, "cc1_vref_dfp_3_0",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc1_vref_dfp_3_0 error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc1_vref_dfp_3_0 = vref_2p6v(array_vals[0]) |
+			    vref_0p8v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		//cc2 parameters
+		ret = of_property_read_u32(sub_node, "cc2_rp_4p7k_code", &u32_vals[0]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_rp_4p7k_code error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc2_rp_36k_code", &u32_vals[1]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_rp_36k_code error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc2_rp_12k_code", &u32_vals[2]);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_rp_12k_code error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc2_rp_code = rp4pk_code(array_vals[0])
+				| rp36k_code(array_vals[1])
+				| rp12k_code(array_vals[2]);
+
+		ret = of_property_read_string(sub_node, "rd_config", &str);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: rd_config error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		ret = of_property_read_u32(sub_node, "cc2_rd_code", &val);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_rd_code error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		if (!strcmp(str, "internal")) {
+			type_c->cc2_rd_code = rd_code(val);
+		} else if (!strcmp(str, "external")) {
+			type_c->cc2_rd_code = 0x0;
+		} else {
+			dev_err(&pdev->dev, "%s: unknown rd_code %s, cc2_rd_code=%d\n",
+				    __func__, str, val);
+		}
+
+		ret = of_property_read_u8_array(sub_node, "cc2_vref_ufp",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_vref_ufp error(%d)\n", __func__, ret);
+			goto err1;
+		}
+		type_c->cc2_vref_ufp = vref_1p23v(array_vals[0]) |
+			    vref_0p66v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		ret = of_property_read_u8_array(sub_node, "cc2_vref_dfp_usb",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_vref_dfp_usb error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc2_vref_dfp_usb = vref_0_1p6v(array_vals[0]) |
+			    vref_0p2v(array_vals[1]);
+
+		ret = of_property_read_u8_array(sub_node, "cc2_vref_dfp_1_5",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_vref_dfp_1_5 error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc2_vref_dfp_1_5 = vref_1_1p6v(array_vals[0]) |
+			    vref_0p4v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		ret = of_property_read_u8_array(sub_node, "cc2_vref_dfp_3_0",
+			    array_vals, 3);
+		if (ret) {
+			dev_err(&pdev->dev, "%s: cc2_vref_dfp_3_0 error(%d)\n",
+				    __func__, ret);
+			goto err1;
+		}
+		type_c->cc2_vref_dfp_3_0 = vref_2p6v(array_vals[0]) |
+			    vref_0p8v(array_vals[1]) | vref_0p2v(array_vals[2]);
+
+		type_c->debounce_val = 0x7f;// 1b,1us 7f,4.7us
+	}
+
+	if (true) {
+		struct device_node	*parent_node;
+		struct device_node	*next_node;
+
+		parent_node = of_get_parent(node);
+		next_node = of_get_next_child(parent_node, NULL);
+		if (next_node != NULL) {
+			type_c->dwc = platform_get_drvdata(
+				    of_find_device_by_node(next_node));
+		} else {
+			dev_err(dev, "%s No find dwc3_drd", __func__);
+			ret = -ENODEV;
+			goto err1;
+		}
+		if (type_c->dwc) {
+			type_c->dwc3_mode = type_c->dwc->dr_mode;
+		} else {
+			dev_err(dev, "%s dwc3_drd device dwc is NULL", __func__);
+			ret = -ENODEV;
+			goto err1;
+		}
+	}
+
+	type_c->cur_mode = USB_DR_MODE_UNKNOWN;
+	type_c->is_attach = IN_DETACH;
+	type_c->is_drd_mode = false;
+	if (of_property_read_bool(node, "drd_mode")) {
+		if (type_c->dwc3_mode == USB_DR_MODE_PERIPHERAL) {
+			type_c->is_drd_mode = true;
+			dev_info(dev, "DWC3_DRD is DRD mode");
+		} else {
+			dev_info(dev, "DWC3_DRD is not DRD mode, "
+				   "due to dwc3_mode=USB_DR_MODE_HOST");
+		}
+	} else {
+		dev_dbg(dev, "DWC3_DRD is no drd_mode, and dwc3_mode=%d",
+			    type_c->dwc3_mode);
+	}
+
+	if (of_property_read_bool(node, "debug")) {
+		dev_info(&pdev->dev, "%s device tree set debug flag\n", __func__);
+		type_c->debug = true;
+	} else {
+		type_c->debug = false;
+	}
+
+	INIT_DELAYED_WORK(&type_c->delayed_work, host_device_switch);
+	INIT_DELAYED_WORK(&type_c->boot_check_work, boot_time_check);
+
+	if (node) {
+		if (of_property_read_bool(node, "delay_probe_work")) {
+			INIT_WORK(&type_c->start_work, dwc3_rtk_type_c_probe_work);
+
+			if (of_property_read_bool(node, "ordered_probe"))
+				rtk_usb_manager_schedule_work(dev, &type_c->start_work);
+			else
+				schedule_work(&type_c->start_work);
+		} else {
+			ret = dwc3_rtk_type_c_init(type_c);
+			if (ret) {
+				dev_err(dev, "%s failed to init type_c\n", __func__);
+				goto err1;
+			}
+		}
+	} else {
+		dev_err(dev, "no device node, failed to init type_c\n");
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	platform_set_drvdata(pdev, type_c);
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+	create_debug_files(type_c);
+#endif
+
+#ifdef CONFIG_DUAL_ROLE_USB_INTF
+	desc = devm_kzalloc(dev, sizeof(struct dual_role_phy_desc), GFP_KERNEL);
+	if (!desc) {
+		dev_err(dev, "%s, dual role descriptor malloc fail\n", __func__);
+		goto err1;
+	}
+	desc->name = "dwc3_otg";
+	desc->supported_modes = DUAL_ROLE_SUPPORTED_MODES_DFP_AND_UFP;
+	desc->get_property = dual_role_get_local_prop;
+//	desc->set_property = dual_role_set_prop;
+	desc->properties = fusb_drp_properties;
+	desc->num_properties = ARRAY_SIZE(fusb_drp_properties);
+	desc->property_is_writeable = dual_role_is_writeable;
+	dual_role = devm_dual_role_instance_register(dev, desc);
+	dual_role->drv_data = type_c;
+	type_c->drp = dual_role;
+#endif
+
+	dev_info(&pdev->dev, "Exit %s OK (take %d ms)\n", __func__,
+		    jiffies_to_msecs(jiffies - probe_time));
+	return 0;
+
+err1:
+	dev_err(&pdev->dev, "%s: Probe fail, %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int dwc3_rtk_type_c_remove(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct type_c_data *type_c = dev_get_drvdata(dev);
+	u32 default_ctrl;
+	unsigned long		flags;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+
+	cancel_delayed_work_sync(&type_c->delayed_work);
+	flush_delayed_work(&type_c->delayed_work);
+	BUG_ON(delayed_work_pending(&type_c->delayed_work));
+
+	cancel_delayed_work_sync(&type_c->boot_check_work);
+	flush_delayed_work(&type_c->boot_check_work);
+	BUG_ON(delayed_work_pending(&type_c->boot_check_work));
+
+	spin_lock_irqsave(&type_c->lock, flags);
+	//disable interrupt
+	default_ctrl = readl(type_c->type_c_reg_base + USB_TYPEC_CTRL) &
+		    debounce_time_MASK;
+	writel(default_ctrl, type_c->type_c_reg_base + USB_TYPEC_CTRL);
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+	dev_info(&pdev->dev, "[USB] Exit %s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id rtk_dwc3_type_c_match[] = {
+	{ .compatible = "Realtek,dwc3-type_c" },
+	{ .compatible = "Realtek,rtd1295-dwc3-type_c" },
+	{ .compatible = "Realtek,rtd1296-dwc3-type_c" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_dwc3_type_c_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int dwc3_rtk_type_c_prepare(struct device *dev) {
+	struct type_c_data *type_c = dev_get_drvdata(dev);
+	int ret = 0;
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//	} else {
+		dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return ret;
+}
+
+static void dwc3_rtk_type_c_complete(struct device *dev) {
+	struct type_c_data *type_c = dev_get_drvdata(dev);
+	unsigned long		flags;
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s S1 (Standby mode)\n", __func__);
+//	} else {
+		dev_info(dev, "[USB] %s S3 (Suspend-to-RAM mode)\n", __func__);
+			spin_lock_irqsave(&type_c->lock, flags);
+			switch_type_c_plug_side(type_c, disable_cc);
+			spin_unlock_irqrestore(&type_c->lock, flags);
+
+		if ((type_c->chip_id & 0xFFF0) == CHIP_ID_RTD129X) {
+			if (rtk_usb_type_c_power_on_off(dev, false))
+				dev_err(dev, "%s to disable type c power Fail\n", __func__);
+			else
+				dev_dbg(dev, "%s to disable type c power OK\n", __func__);
+		}
+
+		dwc3_rtk_type_c_init(type_c);
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+}
+
+static int dwc3_rtk_type_c_suspend(struct device *dev)
+{
+	struct type_c_data *type_c = dev_get_drvdata(dev);
+	u32 default_ctrl;
+	unsigned long		flags;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+
+	cancel_delayed_work_sync(&type_c->delayed_work);
+	flush_delayed_work(&type_c->delayed_work);
+	BUG_ON(delayed_work_pending(&type_c->delayed_work));
+
+	cancel_delayed_work_sync(&type_c->boot_check_work);
+	flush_delayed_work(&type_c->boot_check_work);
+	BUG_ON(delayed_work_pending(&type_c->boot_check_work));
+
+	spin_lock_irqsave(&type_c->lock, flags);
+	//disable interrupt
+	default_ctrl = readl(type_c->type_c_reg_base + USB_TYPEC_CTRL) &
+		    debounce_time_MASK;
+	writel(default_ctrl, type_c->type_c_reg_base + USB_TYPEC_CTRL);
+
+	spin_unlock_irqrestore(&type_c->lock, flags);
+
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	//For suspend mode
+	dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+
+	if (type_c->rd_ctrl_gpio != -1)
+		gpio_free(type_c->rd_ctrl_gpio);
+
+out:
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return 0;
+}
+
+static int dwc3_rtk_type_c_resume(struct device *dev)
+{
+	struct type_c_data *type_c = dev_get_drvdata(dev);
+	unsigned long		flags;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		spin_lock_irqsave(&type_c->lock, flags);
+//		//enable interrupt
+//		if (type_c->is_attach == IN_ATTACH)
+//			enable_writel(ENABLE_TYPE_C_DETECT,
+//			    type_c->type_c_reg_base + USB_TYPEC_CTRL);
+//
+//		schedule_delayed_work(&type_c->delayed_work, msecs_to_jiffies(1));
+//		spin_unlock_irqrestore(&type_c->lock, flags);
+//		goto out;
+//	} else {
+		//For suspend mode
+		dev_info(dev, "[USB] %s Suspend mode\n", __func__);
+
+		if (type_c->cur_mode == USB_DR_MODE_HOST) {
+			writel(USB2_PHY_SWITCH_HOST |
+				    (~USB2_PHY_SWITCH_MASK &
+				    readl(type_c->wrap_base + USB2_PHY_reg)),
+				    type_c->wrap_base + USB2_PHY_reg);
+			dev_info(dev, "%s USB_DR_MODE_HOST to enable power\n", __func__);
+			if (rtk_usb_type_c_power_on_off(dev, true))
+				dev_err(dev, "%s to enable type c power Fail\n", __func__);
+			else
+				dev_dbg(dev, "%s to enable type c power OK\n", __func__);
+		} else if (type_c->cur_mode == USB_DR_MODE_PERIPHERAL) {
+			writel(USB2_PHY_SWITCH_DEVICE |
+				    (~USB2_PHY_SWITCH_MASK &
+				    readl(type_c->wrap_base + USB2_PHY_reg)),
+				    type_c->wrap_base + USB2_PHY_reg);
+		}
+
+		spin_lock_irqsave(&type_c->lock, flags);
+		if (type_c->is_attach == IN_ATTACH && type_c->at_cc1 == AT_CC1)
+			switch_type_c_plug_side(type_c, enable_cc1);
+		else if (type_c->is_attach == IN_ATTACH && type_c->at_cc1 == AT_CC2)
+			switch_type_c_plug_side(type_c, enable_cc2);
+		spin_unlock_irqrestore(&type_c->lock, flags);
+//	}
+out:
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops dwc3_rtk_type_c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc3_rtk_type_c_suspend, dwc3_rtk_type_c_resume)
+	.prepare = dwc3_rtk_type_c_prepare,
+	.complete = dwc3_rtk_type_c_complete,
+};
+
+#define DEV_PM_OPS	(&dwc3_rtk_type_c_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static struct platform_driver dwc3_rtk_type_c_driver = {
+	.probe		= dwc3_rtk_type_c_probe,
+	.remove		= dwc3_rtk_type_c_remove,
+	.driver		= {
+		.name	= "rtk-dwc3-type_c",
+		.of_match_table = of_match_ptr(rtk_dwc3_type_c_match),
+		.pm = DEV_PM_OPS,
+	},
+};
+
+static int __init dwc3_rtk_type_c_driver_init(void)
+{
+	return platform_driver_register(&(dwc3_rtk_type_c_driver));
+}
+module_init(dwc3_rtk_type_c_driver_init);
+
+static void __exit dwc3_rtk_type_c_driver_exit(void)
+{
+	platform_driver_unregister(&(dwc3_rtk_type_c_driver));
+}
+module_exit(dwc3_rtk_type_c_driver_exit);
+
+MODULE_ALIAS("platform:rtk-dwc3-type_c");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/usb/dwc3/dwc3-rtk.c b/drivers/usb/dwc3/dwc3-rtk.c
new file mode 100644
index 000000000..3d2de02f5
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-rtk.c
@@ -0,0 +1,462 @@
+/**
+ * dwc3-rtk.c - Realtek DWC3 Specific Glue layer
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/usb_phy_generic.h>
+#include <linux/usb/of.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/suspend.h>
+#include <soc/realtek/rtk_chip.h>
+
+#include "../host/xhci.h" //hcy test added
+#include "core.h" //hcy test added
+
+#define WRAP_CTR_reg  0x0
+#define USB2_PHY_reg  0x70
+
+#define EN_PHY_PLL_PORT0 BIT(12)
+#define EN_PHY_PLL_PORT1 BIT(13)
+#define DISABLE_MULTI_REQ BIT(1)
+#define USB2_PHY_SWITCH_MASK 0x707
+#define USB2_PHY_SWITCH_DEVICE 0x0
+#define USB2_PHY_SWITCH_HOST 0x606
+
+struct dwc3_rtk {
+	struct platform_device	*usb2_phy;
+	struct platform_device	*usb3_phy;
+	struct device		*dev;
+
+	void __iomem		*regs;
+	size_t		regs_size;
+
+	struct clk		*clk;
+	struct platform_device *dwc; //hjcy added
+
+	struct work_struct work;
+};
+
+#ifdef CONFIG_RTK_USB3PHY
+extern void rtk_usb3_phy_toggle(struct usb_phy *usb3_phy, bool isConnect,
+	    int port);
+#endif
+
+void RTK_dwc3_usb3_phy_toggle(struct device *hcd_dev, bool isConnect, int port)
+{
+	struct device *dwc3_dev = NULL;
+	struct dwc3 *dwc = NULL;
+	if (hcd_dev == NULL) return;
+
+	dwc3_dev = hcd_dev->parent;
+	if (dwc3_dev == NULL) return;
+
+	dwc = dev_get_drvdata(dwc3_dev);
+#ifdef CONFIG_RTK_USB3PHY
+	dev_dbg(dwc3_dev, "%s port=%d\n", __func__, port);
+	if (dwc != NULL)
+		rtk_usb3_phy_toggle(dwc->usb3_phy, isConnect, port);
+#endif
+}
+
+#ifdef CONFIG_RTK_USB2PHY
+extern void rtk_usb2_phy_toggle(struct usb_phy *usb3_phy, bool isConnect,
+	    int port);
+#endif
+
+int RTK_dwc3_usb2_phy_toggle(struct device *hcd_dev, bool isConnect, int port)
+{
+	struct device *dwc3_dev = NULL;
+	struct dwc3 *dwc = NULL;
+	if (hcd_dev == NULL) return -1;
+
+	dwc3_dev = hcd_dev->parent;
+	if (dwc3_dev == NULL) return -1;
+
+	dwc = dev_get_drvdata(dwc3_dev);
+	if (dwc == NULL) return -1;
+
+#ifdef CONFIG_RTK_USB2PHY
+	dev_dbg(dwc3_dev, "%s port=%d\n", __func__, port);
+	rtk_usb2_phy_toggle(dwc->usb2_phy, isConnect, port);
+#endif
+	return 0;
+}
+
+// CB: This seems to be removed in 5.4
+//static int dwc3_rtk_register_phys(struct dwc3_rtk *rtk)
+//{
+//	struct usb_phy_generic_platform_data pdata;
+//	struct platform_device	*pdev;
+//	int			ret;
+//
+//	memset(&pdata, 0x00, sizeof(pdata));
+//
+//	pdev = platform_device_alloc("usb_phy_generic", PLATFORM_DEVID_AUTO);
+//	if (!pdev)
+//		return -ENOMEM;
+//
+//	rtk->usb2_phy = pdev;
+//	pdata.type = USB_PHY_TYPE_USB2;
+//
+//	ret = platform_device_add_data(rtk->usb2_phy, &pdata, sizeof(pdata));
+//	if (ret)
+//		goto err1;
+//
+//	pdev = platform_device_alloc("usb_phy_generic", PLATFORM_DEVID_AUTO);
+//	if (!pdev) {
+//		ret = -ENOMEM;
+//		goto err1;
+//	}
+//
+//	rtk->usb3_phy = pdev;
+//	pdata.type = USB_PHY_TYPE_USB3;
+//
+//	ret = platform_device_add_data(rtk->usb3_phy, &pdata, sizeof(pdata));
+//	if (ret)
+//		goto err2;
+//
+//	ret = platform_device_add(rtk->usb2_phy);
+//	if (ret)
+//		goto err2;
+//
+//	ret = platform_device_add(rtk->usb3_phy);
+//	if (ret)
+//		goto err3;
+//
+//	return 0;
+//
+//err3:
+//	platform_device_del(rtk->usb2_phy);
+//
+//err2:
+//	platform_device_put(rtk->usb3_phy);
+//
+//err1:
+//	platform_device_put(rtk->usb2_phy);
+//
+//	return ret;
+//}
+
+/*
+static int dwc3_rtk_remove_child(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+*/
+
+static void dwc3_rtk_int_dr_mode(struct dwc3_rtk *rtk, int dr_mode)
+{
+	switch (dr_mode) {
+	case USB_DR_MODE_PERIPHERAL:
+		writel(USB2_PHY_SWITCH_DEVICE |
+			    (~USB2_PHY_SWITCH_MASK & readl(rtk->regs + USB2_PHY_reg)),
+			    rtk->regs + USB2_PHY_reg);
+		break;
+	case USB_DR_MODE_HOST:
+		writel(USB2_PHY_SWITCH_HOST |
+			    (~USB2_PHY_SWITCH_MASK & readl(rtk->regs + USB2_PHY_reg)),
+			    rtk->regs + USB2_PHY_reg);
+		break;
+	case USB_DR_MODE_OTG:
+		//writel(BIT(11) , rtk->regs + USB2_PHY_reg);
+		dev_info(rtk->dev, "%s: USB_DR_MODE_OTG\n", __func__);
+		break;
+	}
+}
+
+static int dwc3_rtk_init(struct dwc3_rtk *rtk)
+{
+	struct device		*dev = rtk->dev;
+	//struct device_node	*node = dev->of_node;
+	void __iomem		*regs = rtk->regs;
+
+	if ((get_rtd_chip_id() == CHIP_ID_RTD1295 ||
+		    get_rtd_chip_id() == CHIP_ID_RTD1296) &&
+		    get_rtd_chip_revision() == RTD_CHIP_A00) {
+		writel(DISABLE_MULTI_REQ | readl(regs + WRAP_CTR_reg),
+				regs + WRAP_CTR_reg);
+		dev_info(dev, "[bug fixed] 1295/1296 A00: add workaround to "
+			    "disable multiple request for D-Bus");
+	}
+
+	if (get_rtd_chip_id() == CHIP_ID_RTD1395) {
+		writel(EN_PHY_PLL_PORT1 | readl(regs + USB2_PHY_reg),
+			    regs + USB2_PHY_reg);
+		dev_info(dev, "[bug fixed] 1395 add workaround to "
+			    "disable usb2 port 2 suspend!");
+
+	}
+	return 0;
+}
+
+extern void rtk_usb_init_gpio_power_on(struct device *dev);
+extern int rtk_usb_manager_schedule_work(struct device *usb_dev, struct work_struct *work);
+
+static int dwc3_rtk_probe_dwc3core(struct dwc3_rtk *rtk)
+{
+	struct device		*dev = rtk->dev;
+	struct device_node	*node = dev->of_node;
+	struct device_node	*next_node;
+	int    ret = 0;
+
+	dwc3_rtk_init(rtk);
+
+	if (node) {
+		ret = of_platform_populate(node, NULL, NULL, dev);
+		if (ret) {
+			dev_err(dev, "failed to add dwc3 core\n");
+			return ret;
+		}
+		/* hcy adde below */
+		//node =  of_find_compatible_node(NULL, NULL, "synopsys,dwc3");
+		next_node = of_get_next_child(node, NULL);
+		if (next_node != NULL) {
+			struct device *next_dev;
+			int dr_mode;
+
+			rtk->dwc = of_find_device_by_node(next_node);
+			next_dev = &(rtk->dwc)->dev;
+			dr_mode = usb_get_dr_mode(next_dev);
+			dwc3_rtk_int_dr_mode(rtk, dr_mode);
+		}
+	}
+
+	rtk_usb_init_gpio_power_on(dev);
+
+	return ret;
+}
+
+static void dwc3_rtk_probe_work(struct work_struct *work)
+{
+	struct dwc3_rtk *rtk = container_of(work, struct dwc3_rtk, work);
+	struct device		*dev = rtk->dev;
+	int    ret = 0;
+
+	unsigned long probe_time = jiffies;
+
+	dev_info(dev, "%s Start ...\n", __func__);
+
+	ret = dwc3_rtk_probe_dwc3core(rtk);
+
+	if (ret)
+		dev_err(dev, "%s failed to add dwc3 core\n", __func__);
+
+	dev_info(dev, "%s End ... ok! (take %d ms)\n", __func__,
+		    jiffies_to_msecs(jiffies - probe_time));
+}
+
+static int dwc3_rtk_probe(struct platform_device *pdev)
+{
+	struct dwc3_rtk	*rtk;
+//	struct clk		*clk;
+	struct device		*dev = &pdev->dev;
+	struct device_node	*node = dev->of_node;
+
+	struct resource         *res;
+	void __iomem            *regs;
+
+	int			ret = -ENOMEM;
+	unsigned long probe_time = jiffies;
+
+	dev_info(&pdev->dev, "Probe Realtek-SoC USB DWC3 Host Controller\n");
+
+	rtk = devm_kzalloc(dev, sizeof(*rtk), GFP_KERNEL);
+	if (!rtk) {
+		dev_err(dev, "not enough memory\n");
+		goto err1;
+	}
+
+	/*
+	 * Right now device-tree probed devices don't get dma_mask set.
+	 * Since shared usb code relies on it, set it here for now.
+	 * Once we move to full device tree support this will vanish off.
+	 */
+	if (!dev->dma_mask)
+		dev->dma_mask = &dev->coherent_dma_mask;
+	if (!dev->coherent_dma_mask)
+		dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	platform_set_drvdata(pdev, rtk);
+
+//	ret = dwc3_rtk_register_phys(rtk);
+//	if (ret) {
+//		dev_err(dev, "couldn't register PHYs\n");
+//		goto err1;
+//	}
+
+	rtk->dev	= dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "missing memory resource\n");
+		return -ENODEV;
+	}
+
+	regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(regs)) {
+		ret = PTR_ERR(regs);
+		goto err1;
+	}
+
+	rtk->regs = regs;
+	rtk->regs_size = resource_size(res);
+
+	if (node) {
+		if (of_property_read_bool(node, "delay_probe_work")) {
+			INIT_WORK(&rtk->work, dwc3_rtk_probe_work);
+			if (of_property_read_bool(node, "ordered_probe"))
+				rtk_usb_manager_schedule_work(dev, &rtk->work);
+			else
+				schedule_work(&rtk->work);
+		} else {
+			ret = dwc3_rtk_probe_dwc3core(rtk);
+			if (ret) {
+				dev_err(dev, "%s failed to add dwc3 core\n", __func__);
+				goto err2;
+			}
+		}
+	} else {
+		dev_err(dev, "no device node, failed to add dwc3 core\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+	dev_info(dev, "dwc3_rtk_probe ok! (take %d ms)\n",
+		    jiffies_to_msecs(jiffies - probe_time));
+
+	return 0;
+
+err2:
+err1:
+	return ret;
+}
+
+static int dwc3_rtk_remove(struct platform_device *pdev)
+{
+	struct dwc3_rtk	*rtk = platform_get_drvdata(pdev);
+
+	of_platform_depopulate(rtk->dev);
+	//device_for_each_child(&pdev->dev, NULL, dwc3_rtk_remove_child);
+	platform_device_unregister(rtk->usb2_phy);
+	platform_device_unregister(rtk->usb3_phy);
+
+	clk_disable_unprepare(rtk->clk);
+
+	return 0;
+}
+
+static void dwc3_rtk_shutdown(struct platform_device *pdev)
+{
+	struct dwc3_rtk	*rtk = platform_get_drvdata(pdev);
+	struct device		*dev = &pdev->dev;
+
+	dev_info(dev, "dwc3_rtk_shutdown start ...\n");
+
+	of_platform_depopulate(rtk->dev);
+	//device_for_each_child(&pdev->dev, NULL, dwc3_rtk_remove_child);
+	platform_device_unregister(rtk->usb2_phy);
+	platform_device_unregister(rtk->usb3_phy);
+
+	clk_disable_unprepare(rtk->clk);
+	dev_info(dev, "dwc3_rtk_shutdown ok!\n");
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id rtk_dwc3_match[] = {
+	{ .compatible = "Realtek,dwc3" },
+	{ .compatible = "Realtek,rtk119x-dwc3" },
+	{ .compatible = "Realtek,rtd129x-dwc3-drd" },
+	{ .compatible = "Realtek,rtd129x-dwc3-u2h" },
+	{ .compatible = "Realtek,rtd129x-dwc3-u3h" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_dwc3_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int dwc3_rtk_suspend(struct device *dev)
+{
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	//For suspend mode
+	dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return 0;
+}
+
+static int dwc3_rtk_resume(struct device *dev)
+{
+	struct dwc3_rtk *rtk = dev_get_drvdata(dev);
+	struct dwc3 *dwc = platform_get_drvdata(rtk->dwc);
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	//For suspend mode
+	dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+
+	dwc3_rtk_init(rtk);
+
+	dwc3_rtk_int_dr_mode(rtk, dwc->dr_mode);
+
+	/* runtime set active to reflect active state. */
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops dwc3_rtk_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc3_rtk_suspend, dwc3_rtk_resume)
+};
+
+#define DEV_PM_OPS	(&dwc3_rtk_dev_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static struct platform_driver dwc3_rtk_driver = {
+	.probe		= dwc3_rtk_probe,
+	.remove		= dwc3_rtk_remove,
+	.driver		= {
+		.name	= "rtk-dwc3",
+		.of_match_table = of_match_ptr(rtk_dwc3_match),
+		.pm	= DEV_PM_OPS,
+	},
+	.shutdown 	= dwc3_rtk_shutdown,
+};
+
+module_platform_driver(dwc3_rtk_driver);
+
+MODULE_ALIAS("platform:rtk-dwc3");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 65ff41e3a..07699d98b 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -19,6 +19,10 @@
 #include <linux/list.h>
 #include <linux/dma-mapping.h>
 
+#ifdef CONFIG_USB_DWC3_RTK
+#include <linux/of_device.h>
+#endif
+
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
@@ -2243,6 +2247,10 @@ static void dwc3_gadget_setup_nump(struct dwc3 *dwc)
 	u32 nump;
 	u32 reg;
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_dbg(dwc->dev, "%s Enter \n", __func__);
+#endif
+
 	ram2_depth = DWC3_GHWPARAMS7_RAM2_DEPTH(dwc->hwparams.hwparams7);
 	mdwidth = DWC3_GHWPARAMS0_MDWIDTH(dwc->hwparams.hwparams0);
 	if (DWC3_IP_IS(DWC32))
@@ -2316,6 +2324,10 @@ static int __dwc3_gadget_start(struct dwc3 *dwc)
 
 	dwc3_gadget_enable_irq(dwc);
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_dbg(dwc->dev, "%s Exit\n", __func__);
+#endif
+
 	return 0;
 
 err1:
@@ -2352,6 +2364,9 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 	}
 
 	dwc->gadget_driver	= driver;
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dwc->link_state = 0;
+#endif
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	return 0;
@@ -2378,6 +2393,9 @@ static int dwc3_gadget_stop(struct usb_gadget *g)
 
 	spin_lock_irqsave(&dwc->lock, flags);
 	dwc->gadget_driver	= NULL;
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	dwc->link_state = 0;
+#endif
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	free_irq(dwc->irq_gadget, dwc->ev_buf);
@@ -3734,14 +3752,22 @@ static irqreturn_t dwc3_check_event_buf(struct dwc3_event_buffer *evt)
 	 * irq event handler completes before caching new event to prevent
 	 * losing events.
 	 */
+#ifndef CONFIG_USB_PATCH_ON_RTK
 	if (evt->flags & DWC3_EVENT_PENDING)
 		return IRQ_HANDLED;
+#endif
 
 	count = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(0));
 	count &= DWC3_GEVNTCOUNT_MASK;
 	if (!count)
 		return IRQ_NONE;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (evt->flags & DWC3_EVENT_PENDING) {
+		return IRQ_NONE;
+	}
+#endif
+
 	evt->count = count;
 	evt->flags |= DWC3_EVENT_PENDING;
 
@@ -3817,6 +3843,11 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	int irq;
 	struct device *dev;
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	if (dwc->has_gadget) return 0;
+	dev_info(dwc->dev, "%s Enter\n", __func__);
+#endif
+
 	irq = dwc3_gadget_get_irq(dwc);
 	if (irq < 0) {
 		ret = irq;
@@ -3904,6 +3935,10 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 
 	dwc3_gadget_set_speed(dwc->gadget, dwc->maximum_speed);
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dwc->has_gadget = true;
+	dev_info(dwc->dev, "%s Exit\n", __func__);
+#endif
 	return 0;
 
 err5:
@@ -3929,6 +3964,13 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 
 void dwc3_gadget_exit(struct dwc3 *dwc)
 {
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	if (!dwc->has_gadget) return;
+
+	dev_info(dwc->dev, "%s Enter\n", __func__);
+	dwc->has_gadget = false;
+#endif
+
 	usb_del_gadget_udc(dwc->gadget);
 	dwc3_gadget_free_endpoints(dwc);
 	dma_free_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE, dwc->bounce,
@@ -3936,10 +3978,26 @@ void dwc3_gadget_exit(struct dwc3 *dwc)
 	kfree(dwc->setup_buf);
 	dma_free_coherent(dwc->sysdev, sizeof(*dwc->ep0_trb) * 2,
 			  dwc->ep0_trb, dwc->ep0_trb_addr);
+
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	memset(&dwc->gadget, 0x00, sizeof(dwc->gadget));
+
+	dev_info(dwc->dev, "%s Exit\n", __func__);
+#endif
 }
 
 int dwc3_gadget_suspend(struct dwc3 *dwc)
 {
+	int ret;
+
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_info(dwc->dev, "[USB] Enter %s", __func__);
+	if (!dwc->has_gadget) {
+		dev_info(dwc->dev, "[USB] Exit %s (by no gadget)", __func__);
+		return 0;
+	}
+#endif
+
 	if (!dwc->gadget_driver)
 		return 0;
 
@@ -3947,6 +4005,9 @@ int dwc3_gadget_suspend(struct dwc3 *dwc)
 	dwc3_disconnect_gadget(dwc);
 	__dwc3_gadget_stop(dwc);
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_info(dwc->dev, "[USB] Exit %s", __func__);
+#endif
 	return 0;
 }
 
@@ -3957,6 +4018,14 @@ int dwc3_gadget_resume(struct dwc3 *dwc)
 	if (!dwc->gadget_driver)
 		return 0;
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_info(dwc->dev, "[USB] Enter %s", __func__);
+	if (!dwc->has_gadget) {
+		dev_info(dwc->dev, "[USB] Exit %s (by no gadget)", __func__);
+		return 0;
+	}
+#endif
+
 	ret = __dwc3_gadget_start(dwc);
 	if (ret < 0)
 		goto err0;
@@ -3965,6 +4034,10 @@ int dwc3_gadget_resume(struct dwc3 *dwc)
 	if (ret < 0)
 		goto err1;
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_info(dwc->dev, "[USB] Exit %s", __func__);
+#endif
+
 	return 0;
 
 err1:
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index e19517658..567aa70cb 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -10,6 +10,10 @@
 #include <linux/acpi.h>
 #include <linux/platform_device.h>
 
+#ifdef CONFIG_USB_DWC3_RTK
+#include <linux/of_device.h>
+#endif
+
 #include "core.h"
 
 static int dwc3_host_get_irq(struct dwc3 *dwc)
@@ -69,6 +73,10 @@ int dwc3_host_init(struct dwc3 *dwc)
 	dwc->xhci_resources[1].flags = res->flags;
 	dwc->xhci_resources[1].name = res->name;
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dev_info(dwc->dev, "%s\n", __func__);
+#endif
+
 	xhci = platform_device_alloc("xhci-hcd", PLATFORM_DEVID_AUTO);
 	if (!xhci) {
 		dev_err(dwc->dev, "couldn't allocate xHCI device\n");
@@ -79,6 +87,9 @@ int dwc3_host_init(struct dwc3 *dwc)
 	ACPI_COMPANION_SET(&xhci->dev, ACPI_COMPANION(dwc->dev));
 
 	dwc->xhci = xhci;
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dwc->has_xhci = true;
+#endif
 
 	ret = platform_device_add_resources(xhci, dwc->xhci_resources,
 						DWC3_XHCI_RESOURCES_NUM);
@@ -129,5 +140,8 @@ int dwc3_host_init(struct dwc3 *dwc)
 
 void dwc3_host_exit(struct dwc3 *dwc)
 {
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	dwc->has_xhci = false;
+#endif
 	platform_device_unregister(dwc->xhci);
 }
diff --git a/drivers/usb/dwc3/io.h b/drivers/usb/dwc3/io.h
index 76b73b116..f76471a45 100644
--- a/drivers/usb/dwc3/io.h
+++ b/drivers/usb/dwc3/io.h
@@ -16,10 +16,21 @@
 #include "debug.h"
 #include "core.h"
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* Add global lock for emmc issue*/
+#include <soc/realtek/rtd129x_lockapi.h>
+#endif
+
 static inline u32 dwc3_readl(void __iomem *base, u32 offset)
 {
 	u32 value;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add global lock for emmc issue*/
+	unsigned long flags;
+	rtk_lockapi_lock(flags, __FUNCTION__);
+#endif
+
 	/*
 	 * We requested the mem region starting from the Globals address
 	 * space, see dwc3_probe in core.c.
@@ -27,6 +38,11 @@ static inline u32 dwc3_readl(void __iomem *base, u32 offset)
 	 */
 	value = readl(base + offset - DWC3_GLOBALS_REGS_START);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add global lock for emmc issue*/
+	rtk_lockapi_unlock(flags,__FUNCTION__);
+#endif
+
 	/*
 	 * When tracing we want to make it easy to find the correct address on
 	 * documentation, so we revert it back to the proper addresses, the
@@ -39,6 +55,11 @@ static inline u32 dwc3_readl(void __iomem *base, u32 offset)
 
 static inline void dwc3_writel(void __iomem *base, u32 offset, u32 value)
 {
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	unsigned long flags;
+	rtk_lockapi_lock(flags, __FUNCTION__);
+#endif
+
 	/*
 	 * We requested the mem region starting from the Globals address
 	 * space, see dwc3_probe in core.c.
@@ -46,6 +67,10 @@ static inline void dwc3_writel(void __iomem *base, u32 offset, u32 value)
 	 */
 	writel(value, base + offset - DWC3_GLOBALS_REGS_START);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	rtk_lockapi_unlock(flags,__FUNCTION__);
+#endif
+
 	/*
 	 * When tracing we want to make it easy to find the correct address on
 	 * documentation, so we revert it back to the proper addresses, the
diff --git a/drivers/usb/dwc3/rtk-rts5400.c b/drivers/usb/dwc3/rtk-rts5400.c
new file mode 100644
index 000000000..f6db46a31
--- /dev/null
+++ b/drivers/usb/dwc3/rtk-rts5400.c
@@ -0,0 +1,735 @@
+/**
+ * rtk-rts5400.c - Realtek RTS5400 Type C driver
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <linux/suspend.h>
+
+#define RTS5400_MAX_WRITE_DATA_LEN 32
+
+static struct tcpm_command {
+	u8 cmd;
+	u8 wr_data_len;
+	u8 data[RTS5400_MAX_WRITE_DATA_LEN];
+} __packed;
+
+#define PING_STATUS_CMD_STATUS(n) (n & 0x3)
+#define PING_STATUS_DATA_LEN(n) ((n & 0xFC) >> 2)
+
+static struct tcpm_command_status {
+	u8 cmd_status:2;
+#define PING_STATUS_IN_PORCESS 	0x0
+#define PING_STATUS_COMPLETE 	0x1
+#define PING_STATUS_DEFERRED 	0x2
+#define PING_STATUS_ERROR 		0x3
+	u8 data_len:6;
+} __packed;
+
+static struct pd_ic_status {
+	u8 reservrd1;
+	u8 reservrd2;
+	u8 reservrd3;
+	u8 main_ver;
+	u8 sub_ver;
+	u8 sub_ver2;
+	u8 reservrd4;
+	u8 reservrd5;
+	u8 pd_tc;
+#define IC_STATUS_PD_READY(n) (n & 0x1)
+#define IC_STATUS_TC_CONNECT(n) ((n >> 3) & 0x1)
+	uint32_t reservrd6;
+	u8 sm_ready;
+#define IC_STATUS_SMB_READY(n) (n & 0x1)
+	u8 reservrd7;
+	u8 reservrd8;
+	uint32_t reservrd9;
+} __packed;
+
+static struct pd_status_change {//TODO
+	uint32_t reservrd;
+} __packed;
+
+static struct pd_status_info {
+	struct pd_status_change status_change; /* bit 0-31 */
+	u8 supply:1;
+#define PD_STATUS_INFO_NO_SUPPULY 		0x0
+#define PD_STATUS_INFO_SUPPULY 			0x1
+	u8 port_op_mode:3;
+#define PD_STATUS_INFO_NO_CONSUMER 		0x0
+#define PD_STATUS_INFO_USB_DEFAULT 		0x1
+#define PD_STATUS_INFO_BC 			0x2
+#define PD_STATUS_INFO_PD 			0x3
+#define PD_STATUS_INFO_USB_1_5A 		0x4
+#define PD_STATUS_INFO_USB_3_0A 		0x5
+	u8 insertion_detect:1;
+#define PD_STATUS_INFO_NO_CABLE 		0x0
+#define PD_STATUS_INFO_CABLE_DETECT		0x1
+	u8 pd_capable_cable:1;
+#define PD_STATUS_INFO_NO_PD_CABLE 		0x0
+#define PD_STATUS_INFO_PD_CABLE 		0x1
+	u8 power_direction:1;
+#define PD_STATUS_INFO_CONSUMER 		0x0
+#define PD_STATUS_INFO_PROVIDER 		0x1
+	u8 connect_status:1;
+#define PD_STATUS_INFO_UNATTACHED 		0x0
+#define PD_STATUS_INFO_ATTACHED 		0x1
+	u8 port_partner_flag:8;				/* bit 40-47 */
+#define PD_STATUS_INFO_PARTNER_USB 		0x0
+#define PD_STATUS_INFO_PARTNER_ALT 		0x1
+	uint32_t  request_data_obj:32;			/* bit 48-79 */
+	u8 port_partner_type:3;				/* bit 80-82 */
+#define PD_STATUS_INFO_PARTNER_DFP 		0x1
+#define PD_STATUS_INFO_PARTNER_UFP 		0x2
+#define PD_STATUS_INFO_PARTNER_PC 		0x3
+#define PD_STATUS_INFO_PARTNER_PC_UFP		0x4
+#define PD_STATUS_INFO_PARTNER_DA 		0x5
+#define PD_STATUS_INFO_PARTNER_AAA 		0x6
+	u8 battery_charging_status:2;
+	u8 pd_sourcing_Vconn:1;
+	u8 pd_responsible_for_Vconn:1;
+	u8 pd_ams:1;
+	u8 last_ams:4;					/* bit 88-91 */
+	u8 port_partner_not_support_pd:1;
+	u8 plug_direction:1;
+	u8 dp_role:1;
+#define PD_STATUS_INFO_DP_SINK 			0x0
+#define PD_STATUS_INFO_DP_SOURCE 		0x1
+	u8 pd_connect:1;
+#define PD_STATUS_INFO_PD_NOT_EXCHANGE		0x0
+#define PD_STATUS_INFO_PD_EXCHANGE 		0x1
+	u8 reservrd1:8;
+	u8 alt_mode_status:3;
+	u8 reservrd2:5;
+} __packed;
+
+#define PDO_TYPE(n) (n&0x1)
+#define PDO_TYPE_SINK 0x0
+#define PDO_TYPE_SOURCE 0x1
+#define PDO_TCPM(n) ((n&0x1) << 1)
+#define PDO_TCPM_TCPM 0x0
+#define PDO_TCPM_PARTNER 0x1
+#define PDO_OFFEST(n) ((n&0x7) << 2)
+#define PDO_NUM(n) ((n&0x7) << 5)
+
+static struct source_fix_pdo {
+	u16 max_current:10;
+	u16 valtage:10;
+	u8 peak_current:2;
+	u8 reservrd:3;
+	u8 data_role_swap:1;
+	u8 usb_comm_capable:1;
+	u8 external_power:1;
+	u8 usb_suspend:1;
+	u8 dual_role_power:1;
+	u8 power_type:2;
+} __packed;
+
+static struct source_var_pdo {
+	u16 max_current:10;
+	u16 min_valtage:10;
+	u16 max_valtage:10;
+	u8 power_type:2;
+} __packed;
+
+static struct source_bat_pdo {
+	u16 max_current:10;
+	u16 min_valtage:10;
+	u16 max_valtage:10;
+	u8 power_type:2;
+} __packed;
+
+static struct sink_fix_pdo {
+	u16 op_current:10;
+	u16 valtage:10;
+	u8 peak_current:2;
+	u8 reservrd:3;
+	u8 data_role_swap:1;
+	u8 usb_comm_capable:1;
+	u8 external_power:1;
+	u8 higher_capability:1;
+	u8 dual_role_power:1;
+	u8 power_type:2;
+} __packed;
+
+static struct sink_var_pdo {
+	u16 op_current:10;
+	u16 min_valtage:10;
+	u16 max_valtage:10;
+	u8 power_type:2;
+} __packed;
+
+static struct sink_bat_pdo {
+	u16 op_current:10;
+	u16 min_valtage:10;
+	u16 max_valtage:10;
+	u8 power_type:2;
+} __packed;
+
+static struct common_pdo {
+	uint32_t reservrd:30;
+	u8 power_type:2;
+#define PDO_INFO_POWER_TYPE_FIX 0x0
+#define PDO_INFO_POWER_TYPE_BAT 0x1
+#define PDO_INFO_POWER_TYPE_VAR 0x2
+} __packed;
+
+union pdo_info {
+	struct source_fix_pdo so_f;
+	struct source_var_pdo so_v;
+	struct source_bat_pdo so_b;
+	struct sink_fix_pdo si_f;
+	struct sink_var_pdo si_v;
+	struct sink_bat_pdo si_b;
+	struct common_pdo com;
+};
+
+static struct rdo_info_struct {
+	uint32_t reservrd_todo:28; //TODO
+	uint32_t obj_pos:3;
+	uint32_t reservrd:1;
+} __packed;
+
+union rdo_info {
+	struct rdo_info_struct	info;
+	unsigned int		set;
+};
+
+#define PD_AMS_PR_SWAP 		0x01
+#define PD_AMS_DR_SWAP 		0x02
+#define PD_AMS_VCONN_SWAP 	0x03
+#define PD_AMS_SOURCE_CAP 	0x04
+#define PD_AMS_REQUEST 		0x05
+#define PD_AMS_SOFT_RESET 	0x06
+#define PD_AMS_HARD_RESET 	0x07
+#define PD_AMS_GOTO_MIN 	0x08
+#define PD_AMS_GET_SNK_CAP 	0x09
+#define PD_AMS_GET_SRC_CAP 	0x0A
+
+static struct rts5400_dev {
+	struct i2c_client *client;
+	struct device *dev;
+	bool no_device;
+
+	struct pd_ic_status ic_status;
+	struct pd_status_info status_info;
+
+	unsigned int pow_gpio;
+} g_rts5400;
+
+/* I2C transfer */
+static struct tcpm_command_status __rts5400_get_ping_status(
+		const struct i2c_client *client)
+{
+	int ret;
+	struct tcpm_command_status status;
+	status.cmd_status = 0;
+	status.data_len = 0;
+
+	ret = i2c_smbus_read_byte(client);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s get error %d\n", __func__, ret);
+		return status;
+	}
+	status.cmd_status = PING_STATUS_CMD_STATUS(ret);
+	status.data_len = PING_STATUS_DATA_LEN(ret);
+	return status;
+}
+
+static int __rts5400_block_read(const struct i2c_client *client,
+		struct tcpm_command *command)
+{
+	int ret;
+	int data_len = command->wr_data_len + 1;
+	u8 *buffer;
+
+	buffer = kzalloc(data_len, GFP_KERNEL);
+
+	ret = i2c_smbus_read_i2c_block_data(client, command->cmd,
+			data_len, buffer);
+
+	if (ret < 0)
+		dev_err(&client->dev, "block read failed\n");
+	else {
+		memcpy(&command->data, buffer + 1, command->wr_data_len);
+		ret = buffer[0];
+	}
+
+	kfree(buffer);
+
+	return ret;
+}
+
+static int __rts5400_block_write(struct i2c_client *client,
+		struct tcpm_command *command)
+{
+	int ret;
+
+	ret = i2c_smbus_write_block_data(client, command->cmd,
+			command->wr_data_len, (const u8 *) &command->data);
+	return ret;
+}
+
+static int __rts5400_transfer(const struct rts5400_dev *rts5400,
+		struct tcpm_command *w_cmd, struct tcpm_command *r_cmd)
+{
+	struct device *dev = rts5400->dev;
+	struct i2c_client *client = rts5400->client;
+	struct tcpm_command_status status;
+	int retry = 100;
+	int ret = -ENODEV;
+
+	if (rts5400->no_device) {
+		dev_dbg(dev, "%s Error! NO rts5400\n", __func__);
+		return ret;
+	}
+	dev_dbg(dev, "%s start write command 0x%x,wr_data_len %d, sub_command 0x%x\n",
+			__func__, w_cmd->cmd, w_cmd->wr_data_len, w_cmd->data[0]);
+
+	ret = __rts5400_block_write(client, w_cmd);
+
+	if (ret < 0) {
+		dev_err(dev, "%s block write error %d", __func__, ret);
+		return ret;
+	}
+
+	while (--retry) {
+		mdelay(1);
+		status = __rts5400_get_ping_status(client);
+		if (status.cmd_status == PING_STATUS_COMPLETE) {
+			break;
+		} else if (status.cmd_status == PING_STATUS_ERROR) {
+			dev_err(dev, "%s get ping status error %d\n", __func__, status.cmd_status);
+			break;
+		}
+	}
+	if (!retry) {
+		dev_err(dev, "%s get ping status TIMEOUT\n", __func__);
+		return -ETIMEDOUT;
+	} else
+		dev_dbg(dev, "%s get ping status 0x%x, data_len %d\n",
+				__func__, status.cmd_status, status.data_len);
+
+	if (r_cmd->wr_data_len == 0xff)
+		r_cmd->wr_data_len = status.data_len;
+
+	if (r_cmd->wr_data_len > 0) {
+		dev_dbg(dev, "%s start read command 0x%x,wr_data_len %d\n",
+			__func__, r_cmd->cmd, r_cmd->wr_data_len);
+
+		ret = __rts5400_block_read(client, r_cmd);
+		if (ret < 0)
+			dev_err(dev, "%s block read error %d\n", __func__, ret);
+	}
+	if (status.cmd_status == PING_STATUS_ERROR)
+		return -3;
+	else
+		return ret;
+}
+
+int rtk_rts5400_get_IC_status(void)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	int ret, i;
+	struct tcpm_command w_cmd, r_cmd;
+	struct pd_ic_status *ic_status = &rts5400->ic_status;
+
+	w_cmd.cmd = 0x3A;
+	w_cmd.wr_data_len = 0x1;
+	w_cmd.data[0] = 0x14;
+	r_cmd.cmd = 0x80;
+	r_cmd.wr_data_len = 0x14;
+	memset(&r_cmd.data, 0, RTS5400_MAX_WRITE_DATA_LEN);
+
+	dev_dbg(rts5400->dev, "Enter %s\n", __func__);
+
+	ret = __rts5400_transfer(rts5400, &w_cmd, &r_cmd);
+
+	if (ret < 0) {
+		dev_err(rts5400->dev, "%s I2C transfer fails\n", __func__);
+		return ret;
+	}
+
+	//for (i = 0; i < r_cmd.wr_data_len; i++) {
+	//	dev_dbg(rts5400->dev, "Data#%d : 0x%x\n", i, r_cmd.data[i]);
+	//}
+	memcpy(ic_status, &r_cmd.data, r_cmd.wr_data_len);
+
+	dev_info(rts5400->dev, "RTS5400 Main_version %d Sub_version %d Sub_version_2 %d\n",
+			ic_status->main_ver, ic_status->sub_ver, ic_status->sub_ver2);
+
+	dev_info(rts5400->dev, "SMBus %sready, PD %sready, TypeC %sconnect\n",
+			IC_STATUS_SMB_READY(ic_status->sm_ready)?"":"NOT ",
+			IC_STATUS_PD_READY(ic_status->pd_tc)?"":"NOT ",
+			IC_STATUS_TC_CONNECT(ic_status->pd_tc)?"":"NOT ");
+
+	dev_dbg(rts5400->dev, "Exit %s return cmd %x, wr_data_len %d\n", __func__,
+			r_cmd.cmd, r_cmd.wr_data_len);
+
+	ret = IC_STATUS_SMB_READY(ic_status->sm_ready)
+			& IC_STATUS_PD_READY(ic_status->pd_tc)
+			& IC_STATUS_TC_CONNECT(ic_status->pd_tc);
+
+	return ret;
+}
+
+int rtk_rts5400_get_status(void)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	int ret, i;
+	struct tcpm_command w_cmd, r_cmd;
+	struct pd_status_info *status_info = &rts5400->status_info;
+
+	w_cmd.cmd = 0x9;
+	w_cmd.wr_data_len = 0x3;
+	w_cmd.data[0] = 0x0;
+	w_cmd.data[1] = 0;
+	w_cmd.data[2] = 0x0D;
+	r_cmd.cmd = 0x80;
+	r_cmd.wr_data_len = 0xff;
+	memset(&r_cmd.data, 0, RTS5400_MAX_WRITE_DATA_LEN);
+
+	dev_dbg(rts5400->dev, "Enter %s\n", __func__);
+
+	ret = __rts5400_transfer(rts5400, &w_cmd, &r_cmd);
+
+	if (ret < 0) {
+		dev_err(rts5400->dev, "%s I2C transfer fails\n", __func__);
+		return ret;
+	}
+
+	//for (i = 0; i < r_cmd.wr_data_len; i++) {
+	//	dev_dbg(rts5400->dev, "Data#%d : 0x%x\n", i, r_cmd.data[i]);
+	//}
+
+	memcpy(status_info, &r_cmd.data, r_cmd.wr_data_len);
+
+	dev_info(rts5400->dev, "[Status Info] Externally Powered supply %d, Port OP mode %d, Insertion Detect %d\n",
+			status_info->supply, status_info->port_op_mode, status_info->insertion_detect);
+	dev_info(rts5400->dev, "[Status Info] PD Capable Cable %d, Power Direction %d\n",
+			status_info->pd_capable_cable, status_info->power_direction);
+	dev_info(rts5400->dev, "[Status Info] Connect Status %d, Port Partner Flags %d\n",
+			status_info->connect_status, status_info->port_partner_flag);
+	dev_info(rts5400->dev, "[Status Info] Request Data Object 0x%x\n", status_info->request_data_obj);
+	dev_info(rts5400->dev, "[Status Info] Port Partner Type %d\n", status_info->port_partner_type);
+	dev_info(rts5400->dev, "[Status Info] Battery Charging Status %d\n", status_info->battery_charging_status);
+	dev_info(rts5400->dev, "[Status Info] PD Sourcing Vconn %d\n", status_info->pd_sourcing_Vconn);
+	dev_info(rts5400->dev, "[Status Info] PD AMS is %s\n", status_info->pd_ams?"in progress":"ready");
+	dev_info(rts5400->dev, "[Status Info] DP Role: %s\n", status_info->dp_role?"Sink":"Source");
+	dev_info(rts5400->dev, "[Status Info] PD %sexchanged pd message and goodcrc\n", status_info->pd_connect?"":"NOT ");
+	dev_info(rts5400->dev, "[Status Info] Alt mode status 0x%x\n", status_info->alt_mode_status);
+
+	dev_dbg(rts5400->dev, "Exit %s return cmd %x, wr_data_len %d\n", __func__,
+			r_cmd.cmd, r_cmd.wr_data_len);
+
+	return ret;
+}
+
+int rtk_rts5400_get_PDO(int pdo_type, int pdo, int offset,
+		int num, union pdo_info *dat_buf)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	int ret, i;
+	struct tcpm_command w_cmd, r_cmd;
+	union pdo_info *pdo_inf;
+
+	w_cmd.cmd = 0x8;
+	w_cmd.wr_data_len = 0x3;
+	w_cmd.data[0] = 0x83;
+	w_cmd.data[1] = 0;
+	w_cmd.data[2] = PDO_TYPE(pdo_type) | PDO_TCPM(pdo) | PDO_OFFEST(offset) | PDO_NUM(num);
+	r_cmd.cmd = 0x80;
+	r_cmd.wr_data_len = 0xff;
+	memset(&r_cmd.data, 0, RTS5400_MAX_WRITE_DATA_LEN);
+
+	dev_dbg(rts5400->dev, "Enter %s\n", __func__);
+
+	ret = __rts5400_transfer(rts5400, &w_cmd, &r_cmd);
+
+	if (ret < 0) {
+		dev_err(rts5400->dev, "%s I2C transfer fails\n", __func__);
+		return ret;
+	}
+
+	dev_dbg(rts5400->dev, "[PDO status] %s %s PDO, offset %d, num %d\n",
+			pdo?"Partner":"TCPM", pdo_type?"Source":"Sink", offset, num);
+
+	//for (i = 0; i < r_cmd.wr_data_len; i++) {
+	//	dev_dbg(rts5400->dev, "Data#%d : 0x%x\n", i, r_cmd.data[i]);
+	//}
+
+	for (i = 0; i < r_cmd.wr_data_len; i = i + 4) {
+		pdo_inf = (union pdo_info *)&r_cmd.data[i];
+
+		if (pdo == PDO_TYPE_SOURCE && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_FIX) {
+			dev_info(rts5400->dev, "[PDO status] %s Fix PDO, valtage %d mV\n",
+				pdo_type?"Source":"Sink", (pdo_inf->so_f.valtage) * 50);
+		} else if (pdo == PDO_TYPE_SOURCE && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_VAR) {
+			dev_info(rts5400->dev, "[PDO status] %s Var PDO\n", pdo_type?"Source":"Sink");
+		} else if (pdo == PDO_TYPE_SOURCE && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_BAT) {
+			dev_info(rts5400->dev, "[PDO status] %s Bat PDO\n", pdo_type?"Source":"Sink");
+		} else if (pdo == PDO_TYPE_SINK && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_FIX) {
+			dev_info(rts5400->dev, "[PDO status] %s Fix PDO, valtage %d mV\n",
+				pdo_type?"Source":"Sink", (pdo_inf->si_f.valtage) * 50);
+		} else if (pdo == PDO_TYPE_SINK && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_VAR) {
+			dev_info(rts5400->dev, "[PDO status] %s Var PDO\n", pdo_type?"Source":"Sink");
+		} else if (pdo == PDO_TYPE_SINK && pdo_inf->com.power_type == PDO_INFO_POWER_TYPE_BAT) {
+			dev_info(rts5400->dev, "[PDO status] %s Var PDO\n", pdo_type?"Source":"Sink");
+		}
+	}
+	dev_dbg(rts5400->dev, "Exit %s return cmd %x, wr_data_len %d\n", __func__,
+			r_cmd.cmd, r_cmd.wr_data_len);
+
+	if (ret > 0) {
+		if (dat_buf != NULL) {
+			memcpy(dat_buf, &r_cmd.data, r_cmd.wr_data_len);
+		}
+		return r_cmd.wr_data_len;
+	}
+	return ret;
+}
+
+int rtk_rts5400_init_pd_ams(u8 pd_ams)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	int ret, i;
+	struct tcpm_command w_cmd, r_cmd;
+
+	w_cmd.cmd = 0x8;
+	w_cmd.wr_data_len = 0x3;
+	w_cmd.data[0] = 0x20;
+	w_cmd.data[1] = 0;
+	w_cmd.data[2] = pd_ams;
+	r_cmd.cmd = 0x80;
+	r_cmd.wr_data_len = 0x0;
+	memset(&r_cmd.data, 0, RTS5400_MAX_WRITE_DATA_LEN);
+
+	dev_dbg(rts5400->dev, "Enter %s pd_ams=%x\n", __func__, pd_ams);
+
+	ret = __rts5400_transfer(rts5400, &w_cmd, &r_cmd);
+
+	if (ret < 0) {
+		dev_err(rts5400->dev, "%s I2C transfer fails\n", __func__);
+		return ret;
+	}
+
+	dev_dbg(rts5400->dev, "Exit %s\n", __func__);
+
+	return ret;
+}
+
+/* Type C */
+bool rtk_rts5400_is_enabled(void)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	struct device *dev = rts5400->dev;
+
+	return !rts5400->no_device;
+}
+
+bool rtk_rts5400_is_UFP_attached(void)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	struct device *dev = rts5400->dev;
+	struct pd_status_info *status_info = &rts5400->status_info;
+
+	return status_info->port_partner_type == PD_STATUS_INFO_PARTNER_UFP;
+}
+
+int rtk_rts5400_set_type_c_soft_reset(void)
+{
+	int ret = 0;
+
+	ret = rtk_rts5400_init_pd_ams(PD_AMS_SOFT_RESET);
+
+	return ret;
+}
+
+int rtk_rts5400_get_current_pdo_voltage(void)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	struct device *dev = rts5400->dev;
+	struct pd_status_info *status_info = &rts5400->status_info;
+	union rdo_info rdo;
+	union pdo_info *pdo = NULL;
+	int offest;
+	int ret = -1;
+	//u8 *buffer;
+	union pdo_info *buffer;
+
+	dev_dbg(dev, "Enter %s\n", __func__);
+	if (status_info->request_data_obj == 0x0) {
+		dev_err(dev, "%s NO request_data_obj", __func__);
+		return ret;
+	} else
+		rdo.set = status_info->request_data_obj;
+
+	offest = (rdo.info.obj_pos - 1) * 4;
+
+	dev_dbg(dev, "%s rdo.obj_pos=%d, offest=%d", __func__,
+			rdo.info.obj_pos, offest);
+
+	if (offest < 0) {
+		dev_err(dev, "%s Error! rdo.obj_pos=%d, offest=%d",
+			__func__, rdo.info.obj_pos, offest);
+		return ret;
+	}
+
+	buffer = kzalloc(7*4, GFP_KERNEL);
+
+	ret = rtk_rts5400_get_PDO(PDO_TYPE_SOURCE, PDO_TCPM_PARTNER, 0, 7, buffer);
+
+	if (ret < 0) {
+		dev_err(dev, "%s rtk_rts5400_get_PDO fail(ret=%d)", __func__, ret);
+		kfree(buffer);
+		return ret;
+	}
+	pdo = buffer + offest;
+
+	if (pdo != NULL && pdo->com.power_type == PDO_INFO_POWER_TYPE_FIX) {
+		dev_info(rts5400->dev, "Current Partner Source Fix PDO, "
+				"valtage %d mV\n", (pdo->so_f.valtage) * 50);
+		ret = pdo->so_f.valtage * 50;
+	}
+
+	kfree(buffer);
+	dev_dbg(dev, "Exit %s\n", __func__);
+	return ret;
+}
+
+/* init and probe */
+static int rtk_rts5400_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct rts5400_dev *rts5400 = &g_rts5400;
+	struct device *dev = &client->dev;
+	struct device_node	*node = dev->of_node;
+	unsigned int gpio, power_on_12v = 0;
+
+	int i, ret;
+	u8 val;
+	dev_dbg(dev, "Enter %s\n", __func__);
+
+	memset(rts5400, 0, sizeof(struct rts5400_dev));
+
+	rts5400->client = client;
+	rts5400->dev = dev;
+
+	i2c_set_clientdata(client, rts5400);
+
+	ret = rtk_rts5400_get_IC_status();
+	if (ret < 0) {
+		dev_err(dev, "[RTS5400] rtk_rts5400_get_IC_status fail (ret=%d)\n", ret);
+		rts5400->no_device = true;
+	} else {
+		ret = rtk_rts5400_get_status();
+		if (ret < 0)
+			dev_err(dev, "[RTS5400] rtk_rts5400_get_status fail (ret=%d)\n", ret);
+		ret = rtk_rts5400_get_PDO(PDO_TYPE_SOURCE, PDO_TCPM_TCPM, 0, 7, NULL);
+		if (ret < 0)
+			dev_err(dev, "[RTS5400] rtk_rts5400_get_PDO "
+				"(PDO_TYPE_SOURCE, PDO_TCPM_TCPM) fail (ret=%d)\n", ret);
+		ret = rtk_rts5400_get_PDO(PDO_TYPE_SOURCE, PDO_TCPM_PARTNER, 0, 7, NULL);
+		if (ret < 0)
+			dev_err(dev, "[RTS5400] rtk_rts5400_get_PDO "
+				"PDO_TYPE_SOURCE, PDO_TCPM_PARTNER) fail (ret=%d)\n", ret);
+		ret = rtk_rts5400_get_PDO(PDO_TYPE_SINK, PDO_TCPM_TCPM, 0, 7, NULL);
+		if (ret < 0)
+			dev_err(dev, "[RTS5400] rtk_rts5400_get_PDO "
+				"(PDO_TYPE_SINK, PDO_TCPM_TCPM) fail (ret=%d)\n", ret);
+		ret = rtk_rts5400_get_PDO(PDO_TYPE_SINK, PDO_TCPM_PARTNER, 0, 7, NULL);
+		if (ret < 0)
+			 dev_err(dev, "[RTS5400] rtk_rts5400_get_PDO "
+				"(PDO_TYPE_SINK, PDO_TCPM_PARTNER) fail (ret=%d)\n", ret);
+
+		ret = rtk_rts5400_get_current_pdo_voltage();
+
+		if (ret >= 12000)
+			power_on_12v = 1;
+
+		gpio = of_get_named_gpio(node, "realtek,12v-power-gpio", 0);
+
+		if (gpio_is_valid(gpio)) {
+			rts5400->pow_gpio = gpio;
+			dev_info(dev, "%s get 12V power-gpio (id=%d) OK\n", __func__, gpio);
+			if (gpio_direction_output(gpio, power_on_12v))
+				dev_err(dev, "%s ERROR set 12v power (= 0) fail\n", __func__);
+			else
+				dev_info(dev, "%s Power %s 12v\n", __func__, power_on_12v?"on":"off");
+		 } else {
+			dev_err(dev, "Error 12V-power-gpio no found");
+			rts5400->pow_gpio = -1;
+		}
+	}
+
+	dev_dbg(dev, "Exit %s\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_SUSPEND
+static int rtk_rts5400_suspend(struct device *dev)
+{
+	dev_dbg(dev, "Enter %s\n", __func__);
+
+	dev_dbg(dev, "Exit %s\n", __func__);
+	return 0;
+}
+
+static int rtk_rts5400_resume(struct device *dev)
+{
+	dev_dbg(dev, "Enter %s\n", __func__);
+
+	dev_dbg(dev, "Exit %s\n", __func__);
+	return 0;
+}
+#else
+
+#define rtk_rts5400_suspend NULL
+#define rtk_rts5400_resume NULL
+
+#endif
+
+static const struct dev_pm_ops rtk_rts5400_pm_ops = {
+	.suspend    = rtk_rts5400_suspend,
+	.resume     = rtk_rts5400_resume,
+};
+
+static const struct i2c_device_id rtk_rts5400_ids[] = {
+	{"rtk-rts5400", 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, rtk_rts5400_ids);
+
+static struct i2c_driver rtk_rts5400_driver = {
+	.driver = {
+		.name = "rtk_rts5400",
+		.owner = THIS_MODULE,
+		.pm = &rtk_rts5400_pm_ops,
+	},
+	.probe = rtk_rts5400_probe,
+	.id_table = rtk_rts5400_ids,
+};
+
+module_i2c_driver(rtk_rts5400_driver);
+
+MODULE_DESCRIPTION("RTS5400 Type C Port Manager Driver");
+MODULE_AUTHOR("Stanley Chang");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 1a556a628..7fb6df867 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -346,6 +346,14 @@ int usb_add_function(struct usb_configuration *config,
 	if (value)
 		DBG(config->cdev, "adding '%s'/%p --> %d\n",
 				function->name, function, value);
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* add to print log*/
+	pr_err("adding '%s'/%p to config '%s'/%p --> %s (ret=%d)\n",
+			function->name, function,
+			config->label, config, value?"Fail":"Ok", value);
+#endif
+
 	return value;
 }
 EXPORT_SYMBOL_GPL(usb_add_function);
@@ -2047,6 +2055,12 @@ void composite_disconnect(struct usb_gadget *gadget)
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	unsigned long			flags;
 
+	if (cdev == NULL) {
+		WARN(1, "%s: Calling disconnect on a Gadget that is \
+			not connected\n", __func__);
+		return;
+	}
+
 	/* REVISIT:  should we have config and device level
 	 * disconnect callbacks?
 	 */
diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
index 9b7fa53d6..dd5a6af73 100644
--- a/drivers/usb/gadget/configfs.c
+++ b/drivers/usb/gadget/configfs.c
@@ -254,6 +254,12 @@ static int unregister_gadget(struct gadget_info *gi)
 	return 0;
 }
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+extern struct usb_gadget_driver *rtk_dwc3_set_and_get_usb_gadget_driver(
+			struct usb_gadget_driver* driver);
+extern int usb_gadget_find_udc(const char *name);
+#endif
+
 static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 		const char *page, size_t len)
 {
@@ -272,8 +278,18 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 
 	mutex_lock(&gi->lock);
 
-	if (!strlen(name)) {
+	if (!strlen(name) || strcmp(name, "none") == 0) {
 		ret = unregister_gadget(gi);
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+		if (ret == -ENODEV && gi->composite.gadget_driver.udc_name) {
+			pr_info("%s gadget device disconnected remove udc_name %s\n",
+					__func__, gi->composite.gadget_driver.udc_name);
+			rtk_dwc3_set_and_get_usb_gadget_driver(NULL);
+			kfree(gi->composite.gadget_driver.udc_name);
+			gi->composite.gadget_driver.udc_name = NULL;
+			ret = 0;
+		}
+#endif
 		if (ret)
 			goto err;
 		kfree(name);
@@ -288,6 +304,17 @@ static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,
 			gi->composite.gadget_driver.udc_name = NULL;
 			goto err;
 		}
+
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+		/* We save usb_gadget_driver for DRD switch*/
+		if (usb_gadget_find_udc(name) == -ENODEV) {
+			pr_info("%s: udc_name=%s usb_udc_attach_driver --> "
+					"gadget device disconnected\n", __func__, name);
+			rtk_dwc3_set_and_get_usb_gadget_driver(
+					&gi->composite.gadget_driver);
+			ret = 0;
+		}
+#endif
 	}
 	mutex_unlock(&gi->lock);
 	return len;
@@ -481,7 +508,10 @@ static void config_usb_cfg_unlink(
 	mutex_lock(&gi->lock);
 	if (gi->composite.gadget_driver.udc_name)
 		unregister_gadget(gi);
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+#else
 	WARN_ON(gi->composite.gadget_driver.udc_name);
+#endif
 
 	list_for_each_entry(f, &cfg->func_list, list) {
 		if (f->fi == fi) {
@@ -1278,6 +1308,9 @@ static void purge_configs_funcs(struct gadget_info *gi)
 		c->highspeed = 0;
 		c->fullspeed = 0;
 	}
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+	wmb();
+#endif
 }
 
 static int configfs_composite_bind(struct usb_gadget *gadget,
@@ -1603,6 +1636,10 @@ static struct config_group *gadgets_make(
 
 	gi->composite.gadget_driver = configfs_driver_template;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	INIT_LIST_HEAD(&(gi->composite.gadget_driver.pending));
+#endif
+
 	gi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);
 	gi->composite.name = gi->composite.gadget_driver.function;
 
diff --git a/drivers/usb/gadget/udc/Kconfig b/drivers/usb/gadget/udc/Kconfig
index 8c614bb86..c46f6edc8 100644
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -287,6 +287,22 @@ config USB_SNP_UDC_PLAT
 	  and Cygnus SoCs.
 
 	  If unsure, say N.
+
+config USB_RTK_UDC
+	tristate "RTK USB2.0 Device Controller"
+	depends on ARCH_RTD129x
+	default ARCH_RTD129x
+	help
+	  RTD129x Soc include a high speed USB2.0 OTG controller, which can be
+	  configured as high speed or full speed USB peripheral.
+
+config USB_RTK_UDC_OTG_SWITCH
+	tristate "RTK USB2.0 HOST/Device switch by sysfs"
+	depends on USB_RTK_UDC && ARCH_RTD129x
+	default USB_RTK_UDC
+	help
+	  Use sysfs to switch RTK 129x SOC USB2.0 OTG controller.
+
 #
 # Controllers available in both integrated and discrete versions
 #
diff --git a/drivers/usb/gadget/udc/Makefile b/drivers/usb/gadget/udc/Makefile
index a21f2224e..a5f46b7e0 100644
--- a/drivers/usb/gadget/udc/Makefile
+++ b/drivers/usb/gadget/udc/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
 obj-$(CONFIG_USB_MV_UDC)	+= mv_udc.o
 mv_udc-y			:= mv_udc_core.o
+obj-$(CONFIG_USB_RTK_UDC)	+= rtk-hsotg.o
 obj-$(CONFIG_USB_FUSB300)	+= fusb300_udc.o
 obj-$(CONFIG_USB_FOTG210_UDC)	+= fotg210-udc.o
 obj-$(CONFIG_USB_MV_U3D)	+= mv_u3d_core.o
diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index ea114f922..d332608d9 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1312,6 +1312,27 @@ char *usb_get_gadget_udc_name(void)
 }
 EXPORT_SYMBOL_GPL(usb_get_gadget_udc_name);
 
+#ifdef CONFIG_USB_RTK_DWC3_DRD_MODE
+int usb_gadget_find_udc(const char *name)
+{
+	struct usb_udc *udc = NULL;
+	int ret = -ENODEV;
+
+	mutex_lock(&udc_lock);
+	list_for_each_entry(udc, &udc_list, list) {
+		ret = strcmp(name, dev_name(&udc->dev));
+		if (!ret)
+			break;
+	}
+	if (ret) {
+		pr_info("%s No udc device for %s", __func__, name);
+	}
+	mutex_unlock(&udc_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usb_gadget_find_udc);
+#endif
+
 /**
  * usb_add_gadget_udc - adds a new gadget to the udc class driver list
  * @parent: the parent device to this udc. Usually the controller
diff --git a/drivers/usb/gadget/udc/rtk-hsotg.c b/drivers/usb/gadget/udc/rtk-hsotg.c
new file mode 100644
index 000000000..f01b390e5
--- /dev/null
+++ b/drivers/usb/gadget/udc/rtk-hsotg.c
@@ -0,0 +1,4075 @@
+/**
+ * linux/drivers/usb/gadget/rtk-hsotg.c
+ *
+ * RTK USB2.0 High-speed / OtG driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_platform.h>
+//#include <linux/phy/phy.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/otg.h>
+
+#include "rtk-hsotg.h"
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#include <soc/realtek/rtd129x_lockapi.h>
+
+static inline unsigned int otg_readl(void __iomem *reg)
+{
+	unsigned long flags;
+	u32 value;
+
+	rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+
+	value = readl_relaxed(reg);
+	//__iormb();
+
+	rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+
+	return value;
+}
+
+static inline void otg_writel(const unsigned int val, void __iomem *reg)
+{
+	unsigned long flags;
+
+	rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+
+	writel_relaxed(val, reg);
+	//__iormb();
+
+	rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+}
+
+#undef readl
+#define readl(addr) otg_readl(addr)
+#undef writel
+#define writel(val, addr) otg_writel(val, addr)
+
+#endif
+
+
+struct platform_device;
+enum rtk_hsotg_dmamode {
+	RTK_HSOTG_DMA_NONE,		/* do not use DMA at-all */
+	RTK_HSOTG_DMA_ONLY,		/* always use DMA */
+	RTK_HSOTG_DMA_DRV,		/* DMA is chosen by driver */
+};
+
+/**
+ * struct rtk_hsotg_plat - platform data for high-speed otg/udc
+ * @dma: Whether to use DMA or not.
+ * @is_osc: The clock source is an oscillator, not a crystal
+ */
+struct rtk_hsotg_plat {
+	enum rtk_hsotg_dmamode	dma;
+	unsigned int		is_osc:1;
+	int                     phy_type;
+
+	int (*phy_init)(struct platform_device *pdev, int type);
+	int (*phy_exit)(struct platform_device *pdev, int type);
+};
+
+extern void rtk_hsotg_set_platdata(struct rtk_hsotg_plat *pd);
+
+static const char * const rtk_hsotg_supply_names[] = {
+	"vusb_d",		/* digital USB supply, 1.2V */
+	"vusb_a",		/* analog USB supply, 1.1V */
+};
+
+/*
+ * EP0_MPS_LIMIT
+ *
+ * Unfortunately there seems to be a limit of the amount of data that can
+ * be transferred by IN transactions on EP0. This is either 127 bytes or 3
+ * packets (which practically means 1 packet and 63 bytes of data) when the
+ * MPS is set to 64.
+ *
+ * This means if we are wanting to move >127 bytes of data, we need to
+ * split the transactions up, but just doing one packet at a time does
+ * not work (this may be an implicit DATA0 PID on first packet of the
+ * transaction) and doing 2 packets is outside the controller's limits.
+ *
+ * If we try to lower the MPS size for EP0, then no transfers work properly
+ * for EP0, and the system will fail basic enumeration. As no cause for this
+ * has currently been found, we cannot support any large IN transfers for
+ * EP0.
+ */
+#define EP0_MPS_LIMIT	64
+
+struct rtk_hsotg;
+struct rtk_hsotg_req;
+
+/**
+ * struct rtk_hsotg_ep - driver endpoint definition.
+ * @ep: The gadget layer representation of the endpoint.
+ * @name: The driver generated name for the endpoint.
+ * @queue: Queue of requests for this endpoint.
+ * @parent: Reference back to the parent device structure.
+ * @req: The current request that the endpoint is processing. This is
+ *       used to indicate an request has been loaded onto the endpoint
+ *       and has yet to be completed (maybe due to data move, or simply
+ *	 awaiting an ack from the core all the data has been completed).
+ * @debugfs: File entry for debugfs file for this endpoint.
+ * @lock: State lock to protect contents of endpoint.
+ * @dir_in: Set to true if this endpoint is of the IN direction, which
+ *	    means that it is sending data to the Host.
+ * @index: The index for the endpoint registers.
+ * @mc: Multi Count - number of transactions per microframe
+ * @interval - Interval for periodic endpoints
+ * @name: The name array passed to the USB core.
+ * @halted: Set if the endpoint has been halted.
+ * @periodic: Set if this is a periodic ep, such as Interrupt
+ * @isochronous: Set if this is a isochronous ep
+ * @sent_zlp: Set if we've sent a zero-length packet.
+ * @total_data: The total number of data bytes done.
+ * @fifo_size: The size of the FIFO (for periodic IN endpoints)
+ * @fifo_load: The amount of data loaded into the FIFO (periodic IN)
+ * @last_load: The offset of data for the last start of request.
+ * @size_loaded: The last loaded size for DxEPTSIZE for periodic IN
+ *
+ * This is the driver's state for each registered enpoint, allowing it
+ * to keep track of transactions that need doing. Each endpoint has a
+ * lock to protect the state, to try and avoid using an overall lock
+ * for the host controller as much as possible.
+ *
+ * For periodic IN endpoints, we have fifo_size and fifo_load to try
+ * and keep track of the amount of data in the periodic FIFO for each
+ * of these as we don't have a status register that tells us how much
+ * is in each of them. (note, this may actually be useless information
+ * as in shared-fifo mode periodic in acts like a single-frame packet
+ * buffer than a fifo)
+ */
+struct rtk_hsotg_ep {
+	struct usb_ep		ep;
+	struct list_head	queue;
+	struct rtk_hsotg	*parent;
+	struct rtk_hsotg_req	*req;
+	struct dentry		*debugfs;
+
+
+	unsigned long		total_data;
+	unsigned int		size_loaded;
+	unsigned int		last_load;
+	unsigned int		fifo_load;
+	unsigned short		fifo_size;
+
+	unsigned char		dir_in;
+	unsigned char		index;
+	unsigned char		mc;
+	unsigned char		interval;
+
+	unsigned int		halted:1;
+	unsigned int		periodic:1;
+	unsigned int		isochronous:1;
+	unsigned int		sent_zlp:1;
+
+	char			name[10];
+};
+
+/**
+ * struct rtk_hsotg - driver state.
+ * @dev: The parent device supplied to the probe function
+ * @driver: USB gadget driver
+ * @phy: The otg phy transceiver structure for phy control.
+ * @uphy: The otg phy transceiver structure for old USB phy control.
+ * @plat: The platform specific configuration data. This can be removed once
+ * all SoCs support usb transceiver.
+ * @regs: The memory area mapped for accessing registers.
+ * @irq: The IRQ number we are using
+ * @supplies: Definition of USB power supplies
+ * @phyif: PHY interface width
+ * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
+ * @num_of_eps: Number of available EPs (excluding EP0)
+ * @debug_root: root directrory for debugfs.
+ * @debug_file: main status file for debugfs.
+ * @debug_fifo: FIFO status file for debugfs.
+ * @ep0_reply: Request used for ep0 reply.
+ * @ep0_buff: Buffer for EP0 reply data, if needed.
+ * @ctrl_buff: Buffer for EP0 control requests.
+ * @ctrl_req: Request for EP0 control packets.
+ * @setup: NAK management for EP0 SETUP
+ * @last_rst: Time of last reset
+ * @eps: The endpoints being supplied to the gadget framework
+ */
+struct rtk_hsotg {
+	struct device		 *dev;
+	struct usb_gadget_driver *driver;
+	struct phy		 *phy;
+	struct usb_phy		 *uphy;
+	struct rtk_hsotg_plat	 *plat;
+
+	spinlock_t              lock;
+
+	void __iomem		*regs;
+	void __iomem		*phyregs;
+	int			irq;
+	struct clk		*clk;
+
+	struct regulator_bulk_data supplies[ARRAY_SIZE(rtk_hsotg_supply_names)];
+
+	u32			phyif;
+	unsigned int		dedicated_fifos:1;
+	unsigned char           num_of_eps;
+
+	struct dentry		*debug_root;
+	struct dentry		*debug_file;
+	struct dentry		*debug_fifo;
+
+	struct usb_request	*ep0_reply;
+	struct usb_request	*ctrl_req;
+	u8			ep0_buff[8];
+	u8			ctrl_buff[8];
+
+	struct usb_gadget	gadget;
+	unsigned int		setup;
+	unsigned long           last_rst;
+	struct rtk_hsotg_ep	*eps;
+
+#ifdef CONFIG_USB_RTK_UDC_OTG_SWITCH
+	int otg_type;
+#define RTK_HOST_MODE 0
+#define RTK_DEVICE_MODE 1
+#endif //CONFIG_USB_RTK_UDC_OTG_SWITCH
+};
+
+/**
+ * struct rtk_hsotg_req - data transfer request
+ * @req: The USB gadget request
+ * @queue: The list of requests for the endpoint this is queued for.
+ * @in_progress: Has already had size/packets written to core
+ * @mapped: DMA buffer for this request has been mapped via dma_map_single().
+ */
+struct rtk_hsotg_req {
+	struct usb_request	req;
+	struct list_head	queue;
+	unsigned char		in_progress;
+	unsigned char		mapped;
+};
+
+/* conversion functions */
+static inline struct rtk_hsotg_req *our_req(struct usb_request *req)
+{
+	return container_of(req, struct rtk_hsotg_req, req);
+}
+
+static inline struct rtk_hsotg_ep *our_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct rtk_hsotg_ep, ep);
+}
+
+static inline struct rtk_hsotg *to_hsotg(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct rtk_hsotg, gadget);
+}
+
+static inline void __orr32(void __iomem *ptr, u32 val)
+{
+	writel(readl(ptr) | val, ptr);
+}
+
+static inline void __bic32(void __iomem *ptr, u32 val)
+{
+	writel(readl(ptr) & ~val, ptr);
+}
+
+/* forward decleration of functions */
+static void rtk_hsotg_dump(struct rtk_hsotg *hsotg);
+
+/**
+ * using_dma - return the DMA status of the driver.
+ * @hsotg: The driver state.
+ *
+ * Return true if we're using DMA.
+ *
+ * Currently, we have the DMA support code worked into everywhere
+ * that needs it, but the AMBA DMA implementation in the hardware can
+ * only DMA from 32bit aligned addresses. This means that gadgets such
+ * as the CDC Ethernet cannot work as they often pass packets which are
+ * not 32bit aligned.
+ *
+ * Unfortunately the choice to use DMA or not is global to the controller
+ * and seems to be only settable when the controller is being put through
+ * a core reset. This means we either need to fix the gadgets to take
+ * account of DMA alignment, or add bounce buffers (yuerk).
+ *
+ * Until this issue is sorted out, we always return 'false'.
+ */
+static inline bool using_dma(struct rtk_hsotg *hsotg)
+{
+	return false;	/* support is not complete */
+}
+
+/**
+ * rtk_hsotg_en_gsint - enable one or more of the general interrupt
+ * @hsotg: The device state
+ * @ints: A bitmask of the interrupts to enable
+ */
+static void rtk_hsotg_en_gsint(struct rtk_hsotg *hsotg, u32 ints)
+{
+	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
+	u32 new_gsintmsk;
+
+	new_gsintmsk = gsintmsk | ints;
+
+	if (new_gsintmsk != gsintmsk) {
+		dev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);
+		writel(new_gsintmsk, hsotg->regs + GINTMSK);
+	}
+}
+
+/**
+ * rtk_hsotg_disable_gsint - disable one or more of the general interrupt
+ * @hsotg: The device state
+ * @ints: A bitmask of the interrupts to enable
+ */
+static void rtk_hsotg_disable_gsint(struct rtk_hsotg *hsotg, u32 ints)
+{
+	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
+	u32 new_gsintmsk;
+
+	new_gsintmsk = gsintmsk & ~ints;
+
+	if (new_gsintmsk != gsintmsk)
+		writel(new_gsintmsk, hsotg->regs + GINTMSK);
+}
+
+/**
+ * rtk_hsotg_ctrl_epint - enable/disable an endpoint irq
+ * @hsotg: The device state
+ * @ep: The endpoint index
+ * @dir_in: True if direction is in.
+ * @en: The enable value, true to enable
+ *
+ * Set or clear the mask for an individual endpoint's interrupt
+ * request.
+ */
+static void rtk_hsotg_ctrl_epint(struct rtk_hsotg *hsotg,
+				 unsigned int ep, unsigned int dir_in,
+				 unsigned int en)
+{
+	unsigned long flags;
+	u32 bit = 1 << ep;
+	u32 daint;
+
+	if (!dir_in)
+		bit <<= 16;
+
+	local_irq_save(flags);
+	daint = readl(hsotg->regs + DAINTMSK);
+	if (en)
+		daint |= bit;
+	else
+		daint &= ~bit;
+	writel(daint, hsotg->regs + DAINTMSK);
+	local_irq_restore(flags);
+}
+
+/**
+ * rtk_hsotg_init_fifo - initialise non-periodic FIFOs
+ * @hsotg: The device instance.
+ */
+static void rtk_hsotg_init_fifo(struct rtk_hsotg *hsotg)
+{
+	unsigned int ep;
+	unsigned int addr;
+	unsigned int size;
+	int timeout;
+	u32 val;
+
+#define FIFO_SZ		512	//2048
+#define FIFO_DEPTH	256	//1024
+	/* set FIFO sizes to 512/256 2048/1024 */
+
+	writel(FIFO_SZ, hsotg->regs + GRXFSIZ);
+	writel(GNPTXFSIZ_NPTxFStAddr(FIFO_SZ) |
+	       GNPTXFSIZ_NPTxFDep(FIFO_DEPTH),
+	       hsotg->regs + GNPTXFSIZ);
+
+	/*
+	 * arange all the rest of the TX FIFOs, as some versions of this
+	 * block have overlapping default addresses. This also ensures
+	 * that if the settings have been changed, then they are set to
+	 * known values.
+	 */
+
+	/* start at the end of the GNPTXFSIZ, rounded up */
+	addr = FIFO_SZ + FIFO_DEPTH;
+	size = 768;
+
+	/*
+	 * currently we allocate TX FIFOs for all possible endpoints,
+	 * and assume that they are all the same size.
+	 */
+
+	for (ep = 1; ep <= 15; ep++) {
+		val = addr;
+		val |= size << DPTXFSIZn_DPTxFSize_SHIFT;
+		addr += size;
+
+		writel(val, hsotg->regs + DPTXFSIZn(ep));
+	}
+
+	/*
+	 * according to p428 of the design guide, we need to ensure that
+	 * all fifos are flushed before continuing
+	 */
+
+	writel(GRSTCTL_TxFNum(0x10) | GRSTCTL_TxFFlsh |
+	       GRSTCTL_RxFFlsh, hsotg->regs + GRSTCTL);
+
+	/* wait until the fifos are both flushed */
+	timeout = 100;
+	while (1) {
+		val = readl(hsotg->regs + GRSTCTL);
+
+		if ((val & (GRSTCTL_TxFFlsh | GRSTCTL_RxFFlsh)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			dev_err(hsotg->dev,
+				"%s: timeout flushing fifos (GRSTCTL=%08x)\n",
+				__func__, val);
+		}
+
+		udelay(1);
+	}
+
+	dev_dbg(hsotg->dev, "FIFOs reset, timeout at %d\n", timeout);
+}
+
+/**
+ * @ep: USB endpoint to allocate request for.
+ * @flags: Allocation flags
+ *
+ * Allocate a new USB request structure appropriate for the specified endpoint
+ */
+static struct usb_request *rtk_hsotg_ep_alloc_request(struct usb_ep *ep,
+						      gfp_t flags)
+{
+	struct rtk_hsotg_req *req;
+
+	req = kzalloc(sizeof(struct rtk_hsotg_req), flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+/**
+ * is_ep_periodic - return true if the endpoint is in periodic mode.
+ * @hs_ep: The endpoint to query.
+ *
+ * Returns true if the endpoint is in periodic mode, meaning it is being
+ * used for an Interrupt or ISO transfer.
+ */
+static inline int is_ep_periodic(struct rtk_hsotg_ep *hs_ep)
+{
+	return hs_ep->periodic;
+}
+
+/**
+ * rtk_hsotg_unmap_dma - unmap the DMA memory being used for the request
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint for the request
+ * @hs_req: The request being processed.
+ *
+ * This is the reverse of rtk_hsotg_map_dma(), called for the completion
+ * of a request to ensure the buffer is ready for access by the caller.
+ */
+static void rtk_hsotg_unmap_dma(struct rtk_hsotg *hsotg,
+				struct rtk_hsotg_ep *hs_ep,
+				struct rtk_hsotg_req *hs_req)
+{
+	struct usb_request *req = &hs_req->req;
+
+	/* ignore this if we're not moving any data */
+	if (hs_req->req.length == 0)
+		return;
+
+	usb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->dir_in);
+}
+
+/**
+ * rtk_hsotg_write_fifo - write packet Data to the TxFIFO
+ * @hsotg: The controller state.
+ * @hs_ep: The endpoint we're going to write for.
+ * @hs_req: The request to write data for.
+ *
+ * This is called when the TxFIFO has some space in it to hold a new
+ * transmission and we have something to give it. The actual setup of
+ * the data size is done elsewhere, so all we have to do is to actually
+ * write the data.
+ *
+ * The return value is zero if there is more space (or nothing was done)
+ * otherwise -ENOSPC is returned if the FIFO space was used up.
+ *
+ * This routine is only needed for PIO
+ */
+static int rtk_hsotg_write_fifo(struct rtk_hsotg *hsotg,
+				struct rtk_hsotg_ep *hs_ep,
+				struct rtk_hsotg_req *hs_req)
+{
+	bool periodic = is_ep_periodic(hs_ep);
+	u32 gnptxsts = readl(hsotg->regs + GNPTXSTS);
+	int buf_pos = hs_req->req.actual;
+	int to_write = hs_ep->size_loaded;
+	void *data;
+	int can_write;
+	int pkt_round;
+	int max_transfer;
+
+	to_write -= (buf_pos - hs_ep->last_load);
+
+	/* if there's nothing to write, get out early */
+	if (to_write == 0)
+		return 0;
+
+	if (periodic && !hsotg->dedicated_fifos) {
+		u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
+		int size_left;
+		int size_done;
+
+		/*
+		 * work out how much data was loaded so we can calculate
+		 * how much data is left in the fifo.
+		 */
+
+		size_left = DxEPTSIZ_XferSize_GET(epsize);
+
+		/*
+		 * if shared fifo, we cannot write anything until the
+		 * previous data has been completely sent.
+		 */
+		if (hs_ep->fifo_load != 0) {
+			rtk_hsotg_en_gsint(hsotg, GINTSTS_PTxFEmp);
+			return -ENOSPC;
+		}
+
+		dev_dbg(hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",
+			__func__, size_left,
+			hs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);
+
+		/* how much of the data has moved */
+		size_done = hs_ep->size_loaded - size_left;
+
+		/* how much data is left in the fifo */
+		can_write = hs_ep->fifo_load - size_done;
+		dev_dbg(hsotg->dev, "%s: => can_write1=%d\n",
+			__func__, can_write);
+
+		can_write = hs_ep->fifo_size - can_write;
+		dev_dbg(hsotg->dev, "%s: => can_write2=%d\n",
+			__func__, can_write);
+
+		if (can_write <= 0) {
+			rtk_hsotg_en_gsint(hsotg, GINTSTS_PTxFEmp);
+			return -ENOSPC;
+		}
+	} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {
+		can_write = readl(hsotg->regs + DTXFSTS(hs_ep->index));
+
+		can_write &= 0xffff;
+		can_write *= 4;
+	} else {
+		if (GNPTXSTS_NPTxQSpcAvail_GET(gnptxsts) == 0) {
+			dev_dbg(hsotg->dev,
+				"%s: no queue slots available (0x%08x)\n",
+				__func__, gnptxsts);
+
+			rtk_hsotg_en_gsint(hsotg, GINTSTS_NPTxFEmp);
+			return -ENOSPC;
+		}
+
+		can_write = GNPTXSTS_NPTxFSpcAvail_GET(gnptxsts);
+		can_write *= 4;	/* fifo size is in 32bit quantities. */
+	}
+
+	max_transfer = hs_ep->ep.maxpacket * hs_ep->mc;
+
+	dev_dbg(hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n",
+		 __func__, gnptxsts, can_write, to_write, max_transfer);
+
+	/*
+	 * limit to 512 bytes of data, it seems at least on the non-periodic
+	 * FIFO, requests of >512 cause the endpoint to get stuck with a
+	 * fragment of the end of the transfer in it.
+	 */
+	if (can_write > 512 && !periodic)
+		can_write = 512;
+
+	/*
+	 * limit the write to one max-packet size worth of data, but allow
+	 * the transfer to return that it did not run out of fifo space
+	 * doing it.
+	 */
+	if (to_write > max_transfer) {
+		to_write = max_transfer;
+
+		/* it's needed only when we do not use dedicated fifos */
+		if (!hsotg->dedicated_fifos)
+			rtk_hsotg_en_gsint(hsotg,
+					   periodic ? GINTSTS_PTxFEmp :
+					   GINTSTS_NPTxFEmp);
+	}
+
+	/* see if we can write data */
+
+	if (to_write > can_write) {
+		to_write = can_write;
+		pkt_round = to_write % max_transfer;
+
+		/*
+		 * Round the write down to an
+		 * exact number of packets.
+		 *
+		 * Note, we do not currently check to see if we can ever
+		 * write a full packet or not to the FIFO.
+		 */
+
+		if (pkt_round)
+			to_write -= pkt_round;
+
+		/*
+		 * enable correct FIFO interrupt to alert us when there
+		 * is more room left.
+		 */
+
+		/* it's needed only when we do not use dedicated fifos */
+		if (!hsotg->dedicated_fifos)
+			rtk_hsotg_en_gsint(hsotg,
+					   periodic ? GINTSTS_PTxFEmp :
+					   GINTSTS_NPTxFEmp);
+	}
+
+	dev_dbg(hsotg->dev, "write %d/%d, can_write %d, done %d\n",
+		 to_write, hs_req->req.length, can_write, buf_pos);
+
+	if (to_write <= 0)
+		return -ENOSPC;
+
+	hs_req->req.actual = buf_pos + to_write;
+	hs_ep->total_data += to_write;
+
+	if (periodic)
+		hs_ep->fifo_load += to_write;
+
+	to_write = DIV_ROUND_UP(to_write, 4);
+	data = hs_req->req.buf + buf_pos;
+
+	iowrite32_rep(hsotg->regs + EPFIFO(hs_ep->index), data, to_write);
+
+	return (to_write >= can_write) ? -ENOSPC : 0;
+}
+
+/**
+ * get_ep_limit - get the maximum data legnth for this endpoint
+ * @hs_ep: The endpoint
+ *
+ * Return the maximum data that can be queued in one go on a given endpoint
+ * so that transfers that are too long can be split.
+ */
+static unsigned get_ep_limit(struct rtk_hsotg_ep *hs_ep)
+{
+	int index = hs_ep->index;
+	unsigned maxsize;
+	unsigned maxpkt;
+
+	if (index != 0) {
+		maxsize = DxEPTSIZ_XferSize_LIMIT + 1;
+		maxpkt = DxEPTSIZ_PktCnt_LIMIT + 1;
+	} else {
+		maxsize = 64+64;
+		if (hs_ep->dir_in)
+			maxpkt = DIEPTSIZ0_PktCnt_LIMIT + 1;
+		else
+			maxpkt = 2;
+	}
+
+	/* we made the constant loading easier above by using +1 */
+	maxpkt--;
+	maxsize--;
+
+	/*
+	 * constrain by packet count if maxpkts*pktsize is greater
+	 * than the length register size.
+	 */
+
+	if ((maxpkt * hs_ep->ep.maxpacket) < maxsize)
+		maxsize = maxpkt * hs_ep->ep.maxpacket;
+
+	return maxsize;
+}
+
+/**
+ * rtk_hsotg_start_req - start a USB request from an endpoint's queue
+ * @hsotg: The controller state.
+ * @hs_ep: The endpoint to process a request for
+ * @hs_req: The request to start.
+ * @continuing: True if we are doing more for the current request.
+ *
+ * Start the given request running by setting the endpoint registers
+ * appropriately, and writing any data to the FIFOs.
+ */
+static void rtk_hsotg_start_req(struct rtk_hsotg *hsotg,
+				struct rtk_hsotg_ep *hs_ep,
+				struct rtk_hsotg_req *hs_req,
+				bool continuing)
+{
+	struct usb_request *ureq = &hs_req->req;
+	int index = hs_ep->index;
+	int dir_in = hs_ep->dir_in;
+	u32 epctrl_reg;
+	u32 epsize_reg;
+	u32 epsize;
+	u32 ctrl;
+	unsigned length;
+	unsigned packets;
+	unsigned maxreq;
+
+	if (index != 0) {
+		if (hs_ep->req && !continuing) {
+			dev_err(hsotg->dev, "%s: active request\n", __func__);
+			WARN_ON(1);
+			return;
+		} else if (hs_ep->req != hs_req && continuing) {
+			dev_err(hsotg->dev,
+				"%s: continue different req\n", __func__);
+			WARN_ON(1);
+			return;
+		}
+	}
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+	epsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);
+
+	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",
+		__func__, readl(hsotg->regs + epctrl_reg), index,
+		hs_ep->dir_in ? "in" : "out");
+
+	/* If endpoint is stalled, we will restart request later */
+	ctrl = readl(hsotg->regs + epctrl_reg);
+
+	if (ctrl & DxEPCTL_Stall) {
+		dev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);
+		return;
+	}
+
+	length = ureq->length - ureq->actual;
+	dev_dbg(hsotg->dev, "ureq->length:%d ureq->actual:%d\n",
+		ureq->length, ureq->actual);
+	if (0)
+		dev_dbg(hsotg->dev,
+			"REQ buf %p len %d dma 0x%pad noi=%d zp=%d snok=%d\n",
+			ureq->buf, length, &ureq->dma,
+			ureq->no_interrupt, ureq->zero, ureq->short_not_ok);
+
+	maxreq = get_ep_limit(hs_ep);
+	if (length > maxreq) {
+		int round = maxreq % hs_ep->ep.maxpacket;
+
+		dev_dbg(hsotg->dev, "%s: length %d, max-req %d, r %d\n",
+			__func__, length, maxreq, round);
+
+		/* round down to multiple of packets */
+		if (round)
+			maxreq -= round;
+
+		length = maxreq;
+	}
+
+	if (length)
+		packets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);
+	else
+		packets = 1;	/* send one packet if length is zero. */
+
+	if (hs_ep->isochronous && length > (hs_ep->mc * hs_ep->ep.maxpacket)) {
+		dev_err(hsotg->dev, "req length > maxpacket*mc\n");
+		return;
+	}
+
+	if (dir_in && index != 0)
+		if (hs_ep->isochronous)
+			epsize = DxEPTSIZ_MC(packets);
+		else
+			epsize = DxEPTSIZ_MC(1);
+	else
+		epsize = 0;
+
+	if (index != 0 && ureq->zero) {
+		/*
+		 * test for the packets being exactly right for the
+		 * transfer
+		 */
+
+		if (length == (packets * hs_ep->ep.maxpacket))
+			packets++;
+	}
+
+	epsize |= DxEPTSIZ_PktCnt(packets);
+	epsize |= DxEPTSIZ_XferSize(length);
+
+	dev_dbg(hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",
+		__func__, packets, length, ureq->length, epsize, epsize_reg);
+
+	/* store the request as the current one we're doing */
+	hs_ep->req = hs_req;
+
+	/* write size / packets */
+	writel(epsize, hsotg->regs + epsize_reg);
+
+	if (using_dma(hsotg) && !continuing) {
+		unsigned int dma_reg;
+
+		/*
+		 * write DMA address to control register, buffer already
+		 * synced by rtk_hsotg_ep_queue().
+		 */
+
+		dma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);
+		writel(ureq->dma, hsotg->regs + dma_reg);
+
+		dev_dbg(hsotg->dev, "%s: 0x%pad => 0x%08x\n",
+			__func__, &ureq->dma, dma_reg);
+	}
+
+	ctrl |= DxEPCTL_EPEna;	/* ensure ep enabled */
+	ctrl |= DxEPCTL_USBActEp;
+
+	dev_dbg(hsotg->dev, "setup req:%d\n", hsotg->setup);
+
+	/* For Setup request do not clear NAK */
+#if 0	//barry
+	if (hsotg->setup && index == 0)
+		hsotg->setup = 0;
+	else
+#endif
+		ctrl |= DxEPCTL_CNAK;	/* clear NAK set by core */
+
+
+	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
+	writel(ctrl, hsotg->regs + epctrl_reg);
+
+	/*
+	 * set these, it seems that DMA support increments past the end
+	 * of the packet buffer so we need to calculate the length from
+	 * this information.
+	 */
+	hs_ep->size_loaded = length;
+	hs_ep->last_load = ureq->actual;
+
+	if (dir_in && !using_dma(hsotg)) {
+		/* set these anyway, we may need them for non-periodic in */
+		hs_ep->fifo_load = 0;
+
+		rtk_hsotg_write_fifo(hsotg, hs_ep, hs_req);
+	}
+
+	/*
+	 * clear the INTknTXFEmpMsk when we start request, more as a aide
+	 * to debugging to see what is going on.
+	 */
+	if (dir_in)
+		writel(DIEPMSK_INTknTXFEmpMsk,
+		       hsotg->regs + DIEPINT(index));
+
+	/* check ep is enabled */
+	if (!(readl(hsotg->regs + epctrl_reg) & DxEPCTL_EPEna))
+		dev_warn(hsotg->dev,
+			 "ep%d: failed to become enabled (DxEPCTL=0x%08x)?\n",
+			 index, readl(hsotg->regs + epctrl_reg));
+
+	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n",
+		__func__, readl(hsotg->regs + epctrl_reg));
+
+	/* enable ep interrupts */
+	rtk_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);
+}
+
+/**
+ * rtk_hsotg_map_dma - map the DMA memory being used for the request
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint the request is on.
+ * @req: The request being processed.
+ *
+ * We've been asked to queue a request, so ensure that the memory buffer
+ * is correctly setup for DMA. If we've been passed an extant DMA address
+ * then ensure the buffer has been synced to memory. If our buffer has no
+ * DMA memory, then we map the memory and mark our request to allow us to
+ * cleanup on completion.
+ */
+static int rtk_hsotg_map_dma(struct rtk_hsotg *hsotg,
+			     struct rtk_hsotg_ep *hs_ep,
+			     struct usb_request *req)
+{
+	struct rtk_hsotg_req *hs_req = our_req(req);
+	int ret;
+
+	/* if the length is zero, ignore the DMA data */
+	if (hs_req->req.length == 0)
+		return 0;
+
+	ret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);
+	if (ret)
+		goto dma_error;
+
+	return 0;
+
+dma_error:
+	dev_err(hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",
+		__func__, req->buf, req->length);
+
+	return -EIO;
+}
+
+static int rtk_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,
+			      gfp_t gfp_flags)
+{
+	struct rtk_hsotg_req *hs_req = our_req(req);
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hs = hs_ep->parent;
+	bool first;
+
+	dev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
+		ep->name, req, req->length, req->buf, req->no_interrupt,
+		req->zero, req->short_not_ok);
+
+	/* initialise status of the request */
+	INIT_LIST_HEAD(&hs_req->queue);
+	req->actual = 0;
+	req->status = -EINPROGRESS;
+
+	/* if we're using DMA, sync the buffers as necessary */
+	if (using_dma(hs)) {
+		int ret = rtk_hsotg_map_dma(hs, hs_ep, req);
+		if (ret)
+			return ret;
+	}
+
+	first = list_empty(&hs_ep->queue);
+	list_add_tail(&hs_req->queue, &hs_ep->queue);
+
+	if (first)
+		rtk_hsotg_start_req(hs, hs_ep, hs_req, false);
+
+	return 0;
+}
+
+static int rtk_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,
+			      gfp_t gfp_flags)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hs = hs_ep->parent;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	spin_lock_irqsave(&hs->lock, flags);
+	ret = rtk_hsotg_ep_queue(ep, req, gfp_flags);
+	spin_unlock_irqrestore(&hs->lock, flags);
+
+	return ret;
+}
+
+static void rtk_hsotg_ep_free_request(struct usb_ep *ep,
+				      struct usb_request *req)
+{
+	struct rtk_hsotg_req *hs_req = our_req(req);
+
+	kfree(hs_req);
+}
+
+/**
+ * rtk_hsotg_complete_oursetup - setup completion callback
+ * @ep: The endpoint the request was on.
+ * @req: The request completed.
+ *
+ * Called on completion of any requests the driver itself
+ * submitted that need cleaning up.
+ */
+static void rtk_hsotg_complete_oursetup(struct usb_ep *ep,
+					struct usb_request *req)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hsotg = hs_ep->parent;
+
+	dev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);
+
+	rtk_hsotg_ep_free_request(ep, req);
+}
+
+/**
+ * ep_from_windex - convert control wIndex value to endpoint
+ * @hsotg: The driver state.
+ * @windex: The control request wIndex field (in host order).
+ *
+ * Convert the given wIndex into a pointer to an driver endpoint
+ * structure, or return NULL if it is not a valid endpoint.
+ */
+static struct rtk_hsotg_ep *ep_from_windex(struct rtk_hsotg *hsotg,
+					   u32 windex)
+{
+	struct rtk_hsotg_ep *ep = &hsotg->eps[windex & 0x7F];
+	int dir = (windex & USB_DIR_IN) ? 1 : 0;
+	int idx = windex & 0x7F;
+
+	if (windex >= 0x100)
+		return NULL;
+
+	if (idx > hsotg->num_of_eps)
+		return NULL;
+
+	if (idx && ep->dir_in != dir)
+		return NULL;
+
+	return ep;
+}
+
+/**
+ * rtk_hsotg_send_reply - send reply to control request
+ * @hsotg: The device state
+ * @ep: Endpoint 0
+ * @buff: Buffer for request
+ * @length: Length of reply.
+ *
+ * Create a request and queue it on the given endpoint. This is useful as
+ * an internal method of sending replies to certain control requests, etc.
+ */
+static int rtk_hsotg_send_reply(struct rtk_hsotg *hsotg,
+				struct rtk_hsotg_ep *ep,
+				void *buff,
+				int length)
+{
+	struct usb_request *req;
+	int ret;
+
+	dev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);
+
+	req = rtk_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);
+	hsotg->ep0_reply = req;
+	if (!req) {
+		dev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);
+		return -ENOMEM;
+	}
+
+	req->buf = hsotg->ep0_buff;
+	req->length = length;
+	req->zero = 1; /* always do zero-length final transfer */
+	req->complete = rtk_hsotg_complete_oursetup;
+
+	if (length)
+		memcpy(req->buf, buff, length);
+	else
+		ep->sent_zlp = 1;
+
+	ret = rtk_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);
+	if (ret) {
+		dev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * rtk_hsotg_process_req_status - process request GET_STATUS
+ * @hsotg: The device state
+ * @ctrl: USB control request
+ */
+static int rtk_hsotg_process_req_status(struct rtk_hsotg *hsotg,
+					struct usb_ctrlrequest *ctrl)
+{
+	struct rtk_hsotg_ep *ep0 = &hsotg->eps[0];
+	struct rtk_hsotg_ep *ep;
+	__le16 reply;
+	int ret;
+
+	dev_dbg(hsotg->dev, "%s: USB_REQ_GET_STATUS\n", __func__);
+
+	if (!ep0->dir_in) {
+		dev_warn(hsotg->dev, "%s: direction out?\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (ctrl->bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_DEVICE:
+		reply = cpu_to_le16(0); /* bit 0 => self powered,
+					 * bit 1 => remote wakeup */
+		break;
+
+	case USB_RECIP_INTERFACE:
+		/* currently, the data result should be zero */
+		reply = cpu_to_le16(0);
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
+		if (!ep)
+			return -ENOENT;
+
+		reply = cpu_to_le16(ep->halted ? 1 : 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (le16_to_cpu(ctrl->wLength) != 2)
+		return -EINVAL;
+
+	ret = rtk_hsotg_send_reply(hsotg, ep0, &reply, 2);
+	if (ret) {
+		dev_err(hsotg->dev, "%s: failed to send reply\n", __func__);
+		return ret;
+	}
+
+	return 1;
+}
+
+static int rtk_hsotg_ep_sethalt(struct usb_ep *ep, int value);
+
+/**
+ * get_ep_head - return the first request on the endpoint
+ * @hs_ep: The controller endpoint to get
+ *
+ * Get the first request on the endpoint.
+ */
+static struct rtk_hsotg_req *get_ep_head(struct rtk_hsotg_ep *hs_ep)
+{
+	if (list_empty(&hs_ep->queue))
+		return NULL;
+
+	return list_first_entry(&hs_ep->queue, struct rtk_hsotg_req, queue);
+}
+
+/**
+ * rtk_hsotg_process_req_featire - process request {SET,CLEAR}_FEATURE
+ * @hsotg: The device state
+ * @ctrl: USB control request
+ */
+static int rtk_hsotg_process_req_feature(struct rtk_hsotg *hsotg,
+					 struct usb_ctrlrequest *ctrl)
+{
+	struct rtk_hsotg_ep *ep0 = &hsotg->eps[0];
+	struct rtk_hsotg_req *hs_req;
+	bool restart;
+	bool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);
+	struct rtk_hsotg_ep *ep;
+	int ret;
+	bool halted;
+
+	dev_dbg(hsotg->dev, "%s: %s_FEATURE\n",
+		__func__, set ? "SET" : "CLEAR");
+
+	if (ctrl->bRequestType == USB_RECIP_ENDPOINT) {
+		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
+		if (!ep) {
+			dev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",
+				__func__, le16_to_cpu(ctrl->wIndex));
+			return -ENOENT;
+		}
+
+		switch (le16_to_cpu(ctrl->wValue)) {
+		case USB_ENDPOINT_HALT:
+			halted = ep->halted;
+
+			rtk_hsotg_ep_sethalt(&ep->ep, set);
+
+			ret = rtk_hsotg_send_reply(hsotg, ep0, NULL, 0);
+			if (ret) {
+				dev_err(hsotg->dev,
+					"%s: failed to send reply\n", __func__);
+				return ret;
+			}
+
+			/*
+			 * we have to complete all requests for ep if it was
+			 * halted, and the halt was cleared by CLEAR_FEATURE
+			 */
+
+			if (!set && halted) {
+				/*
+				 * If we have request in progress,
+				 * then complete it
+				 */
+				if (ep->req) {
+					hs_req = ep->req;
+					ep->req = NULL;
+					list_del_init(&hs_req->queue);
+					hs_req->req.complete(&ep->ep,
+							     &hs_req->req);
+				}
+
+				/* If we have pending request, then start it */
+				restart = !list_empty(&ep->queue);
+				if (restart) {
+					hs_req = get_ep_head(ep);
+					rtk_hsotg_start_req(hsotg, ep,
+							    hs_req, false);
+				}
+			}
+
+			break;
+
+		default:
+			return -ENOENT;
+		}
+	} else
+		return -ENOENT;  /* currently only deal with endpoint */
+
+	return 1;
+}
+
+static void rtk_hsotg_enqueue_setup(struct rtk_hsotg *hsotg);
+static void rtk_hsotg_disconnect(struct rtk_hsotg *hsotg);
+
+/**
+ * rtk_hsotg_stall_ep0 - stall ep0
+ * @hsotg: The device state
+ *
+ * Set stall for ep0 as response for setup request.
+ */
+static void rtk_hsotg_stall_ep0(struct rtk_hsotg *hsotg) {
+	struct rtk_hsotg_ep *ep0 = &hsotg->eps[0];
+	u32 reg;
+	u32 ctrl;
+
+	dev_dbg(hsotg->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);
+	reg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;
+
+	/*
+	 * DxEPCTL_Stall will be cleared by EP once it has
+	 * taken effect, so no need to clear later.
+	 */
+
+	ctrl = readl(hsotg->regs + reg);
+	ctrl |= DxEPCTL_Stall;
+	ctrl |= DxEPCTL_CNAK;
+	writel(ctrl, hsotg->regs + reg);
+
+	dev_dbg(hsotg->dev,
+		"written DxEPCTL=0x%08x to %08x (DxEPCTL=0x%08x)\n",
+		ctrl, reg, readl(hsotg->regs + reg));
+
+	 /*
+	  * complete won't be called, so we enqueue
+	  * setup request here
+	  */
+	 rtk_hsotg_enqueue_setup(hsotg);
+}
+
+/**
+ * rtk_hsotg_process_control - process a control request
+ * @hsotg: The device state
+ * @ctrl: The control request received
+ *
+ * The controller has received the SETUP phase of a control request, and
+ * needs to work out what to do next (and whether to pass it on to the
+ * gadget driver).
+ */
+static void rtk_hsotg_process_control(struct rtk_hsotg *hsotg,
+				      struct usb_ctrlrequest *ctrl)
+{
+	struct rtk_hsotg_ep *ep0 = &hsotg->eps[0];
+	int ret = 0;
+	u32 dcfg;
+
+	ep0->sent_zlp = 0;
+
+	dev_dbg(hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",
+		 ctrl->bRequest, ctrl->bRequestType,
+		 ctrl->wValue, ctrl->wLength);
+
+	/*
+	 * record the direction of the request, for later use when enquing
+	 * packets onto EP0.
+	 */
+
+	ep0->dir_in = (ctrl->bRequestType & USB_DIR_IN) ? 1 : 0;
+	dev_dbg(hsotg->dev, "ctrl: dir_in=%d\n", ep0->dir_in);
+
+	/*
+	 * if we've no data with this request, then the last part of the
+	 * transaction is going to implicitly be IN.
+	 */
+	if (ctrl->wLength == 0)
+		ep0->dir_in = 1;
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (ctrl->bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			rtk_hsotg_disconnect(hsotg);
+			dcfg = readl(hsotg->regs + DCFG);
+			dcfg &= ~DCFG_DevAddr_MASK;
+			dcfg |= ctrl->wValue << DCFG_DevAddr_SHIFT;
+			writel(dcfg, hsotg->regs + DCFG);
+
+			dev_info(hsotg->dev, "new address %d\n", ctrl->wValue);
+
+			ret = rtk_hsotg_send_reply(hsotg, ep0, NULL, 0);
+			return;
+
+		case USB_REQ_GET_STATUS:
+			ret = rtk_hsotg_process_req_status(hsotg, ctrl);
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			ret = rtk_hsotg_process_req_feature(hsotg, ctrl);
+			break;
+		}
+	}
+
+	/* as a fallback, try delivering it to the driver to deal with */
+
+	if (ret == 0 && hsotg->driver) {
+		spin_unlock(&hsotg->lock);
+		ret = hsotg->driver->setup(&hsotg->gadget, ctrl);
+		spin_lock(&hsotg->lock);
+		if (ret < 0)
+			dev_dbg(hsotg->dev, "driver->setup() ret %d\n", ret);
+	}
+
+	/*
+	 * the request is either unhandlable, or is not formatted correctly
+	 * so respond with a STALL for the status stage to indicate failure.
+	 */
+
+	if (ret < 0)
+		rtk_hsotg_stall_ep0(hsotg);
+}
+
+/**
+ * rtk_hsotg_complete_setup - completion of a setup transfer
+ * @ep: The endpoint the request was on.
+ * @req: The request completed.
+ *
+ * Called on completion of any requests the driver itself submitted for
+ * EP0 setup packets
+ */
+static void rtk_hsotg_complete_setup(struct usb_ep *ep,
+				     struct usb_request *req)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hsotg = hs_ep->parent;
+
+	if (req->status < 0) {
+		dev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);
+		return;
+	}
+
+	spin_lock(&hsotg->lock);
+	if (req->actual == 0)
+		rtk_hsotg_enqueue_setup(hsotg);
+	else
+		rtk_hsotg_process_control(hsotg, req->buf);
+	spin_unlock(&hsotg->lock);
+}
+
+/**
+ * rtk_hsotg_enqueue_setup - start a request for EP0 packets
+ * @hsotg: The device state.
+ *
+ * Enqueue a request on EP0 if necessary to received any SETUP packets
+ * received from the host.
+ */
+static void rtk_hsotg_enqueue_setup(struct rtk_hsotg *hsotg)
+{
+	struct usb_request *req = hsotg->ctrl_req;
+	struct rtk_hsotg_req *hs_req = our_req(req);
+	int ret;
+
+	dev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);
+
+	req->zero = 0;
+	req->length = 8;
+	req->buf = hsotg->ctrl_buff;
+	req->complete = rtk_hsotg_complete_setup;
+
+	if (!list_empty(&hs_req->queue)) {
+		dev_dbg(hsotg->dev, "%s already queued???\n", __func__);
+		return;
+	}
+
+	hsotg->eps[0].dir_in = 0;
+
+	ret = rtk_hsotg_ep_queue(&hsotg->eps[0].ep, req, GFP_ATOMIC);
+	if (ret < 0) {
+		dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
+		/*
+		 * Don't think there's much we can do other than watch the
+		 * driver fail.
+		 */
+	}
+}
+
+/**
+ * rtk_hsotg_complete_request - complete a request given to us
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint the request was on.
+ * @hs_req: The request to complete.
+ * @result: The result code (0 => Ok, otherwise errno)
+ *
+ * The given request has finished, so call the necessary completion
+ * if it has one and then look to see if we can start a new request
+ * on the endpoint.
+ *
+ * Note, expects the ep to already be locked as appropriate.
+ */
+static void rtk_hsotg_complete_request(struct rtk_hsotg *hsotg,
+				       struct rtk_hsotg_ep *hs_ep,
+				       struct rtk_hsotg_req *hs_req,
+				       int result)
+{
+	bool restart;
+
+	if (!hs_req) {
+		dev_dbg(hsotg->dev, "%s: nothing to complete?\n", __func__);
+		return;
+	}
+
+	dev_dbg(hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",
+		hs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);
+
+	/*
+	 * only replace the status if we've not already set an error
+	 * from a previous transaction
+	 */
+
+	if (hs_req->req.status == -EINPROGRESS)
+		hs_req->req.status = result;
+
+	hs_ep->req = NULL;
+	list_del_init(&hs_req->queue);
+
+	if (using_dma(hsotg))
+		rtk_hsotg_unmap_dma(hsotg, hs_ep, hs_req);
+
+	/*
+	 * call the complete request with the locks off, just in case the
+	 * request tries to queue more work for this endpoint.
+	 */
+
+	if (hs_req->req.complete) {
+		spin_unlock(&hsotg->lock);
+		hs_req->req.complete(&hs_ep->ep, &hs_req->req);
+		spin_lock(&hsotg->lock);
+	}
+
+	/*
+	 * Look to see if there is anything else to do. Note, the completion
+	 * of the previous request may have caused a new request to be started
+	 * so be careful when doing this.
+	 */
+
+	if (!hs_ep->req && result >= 0) {
+		restart = !list_empty(&hs_ep->queue);
+		if (restart) {
+			hs_req = get_ep_head(hs_ep);
+			rtk_hsotg_start_req(hsotg, hs_ep, hs_req, false);
+		}
+	}
+}
+
+/**
+ * rtk_hsotg_rx_data - receive data from the FIFO for an endpoint
+ * @hsotg: The device state.
+ * @ep_idx: The endpoint index for the data
+ * @size: The size of data in the fifo, in bytes
+ *
+ * The FIFO status shows there is data to read from the FIFO for a given
+ * endpoint, so sort out whether we need to read the data into a request
+ * that has been made for that endpoint.
+ */
+static void rtk_hsotg_rx_data(struct rtk_hsotg *hsotg, int ep_idx, int size)
+{
+	struct rtk_hsotg_ep *hs_ep = &hsotg->eps[ep_idx];
+	struct rtk_hsotg_req *hs_req = hs_ep->req;
+	void __iomem *fifo = hsotg->regs + EPFIFO(ep_idx);
+	int to_read;
+	int max_req;
+	int read_ptr;
+
+
+	if (!hs_req) {
+		u32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));
+		int ptr;
+
+		dev_warn(hsotg->dev,
+			 "%s: FIFO %d bytes on ep%d but no req (DxEPCTl=0x%08x)\n",
+			 __func__, size, ep_idx, epctl);
+
+		/* dump the data from the FIFO, we've nothing we can do */
+		for (ptr = 0; ptr < size; ptr += 4)
+			(void)readl(fifo);
+
+		return;
+	}
+
+	to_read = size;
+	read_ptr = hs_req->req.actual;
+	max_req = hs_req->req.length - read_ptr;
+
+	dev_dbg(hsotg->dev, "%s: read %d/%d, done %d/%d\n",
+		__func__, to_read, max_req, read_ptr, hs_req->req.length);
+
+	if (to_read > max_req) {
+		/*
+		 * more data appeared than we where willing
+		 * to deal with in this request.
+		 */
+
+		/* currently we don't deal this */
+		WARN_ON_ONCE(1);
+	}
+
+	hs_ep->total_data += to_read;
+	hs_req->req.actual += to_read;
+	to_read = DIV_ROUND_UP(to_read, 4);
+
+	/*
+	 * note, we might over-write the buffer end by 3 bytes depending on
+	 * alignment of the data.
+	 */
+	ioread32_rep(fifo, hs_req->req.buf + read_ptr, to_read);
+}
+
+/**
+ * rtk_hsotg_send_zlp - send zero-length packet on control endpoint
+ * @hsotg: The device instance
+ * @req: The request currently on this endpoint
+ *
+ * Generate a zero-length IN packet request for terminating a SETUP
+ * transaction.
+ *
+ * Note, since we don't write any data to the TxFIFO, then it is
+ * currently believed that we do not need to wait for any space in
+ * the TxFIFO.
+ */
+static void rtk_hsotg_send_zlp(struct rtk_hsotg *hsotg,
+			       struct rtk_hsotg_req *req)
+{
+	u32 ctrl;
+
+	if (!req) {
+		dev_warn(hsotg->dev, "%s: no request?\n", __func__);
+		return;
+	}
+
+	if (req->req.length == 0) {
+		hsotg->eps[0].sent_zlp = 1;
+		rtk_hsotg_enqueue_setup(hsotg);
+		return;
+	}
+
+	hsotg->eps[0].dir_in = 1;
+	hsotg->eps[0].sent_zlp = 1;
+
+	dev_dbg(hsotg->dev, "sending zero-length packet\n");
+
+	/* issue a zero-sized packet to terminate this */
+	writel(DxEPTSIZ_MC(1) | DxEPTSIZ_PktCnt(1) |
+	       DxEPTSIZ_XferSize(0), hsotg->regs + DIEPTSIZ(0));
+
+	ctrl = readl(hsotg->regs + DIEPCTL0);
+	ctrl |= DxEPCTL_CNAK;  /* clear NAK set by core */
+	ctrl |= DxEPCTL_EPEna; /* ensure ep enabled */
+	ctrl |= DxEPCTL_USBActEp;
+	writel(ctrl, hsotg->regs + DIEPCTL0);
+}
+
+/**
+ * rtk_hsotg_handle_outdone - handle receiving OutDone/SetupDone from RXFIFO
+ * @hsotg: The device instance
+ * @epnum: The endpoint received from
+ * @was_setup: Set if processing a SetupDone event.
+ *
+ * The RXFIFO has delivered an OutDone event, which means that the data
+ * transfer for an OUT endpoint has been completed, either by a short
+ * packet or by the finish of a transfer.
+ */
+static void rtk_hsotg_handle_outdone(struct rtk_hsotg *hsotg,
+				     int epnum, bool was_setup)
+{
+	u32 epsize = readl(hsotg->regs + DOEPTSIZ(epnum));
+	struct rtk_hsotg_ep *hs_ep = &hsotg->eps[epnum];
+	struct rtk_hsotg_req *hs_req = hs_ep->req;
+	struct usb_request *req = &hs_req->req;
+	unsigned size_left = DxEPTSIZ_XferSize_GET(epsize);
+	int result = 0;
+
+	if (!hs_req) {
+		dev_dbg(hsotg->dev, "%s: no request active\n", __func__);
+		return;
+	}
+
+	if (using_dma(hsotg)) {
+		unsigned size_done;
+
+		/*
+		 * Calculate the size of the transfer by checking how much
+		 * is left in the endpoint size register and then working it
+		 * out from the amount we loaded for the transfer.
+		 *
+		 * We need to do this as DMA pointers are always 32bit aligned
+		 * so may overshoot/undershoot the transfer.
+		 */
+
+		size_done = hs_ep->size_loaded - size_left;
+		size_done += hs_ep->last_load;
+
+		req->actual = size_done;
+	}
+
+	/* if there is more request to do, schedule new transfer */
+	if (req->actual < req->length && size_left == 0) {
+		rtk_hsotg_start_req(hsotg, hs_ep, hs_req, true);
+		return;
+	} else if (epnum == 0) {
+		/*
+		 * After was_setup = 1 =>
+		 * set CNAK for non Setup requests
+		 */
+		hsotg->setup = was_setup ? 0 : 1;
+	}
+
+	if (req->actual < req->length && req->short_not_ok) {
+		dev_dbg(hsotg->dev, "%s: got %d/%d (short not ok) => error\n",
+			__func__, req->actual, req->length);
+
+		/*
+		 * todo - what should we return here? there's no one else
+		 * even bothering to check the status.
+		 */
+	}
+
+	if (epnum == 0) {
+		/*
+		 * Condition req->complete != rtk_hsotg_complete_setup says:
+		 * send ZLP when we have an asynchronous request from gadget
+		 */
+		if (!was_setup && req->complete != rtk_hsotg_complete_setup)
+			rtk_hsotg_send_zlp(hsotg, hs_req);
+	}
+
+	rtk_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
+}
+
+/**
+ * rtk_hsotg_read_frameno - read current frame number
+ * @hsotg: The device instance
+ *
+ * Return the current frame number
+ */
+static u32 rtk_hsotg_read_frameno(struct rtk_hsotg *hsotg)
+{
+	u32 dsts;
+
+	dsts = readl(hsotg->regs + DSTS);
+	dsts &= DSTS_SOFFN_MASK;
+	dsts >>= DSTS_SOFFN_SHIFT;
+
+	return dsts;
+}
+
+/**
+ * rtk_hsotg_handle_rx - RX FIFO has data
+ * @hsotg: The device instance
+ *
+ * The IRQ handler has detected that the RX FIFO has some data in it
+ * that requires processing, so find out what is in there and do the
+ * appropriate read.
+ *
+ * The RXFIFO is a true FIFO, the packets coming out are still in packet
+ * chunks, so if you have x packets received on an endpoint you'll get x
+ * FIFO events delivered, each with a packet's worth of data in it.
+ *
+ * When using DMA, we should not be processing events from the RXFIFO
+ * as the actual data should be sent to the memory directly and we turn
+ * on the completion interrupts to get notifications of transfer completion.
+ */
+static void rtk_hsotg_handle_rx(struct rtk_hsotg *hsotg)
+{
+	u32 grxstsr = readl(hsotg->regs + GRXSTSP);
+	u32 epnum, status, size;
+
+	WARN_ON(using_dma(hsotg));
+
+	epnum = grxstsr & GRXSTS_EPNum_MASK;
+	status = grxstsr & GRXSTS_PktSts_MASK;
+
+	size = grxstsr & GRXSTS_ByteCnt_MASK;
+	size >>= GRXSTS_ByteCnt_SHIFT;
+
+	if (1)
+		dev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
+			__func__, grxstsr, size, epnum);
+
+#define __status(x) ((x) >> GRXSTS_PktSts_SHIFT)
+
+	switch (status >> GRXSTS_PktSts_SHIFT) {
+	case __status(GRXSTS_PktSts_GlobalOutNAK):
+		dev_dbg(hsotg->dev, "GlobalOutNAK\n");
+		break;
+
+	case __status(GRXSTS_PktSts_OutDone):
+		dev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",
+			rtk_hsotg_read_frameno(hsotg));
+
+		if (!using_dma(hsotg))
+			rtk_hsotg_handle_outdone(hsotg, epnum, false);
+		break;
+
+	case __status(GRXSTS_PktSts_SetupDone):
+		dev_dbg(hsotg->dev,
+			"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
+			rtk_hsotg_read_frameno(hsotg),
+			readl(hsotg->regs + DOEPCTL(0)));
+
+		rtk_hsotg_handle_outdone(hsotg, epnum, true);
+		break;
+
+	case __status(GRXSTS_PktSts_OutRX):
+		rtk_hsotg_rx_data(hsotg, epnum, size);
+		break;
+
+	case __status(GRXSTS_PktSts_SetupRX):
+		dev_dbg(hsotg->dev,
+			"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
+			rtk_hsotg_read_frameno(hsotg),
+			readl(hsotg->regs + DOEPCTL(0)));
+
+		rtk_hsotg_rx_data(hsotg, epnum, size);
+		break;
+
+	default:
+		dev_warn(hsotg->dev, "%s: unknown status %08x\n",
+			 __func__, grxstsr);
+
+		rtk_hsotg_dump(hsotg);
+		break;
+	}
+}
+
+/**
+ * rtk_hsotg_ep0_mps - turn max packet size into register setting
+ * @mps: The maximum packet size in bytes.
+ */
+static u32 rtk_hsotg_ep0_mps(unsigned int mps)
+{
+	switch (mps) {
+	case 64:
+		return D0EPCTL_MPS_64;
+	case 32:
+		return D0EPCTL_MPS_32;
+	case 16:
+		return D0EPCTL_MPS_16;
+	case 8:
+		return D0EPCTL_MPS_8;
+	}
+
+	/* bad max packet size, warn and return invalid result */
+	WARN_ON(1);
+	return (u32)-1;
+}
+
+/**
+ * rtk_hsotg_set_ep_maxpacket - set endpoint's max-packet field
+ * @hsotg: The driver state.
+ * @ep: The index number of the endpoint
+ * @mps: The maximum packet size in bytes
+ *
+ * Configure the maximum packet size for the given endpoint, updating
+ * the hardware control registers to reflect this.
+ */
+static void rtk_hsotg_set_ep_maxpacket(struct rtk_hsotg *hsotg,
+				       unsigned int ep, unsigned int mps)
+{
+	struct rtk_hsotg_ep *hs_ep = &hsotg->eps[ep];
+	void __iomem *regs = hsotg->regs;
+	u32 mpsval;
+	u32 mcval;
+	u32 reg;
+
+	if (ep == 0) {
+		/* EP0 is a special case */
+		mpsval = rtk_hsotg_ep0_mps(mps);
+		if (mpsval > 3)
+			goto bad_mps;
+		hs_ep->ep.maxpacket = mps;
+		hs_ep->mc = 1;
+	} else {
+		mpsval = mps & DxEPCTL_MPS_MASK;
+		if (mpsval > 1024)
+			goto bad_mps;
+		mcval = ((mps >> 11) & 0x3) + 1;
+		hs_ep->mc = mcval;
+		if (mcval > 3)
+			goto bad_mps;
+		hs_ep->ep.maxpacket = mpsval;
+	}
+
+	/*
+	 * update both the in and out endpoint controldir_ registers, even
+	 * if one of the directions may not be in use.
+	 */
+
+	reg = readl(regs + DIEPCTL(ep));
+	reg &= ~DxEPCTL_MPS_MASK;
+	reg |= mpsval;
+	writel(reg, regs + DIEPCTL(ep));
+
+	if (ep) {
+		reg = readl(regs + DOEPCTL(ep));
+		reg &= ~DxEPCTL_MPS_MASK;
+		reg |= mpsval;
+		writel(reg, regs + DOEPCTL(ep));
+	}
+
+	return;
+
+bad_mps:
+	dev_err(hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);
+}
+
+/**
+ * rtk_hsotg_txfifo_flush - flush Tx FIFO
+ * @hsotg: The driver state
+ * @idx: The index for the endpoint (0..15)
+ */
+static void rtk_hsotg_txfifo_flush(struct rtk_hsotg *hsotg, unsigned int idx)
+{
+	int timeout;
+	int val;
+
+	writel(GRSTCTL_TxFNum(idx) | GRSTCTL_TxFFlsh,
+		hsotg->regs + GRSTCTL);
+
+	/* wait until the fifo is flushed */
+	timeout = 100;
+
+	while (1) {
+		val = readl(hsotg->regs + GRSTCTL);
+
+		if ((val & (GRSTCTL_TxFFlsh)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			dev_err(hsotg->dev,
+				"%s: timeout flushing fifo (GRSTCTL=%08x)\n",
+				__func__, val);
+		}
+
+		udelay(1);
+	}
+}
+
+/**
+ * rtk_hsotg_trytx - check to see if anything needs transmitting
+ * @hsotg: The driver state
+ * @hs_ep: The driver endpoint to check.
+ *
+ * Check to see if there is a request that has data to send, and if so
+ * make an attempt to write data into the FIFO.
+ */
+static int rtk_hsotg_trytx(struct rtk_hsotg *hsotg,
+			   struct rtk_hsotg_ep *hs_ep)
+{
+	struct rtk_hsotg_req *hs_req = hs_ep->req;
+
+	if (!hs_ep->dir_in || !hs_req) {
+		/**
+		 * if request is not enqueued, we disable interrupts
+		 * for endpoints, excepting ep0
+		 */
+		if (hs_ep->index != 0)
+			rtk_hsotg_ctrl_epint(hsotg, hs_ep->index,
+					     hs_ep->dir_in, 0);
+		return 0;
+	}
+
+	if (hs_req->req.actual < hs_req->req.length) {
+		dev_dbg(hsotg->dev, "trying to write more for ep%d\n",
+			hs_ep->index);
+		return rtk_hsotg_write_fifo(hsotg, hs_ep, hs_req);
+	}
+
+	return 0;
+}
+
+/**
+ * rtk_hsotg_complete_in - complete IN transfer
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint that has just completed.
+ *
+ * An IN transfer has been completed, update the transfer's state and then
+ * call the relevant completion routines.
+ */
+static void rtk_hsotg_complete_in(struct rtk_hsotg *hsotg,
+				  struct rtk_hsotg_ep *hs_ep)
+{
+	struct rtk_hsotg_req *hs_req = hs_ep->req;
+	u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
+	int size_left, size_done;
+
+	if (!hs_req) {
+		dev_dbg(hsotg->dev, "XferCompl but no req\n");
+		return;
+	}
+
+	/* Finish ZLP handling for IN EP0 transactions */
+	if (hsotg->eps[0].sent_zlp) {
+		dev_dbg(hsotg->dev, "zlp packet received\n");
+		rtk_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+		return;
+	}
+
+	/*
+	 * Calculate the size of the transfer by checking how much is left
+	 * in the endpoint size register and then working it out from
+	 * the amount we loaded for the transfer.
+	 *
+	 * We do this even for DMA, as the transfer may have incremented
+	 * past the end of the buffer (DMA transfers are always 32bit
+	 * aligned).
+	 */
+
+	size_left = DxEPTSIZ_XferSize_GET(epsize);
+
+	size_done = hs_ep->size_loaded - size_left;
+	size_done += hs_ep->last_load;
+
+	if (hs_req->req.actual != size_done)
+		dev_dbg(hsotg->dev, "%s: adjusting size done %d => %d\n",
+			__func__, hs_req->req.actual, size_done);
+
+	hs_req->req.actual = size_done;
+	dev_dbg(hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",
+		hs_req->req.length, hs_req->req.actual, hs_req->req.zero);
+
+	/*
+	 * Check if dealing with Maximum Packet Size(MPS) IN transfer at EP0
+	 * When sent data is a multiple MPS size (e.g. 64B ,128B ,192B
+	 * ,256B ... ), after last MPS sized packet send IN ZLP packet to
+	 * inform the host that no more data is available.
+	 * The state of req.zero member is checked to be sure that the value to
+	 * send is smaller than wValue expected from host.
+	 * Check req.length to NOT send another ZLP when the current one is
+	 * under completion (the one for which this completion has been called).
+	 */
+	if (hs_req->req.length && hs_ep->index == 0 && hs_req->req.zero &&
+	    hs_req->req.length == hs_req->req.actual &&
+	    !(hs_req->req.length % hs_ep->ep.maxpacket)) {
+
+		dev_dbg(hsotg->dev, "ep0 zlp IN packet sent\n");
+		rtk_hsotg_send_zlp(hsotg, hs_req);
+
+		return;
+	}
+
+	if (!size_left && hs_req->req.actual < hs_req->req.length) {
+		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
+		rtk_hsotg_start_req(hsotg, hs_ep, hs_req, true);
+	} else
+		rtk_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
+}
+
+/**
+ * rtk_hsotg_epint - handle an in/out endpoint interrupt
+ * @hsotg: The driver state
+ * @idx: The index for the endpoint (0..15)
+ * @dir_in: Set if this is an IN endpoint
+ *
+ * Process and clear any interrupt pending for an individual endpoint
+ */
+static void rtk_hsotg_epint(struct rtk_hsotg *hsotg, unsigned int idx,
+			    int dir_in)
+{
+	struct rtk_hsotg_ep *hs_ep = &hsotg->eps[idx];
+	u32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);
+	u32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);
+	u32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);
+	u32 ints;
+	u32 ctrl;
+
+	ints = readl(hsotg->regs + epint_reg);
+	ctrl = readl(hsotg->regs + epctl_reg);
+
+	/* Clear endpoint interrupts */
+	writel(ints, hsotg->regs + epint_reg);
+
+	dev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
+		__func__, idx, dir_in ? "in" : "out", ints);
+
+	if (ints & DxEPINT_XferCompl) {
+		if (hs_ep->isochronous && hs_ep->interval == 1) {
+			if (ctrl & DxEPCTL_EOFrNum)
+				ctrl |= DxEPCTL_SetEvenFr;
+			else
+				ctrl |= DxEPCTL_SetOddFr;
+			writel(ctrl, hsotg->regs + epctl_reg);
+		}
+
+		dev_dbg(hsotg->dev,
+			"%s: XferCompl: DxEPCTL=0x%08x, DxEPTSIZ=%08x\n",
+			__func__, readl(hsotg->regs + epctl_reg),
+			readl(hsotg->regs + epsiz_reg));
+
+		/*
+		 * we get OutDone from the FIFO, so we only need to look
+		 * at completing IN requests here
+		 */
+		if (dir_in) {
+			rtk_hsotg_complete_in(hsotg, hs_ep);
+
+			if (idx == 0 && !hs_ep->req)
+				rtk_hsotg_enqueue_setup(hsotg);
+		} else if (using_dma(hsotg)) {
+			/*
+			 * We're using DMA, we need to fire an OutDone here
+			 * as we ignore the RXFIFO.
+			 */
+
+			rtk_hsotg_handle_outdone(hsotg, idx, false);
+		}
+	}
+
+	if (ints & DxEPINT_EPDisbld) {
+		dev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);
+
+		if (dir_in) {
+			int epctl = readl(hsotg->regs + epctl_reg);
+
+			rtk_hsotg_txfifo_flush(hsotg, idx);
+
+			if ((epctl & DxEPCTL_Stall) &&
+				(epctl & DxEPCTL_EPType_Bulk)) {
+				int dctl = readl(hsotg->regs + DCTL);
+
+				dctl |= DCTL_CGNPInNAK;
+				writel(dctl, hsotg->regs + DCTL);
+			}
+		}
+	}
+
+	if (ints & DxEPINT_AHBErr)
+		dev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);
+
+	if (ints & DxEPINT_Setup) {  /* Setup or Timeout */
+		dev_dbg(hsotg->dev, "%s: Setup/Timeout\n",  __func__);
+
+		if (using_dma(hsotg) && idx == 0) {
+			/*
+			 * this is the notification we've received a
+			 * setup packet. In non-DMA mode we'd get this
+			 * from the RXFIFO, instead we need to process
+			 * the setup here.
+			 */
+
+			if (dir_in)
+				WARN_ON_ONCE(1);
+			else
+				rtk_hsotg_handle_outdone(hsotg, 0, true);
+		}
+	}
+
+	if (ints & DxEPINT_Back2BackSetup)
+		dev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);
+
+	if (dir_in && !hs_ep->isochronous) {
+		/* not sure if this is important, but we'll clear it anyway */
+		if (ints & DIEPMSK_INTknTXFEmpMsk) {
+			dev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",
+				__func__, idx);
+		}
+
+		/* this probably means something bad is happening */
+		if (ints & DIEPMSK_INTknEPMisMsk) {
+			dev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",
+				 __func__, idx);
+		}
+
+		/* FIFO has space or is empty (see GAHBCFG) */
+		if (hsotg->dedicated_fifos &&
+		    ints & DIEPMSK_TxFIFOEmpty) {
+			dev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",
+				__func__, idx);
+			if (!using_dma(hsotg))
+				rtk_hsotg_trytx(hsotg, hs_ep);
+		}
+	}
+}
+
+/**
+ * rtk_hsotg_irq_enumdone - Handle EnumDone interrupt (enumeration done)
+ * @hsotg: The device state.
+ *
+ * Handle updating the device settings after the enumeration phase has
+ * been completed.
+ */
+static void rtk_hsotg_irq_enumdone(struct rtk_hsotg *hsotg)
+{
+	u32 dsts = readl(hsotg->regs + DSTS);
+	int ep0_mps = 0, ep_mps;
+
+	/*
+	 * This should signal the finish of the enumeration phase
+	 * of the USB handshaking, so we should now know what rate
+	 * we connected at.
+	 */
+
+	dev_dbg(hsotg->dev, "EnumDone (DSTS=0x%08x)\n", dsts);
+
+	/*
+	 * note, since we're limited by the size of transfer on EP0, and
+	 * it seems IN transfers must be a even number of packets we do
+	 * not advertise a 64byte MPS on EP0.
+	 */
+
+	/* catch both EnumSpd_FS and EnumSpd_FS48 */
+	switch (dsts & DSTS_EnumSpd_MASK) {
+	case DSTS_EnumSpd_FS:
+	case DSTS_EnumSpd_FS48:
+		hsotg->gadget.speed = USB_SPEED_FULL;
+		ep0_mps = EP0_MPS_LIMIT;
+		ep_mps = 1023;
+	//	ep_mps = 64;	//barry
+		break;
+
+	case DSTS_EnumSpd_HS:
+		hsotg->gadget.speed = USB_SPEED_HIGH;
+		ep0_mps = EP0_MPS_LIMIT;
+		ep_mps = 1024;
+	//	ep_mps = 512;	//barry
+		break;
+
+	case DSTS_EnumSpd_LS:
+		hsotg->gadget.speed = USB_SPEED_LOW;
+		/*
+		 * note, we don't actually support LS in this driver at the
+		 * moment, and the documentation seems to imply that it isn't
+		 * supported by the PHYs on some of the devices.
+		 */
+		break;
+	}
+	dev_info(hsotg->dev, "new device is %s\n",
+		 usb_speed_string(hsotg->gadget.speed));
+
+	/*
+	 * we should now know the maximum packet size for an
+	 * endpoint, so set the endpoints to a default value.
+	 */
+
+	if (ep0_mps) {
+		int i;
+		rtk_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps);
+		for (i = 1; i < hsotg->num_of_eps; i++)
+			rtk_hsotg_set_ep_maxpacket(hsotg, i, ep_mps);
+	}
+
+	/* ensure after enumeration our EP0 is active */
+
+	rtk_hsotg_enqueue_setup(hsotg);
+
+	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(hsotg->regs + DIEPCTL0),
+		readl(hsotg->regs + DOEPCTL0));
+}
+
+/**
+ * kill_all_requests - remove all requests from the endpoint's queue
+ * @hsotg: The device state.
+ * @ep: The endpoint the requests may be on.
+ * @result: The result code to use.
+ * @force: Force removal of any current requests
+ *
+ * Go through the requests on the given endpoint and mark them
+ * completed with the given result code.
+ */
+static void kill_all_requests(struct rtk_hsotg *hsotg,
+			      struct rtk_hsotg_ep *ep,
+			      int result, bool force)
+{
+	struct rtk_hsotg_req *req, *treq;
+
+	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
+		/*
+		 * currently, we can't do much about an already
+		 * running request on an in endpoint
+		 */
+
+		if (ep->req == req && ep->dir_in && !force)
+			continue;
+
+		rtk_hsotg_complete_request(hsotg, ep, req,
+					   result);
+	}
+	if(hsotg->dedicated_fifos)
+		if ((readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4 < 3072)
+			rtk_hsotg_txfifo_flush(hsotg, ep->index);
+}
+
+#define call_gadget(_hs, _entry) \
+do { \
+	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN &&	\
+	    (_hs)->driver && (_hs)->driver->_entry) { \
+		spin_unlock(&_hs->lock); \
+		(_hs)->driver->_entry(&(_hs)->gadget); \
+		spin_lock(&_hs->lock); \
+	} \
+} while (0)
+
+/**
+ * rtk_hsotg_disconnect - disconnect service
+ * @hsotg: The device state.
+ *
+ * The device has been disconnected. Remove all current
+ * transactions and signal the gadget driver that this
+ * has happened.
+ */
+static void rtk_hsotg_disconnect(struct rtk_hsotg *hsotg)
+{
+	unsigned ep;
+
+	for (ep = 0; ep < hsotg->num_of_eps; ep++)
+		kill_all_requests(hsotg, &hsotg->eps[ep], -ESHUTDOWN, true);
+
+	call_gadget(hsotg, disconnect);
+}
+
+/**
+ * rtk_hsotg_irq_fifoempty - TX FIFO empty interrupt handler
+ * @hsotg: The device state:
+ * @periodic: True if this is a periodic FIFO interrupt
+ */
+static void rtk_hsotg_irq_fifoempty(struct rtk_hsotg *hsotg, bool periodic)
+{
+	struct rtk_hsotg_ep *ep;
+	int epno, ret;
+
+	/* look through for any more data to transmit */
+
+	for (epno = 0; epno < hsotg->num_of_eps; epno++) {
+		ep = &hsotg->eps[epno];
+
+		if (!ep->dir_in)
+			continue;
+
+		if ((periodic && !ep->periodic) ||
+		    (!periodic && ep->periodic))
+			continue;
+
+		ret = rtk_hsotg_trytx(hsotg, ep);
+		if (ret < 0)
+			break;
+	}
+}
+
+/* IRQ flags which will trigger a retry around the IRQ loop */
+#define IRQ_RETRY_MASK (GINTSTS_NPTxFEmp | \
+			GINTSTS_PTxFEmp |  \
+			GINTSTS_RxFLvl)
+
+/**
+ * rtk_hsotg_corereset - issue softreset to the core
+ * @hsotg: The device state
+ *
+ * Issue a soft reset to the core, and await the core finishing it.
+ */
+static int rtk_hsotg_corereset(struct rtk_hsotg *hsotg)
+{
+	int timeout;
+	u32 grstctl;
+
+	dev_dbg(hsotg->dev, "resetting core\n");
+
+	/* issue soft reset */
+	writel(GRSTCTL_CSftRst, hsotg->regs + GRSTCTL);
+
+	timeout = 10000;
+	do {
+		grstctl = readl(hsotg->regs + GRSTCTL);
+	} while ((grstctl & GRSTCTL_CSftRst) && timeout-- > 0);
+
+	if (grstctl & GRSTCTL_CSftRst) {
+		dev_err(hsotg->dev, "Failed to get CSftRst asserted\n");
+		return -EINVAL;
+	}
+
+	timeout = 10000;
+
+	while (1) {
+		u32 grstctl = readl(hsotg->regs + GRSTCTL);
+
+		if (timeout-- < 0) {
+			dev_info(hsotg->dev,
+				 "%s: reset failed, GRSTCTL=%08x\n",
+				 __func__, grstctl);
+			return -ETIMEDOUT;
+		}
+
+		if (!(grstctl & GRSTCTL_AHBIdle))
+			continue;
+
+		break;		/* reset done */
+	}
+
+	dev_dbg(hsotg->dev, "reset successful\n");
+	return 0;
+}
+
+/**
+ * rtk_hsotg_core_init - issue softreset to the core
+ * @hsotg: The device state
+ *
+ * Issue a soft reset to the core, and await the core finishing it.
+ */
+static void rtk_hsotg_core_init(struct rtk_hsotg *hsotg)
+{
+	rtk_hsotg_corereset(hsotg);
+
+	/*
+	 * we must now enable ep0 ready for host detection and then
+	 * set configuration.
+	 */
+
+	/* set the PLL on, remove the HNP/SRP and set the PHY */
+	writel(hsotg->phyif | GUSBCFG_TOutCal(7) |
+	       (0x5 << 10), hsotg->regs + GUSBCFG);
+	mdelay(100);
+
+	rtk_hsotg_init_fifo(hsotg);
+
+	__orr32(hsotg->regs + DCTL, DCTL_SftDiscon);
+
+	writel(1 << 18 | DCFG_DevSpd_HS,  hsotg->regs + DCFG);
+
+	/* Clear any pending OTG interrupts */
+	writel(0xffffffff, hsotg->regs + GOTGINT);
+
+	/* Clear any pending interrupts */
+	writel(0xffffffff, hsotg->regs + GINTSTS);
+
+	writel(GINTSTS_ErlySusp | GINTSTS_SessReqInt |
+	       GINTSTS_GOUTNakEff | GINTSTS_GINNakEff |
+	       GINTSTS_ConIDStsChng | GINTSTS_USBRst |
+	       GINTSTS_EnumDone | GINTSTS_OTGInt |
+	       GINTSTS_USBSusp | GINTSTS_WkUpInt,
+	       hsotg->regs + GINTMSK);
+
+	if (using_dma(hsotg))
+		writel(GAHBCFG_GlblIntrEn | GAHBCFG_DMAEn |
+		       GAHBCFG_HBstLen_Incr4,
+		       hsotg->regs + GAHBCFG);
+	else
+		writel(((hsotg->dedicated_fifos) ? (GAHBCFG_NPTxFEmpLvl |
+						    GAHBCFG_PTxFEmpLvl) : 0) |
+		       GAHBCFG_GlblIntrEn,
+		       hsotg->regs + GAHBCFG);
+
+	/*
+	 * If INTknTXFEmpMsk is enabled, it's important to disable ep interrupts
+	 * when we have no data to transfer. Otherwise we get being flooded by
+	 * interrupts.
+	 */
+
+	writel(((hsotg->dedicated_fifos) ? DIEPMSK_TxFIFOEmpty |
+	       DIEPMSK_INTknTXFEmpMsk : 0) |
+	       DIEPMSK_EPDisbldMsk | DIEPMSK_XferComplMsk |
+	       DIEPMSK_TimeOUTMsk | DIEPMSK_AHBErrMsk |
+	       DIEPMSK_INTknEPMisMsk,
+	       hsotg->regs + DIEPMSK);
+
+	/*
+	 * don't need XferCompl, we get that from RXFIFO in slave mode. In
+	 * DMA mode we may need this.
+	 */
+	writel((using_dma(hsotg) ? (DIEPMSK_XferComplMsk |
+				    DIEPMSK_TimeOUTMsk) : 0) |
+	       DOEPMSK_EPDisbldMsk | DOEPMSK_AHBErrMsk |
+	       DOEPMSK_SetupMsk,
+	       hsotg->regs + DOEPMSK);
+
+	writel(0, hsotg->regs + DAINTMSK);
+
+	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(hsotg->regs + DIEPCTL0),
+		readl(hsotg->regs + DOEPCTL0));
+
+	/* enable in and out endpoint interrupts */
+	rtk_hsotg_en_gsint(hsotg, GINTSTS_OEPInt | GINTSTS_IEPInt);
+
+	/*
+	 * Enable the RXFIFO when in slave mode, as this is how we collect
+	 * the data. In DMA mode, we get events from the FIFO but also
+	 * things we cannot process, so do not use it.
+	 */
+	if (!using_dma(hsotg))
+		rtk_hsotg_en_gsint(hsotg, GINTSTS_RxFLvl);
+
+	/* Enable interrupts for EP0 in and out */
+	rtk_hsotg_ctrl_epint(hsotg, 0, 0, 1);
+	rtk_hsotg_ctrl_epint(hsotg, 0, 1, 1);
+
+	__orr32(hsotg->regs + DCTL, DCTL_PWROnPrgDone);
+	udelay(10);  /* see openiboot */
+	__bic32(hsotg->regs + DCTL, DCTL_PWROnPrgDone);
+
+	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + DCTL));
+
+	/*
+	 * DxEPCTL_USBActEp says RO in manual, but seems to be set by
+	 * writing to the EPCTL register..
+	 */
+
+	/* set to read 1 8byte packet */
+	writel(DxEPTSIZ_MC(1) | DxEPTSIZ_PktCnt(1) |
+	       DxEPTSIZ_XferSize(8), hsotg->regs + DOEPTSIZ0);
+
+	writel(rtk_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
+	       DxEPCTL_CNAK | DxEPCTL_EPEna |
+	       DxEPCTL_USBActEp,
+	       hsotg->regs + DOEPCTL0);
+
+	/* enable, but don't activate EP0in */
+	writel(rtk_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
+	       DxEPCTL_USBActEp, hsotg->regs + DIEPCTL0);
+
+	rtk_hsotg_enqueue_setup(hsotg);
+
+	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(hsotg->regs + DIEPCTL0),
+		readl(hsotg->regs + DOEPCTL0));
+
+	/* clear global NAKs */
+	writel(DCTL_CGOUTNak | DCTL_CGNPInNAK,
+	       hsotg->regs + DCTL);
+
+	/* must be at-least 3ms to allow bus to see disconnect */
+	mdelay(3);
+
+	/* remove the soft-disconnect and let's go */
+	__bic32(hsotg->regs + DCTL, DCTL_SftDiscon);
+}
+
+/**
+ * rtk_hsotg_irq - handle device interrupt
+ * @irq: The IRQ number triggered
+ * @pw: The pw value when registered the handler.
+ */
+static irqreturn_t rtk_hsotg_irq(int irq, void *pw)
+{
+	struct rtk_hsotg *hsotg = pw;
+	int retry_count = 8;
+	u32 gintsts;
+	u32 gintmsk;
+
+	spin_lock(&hsotg->lock);
+irq_retry:
+	gintsts = readl(hsotg->regs + GINTSTS);
+	gintmsk = readl(hsotg->regs + GINTMSK);
+
+	dev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",
+		__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);
+
+	gintsts &= gintmsk;
+
+	if (gintsts & GINTSTS_OTGInt) {
+		u32 otgint = readl(hsotg->regs + GOTGINT);
+
+		dev_info(hsotg->dev, "OTGInt: %08x\n", otgint);
+
+		writel(otgint, hsotg->regs + GOTGINT);
+	}
+
+	if (gintsts & GINTSTS_SessReqInt) {
+		dev_dbg(hsotg->dev, "%s: SessReqInt\n", __func__);
+		writel(GINTSTS_SessReqInt, hsotg->regs + GINTSTS);
+	}
+
+	if (gintsts & GINTSTS_EnumDone) {
+		writel(GINTSTS_EnumDone, hsotg->regs + GINTSTS);
+
+		rtk_hsotg_irq_enumdone(hsotg);
+	}
+
+	if (gintsts & GINTSTS_ConIDStsChng) {
+		dev_dbg(hsotg->dev, "ConIDStsChg (DSTS=0x%08x, GOTCTL=%08x)\n",
+			readl(hsotg->regs + DSTS),
+			readl(hsotg->regs + GOTGCTL));
+
+		writel(GINTSTS_ConIDStsChng, hsotg->regs + GINTSTS);
+	}
+
+	if (gintsts & (GINTSTS_OEPInt | GINTSTS_IEPInt)) {
+		u32 daint = readl(hsotg->regs + DAINT);
+		u32 daintmsk = readl(hsotg->regs + DAINTMSK);
+		u32 daint_out, daint_in;
+		int ep;
+
+		daint &= daintmsk;
+		daint_out = daint >> DAINT_OutEP_SHIFT;
+		daint_in = daint & ~(daint_out << DAINT_OutEP_SHIFT);
+
+		dev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);
+
+		for (ep = 0; ep < 15 && daint_out; ep++, daint_out >>= 1) {
+			if (daint_out & 1)
+				rtk_hsotg_epint(hsotg, ep, 0);
+		}
+
+		for (ep = 0; ep < 15 && daint_in; ep++, daint_in >>= 1) {
+			if (daint_in & 1)
+				rtk_hsotg_epint(hsotg, ep, 1);
+		}
+	}
+
+	if (gintsts & GINTSTS_USBRst) {
+
+		u32 usb_status = readl(hsotg->regs + GOTGCTL);
+
+		dev_info(hsotg->dev, "%s: USBRst\n", __func__);
+		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
+			readl(hsotg->regs + GNPTXSTS));
+
+		writel(GINTSTS_USBRst, hsotg->regs + GINTSTS);
+
+		if (usb_status & GOTGCTL_BSESVLD) {
+			if (time_after(jiffies, hsotg->last_rst +
+				       msecs_to_jiffies(200))) {
+
+				kill_all_requests(hsotg, &hsotg->eps[0],
+							  -ECONNRESET, true);
+
+				rtk_hsotg_core_init(hsotg);
+				hsotg->last_rst = jiffies;
+			}
+		}
+	}
+
+	/* check both FIFOs */
+
+	if (gintsts & GINTSTS_NPTxFEmp) {
+		dev_dbg(hsotg->dev, "NPTxFEmp\n");
+
+		/*
+		 * Disable the interrupt to stop it happening again
+		 * unless one of these endpoint routines decides that
+		 * it needs re-enabling
+		 */
+
+		rtk_hsotg_disable_gsint(hsotg, GINTSTS_NPTxFEmp);
+		rtk_hsotg_irq_fifoempty(hsotg, false);
+	}
+
+	if (gintsts & GINTSTS_PTxFEmp) {
+		dev_dbg(hsotg->dev, "PTxFEmp\n");
+
+		/* See note in GINTSTS_NPTxFEmp */
+
+		rtk_hsotg_disable_gsint(hsotg, GINTSTS_PTxFEmp);
+		rtk_hsotg_irq_fifoempty(hsotg, true);
+	}
+
+	if (gintsts & GINTSTS_RxFLvl) {
+		/*
+		 * note, since GINTSTS_RxFLvl doubles as FIFO-not-empty,
+		 * we need to retry rtk_hsotg_handle_rx if this is still
+		 * set.
+		 */
+
+		rtk_hsotg_handle_rx(hsotg);
+	}
+
+	if (gintsts & GINTSTS_ModeMis) {
+		dev_warn(hsotg->dev, "warning, mode mismatch triggered\n");
+		writel(GINTSTS_ModeMis, hsotg->regs + GINTSTS);
+	}
+
+	if (gintsts & GINTSTS_USBSusp) {
+		dev_info(hsotg->dev, "GINTSTS_USBSusp\n");
+		writel(GINTSTS_USBSusp, hsotg->regs + GINTSTS);
+
+		call_gadget(hsotg, suspend);
+	}
+
+	if (gintsts & GINTSTS_WkUpInt) {
+		dev_info(hsotg->dev, "GINTSTS_WkUpIn\n");
+		writel(GINTSTS_WkUpInt, hsotg->regs + GINTSTS);
+
+		call_gadget(hsotg, resume);
+	}
+
+	if (gintsts & GINTSTS_ErlySusp) {
+		dev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");
+		writel(GINTSTS_ErlySusp, hsotg->regs + GINTSTS);
+	}
+
+	/*
+	 * these next two seem to crop-up occasionally causing the core
+	 * to shutdown the USB transfer, so try clearing them and logging
+	 * the occurrence.
+	 */
+
+	if (gintsts & GINTSTS_GOUTNakEff) {
+		dev_info(hsotg->dev, "GOUTNakEff triggered\n");
+
+		writel(DCTL_CGOUTNak, hsotg->regs + DCTL);
+
+		rtk_hsotg_dump(hsotg);
+	}
+
+	if (gintsts & GINTSTS_GINNakEff) {
+		dev_info(hsotg->dev, "GINNakEff triggered\n");
+
+		writel(DCTL_CGNPInNAK, hsotg->regs + DCTL);
+
+		rtk_hsotg_dump(hsotg);
+	}
+
+	/*
+	 * if we've had fifo events, we should try and go around the
+	 * loop again to see if there's any point in returning yet.
+	 */
+
+	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
+			goto irq_retry;
+
+	spin_unlock(&hsotg->lock);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * rtk_hsotg_ep_enable - enable the given endpoint
+ * @ep: The USB endpint to configure
+ * @desc: The USB endpoint descriptor to configure with.
+ *
+ * This is called from the USB gadget code's usb_ep_enable().
+ */
+static int rtk_hsotg_ep_enable(struct usb_ep *ep,
+			       const struct usb_endpoint_descriptor *desc)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hsotg = hs_ep->parent;
+	unsigned long flags;
+	int index = hs_ep->index;
+	u32 epctrl_reg;
+	u32 epctrl;
+	u32 mps;
+	int dir_in;
+	int ret = 0;
+
+	dev_dbg(hsotg->dev,
+		"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",
+		__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,
+		desc->wMaxPacketSize, desc->bInterval);
+
+	/* not to be called for EP0 */
+	WARN_ON(index == 0);
+
+	dir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;
+	if (dir_in != hs_ep->dir_in) {
+		dev_err(hsotg->dev, "%s: direction mismatch!\n", __func__);
+		return -EINVAL;
+	}
+
+	mps = usb_endpoint_maxp(desc);
+
+	/* note, we handle this here instead of rtk_hsotg_set_ep_maxpacket */
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+	epctrl = readl(hsotg->regs + epctrl_reg);
+
+	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
+		__func__, epctrl, epctrl_reg);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	epctrl &= ~(DxEPCTL_EPType_MASK | DxEPCTL_MPS_MASK);
+	epctrl |= DxEPCTL_MPS(mps);
+
+	/*
+	 * mark the endpoint as active, otherwise the core may ignore
+	 * transactions entirely for this endpoint
+	 */
+	epctrl |= DxEPCTL_USBActEp;
+
+	/*
+	 * set the NAK status on the endpoint, otherwise we might try and
+	 * do something with data that we've yet got a request to process
+	 * since the RXFIFO will take data for an endpoint even if the
+	 * size register hasn't been set.
+	 */
+
+	epctrl |= DxEPCTL_SNAK;
+
+	/* update the endpoint state */
+	rtk_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps);
+
+	/* default, set to non-periodic */
+	hs_ep->isochronous = 0;
+	hs_ep->periodic = 0;
+	hs_ep->halted = 0;
+	hs_ep->interval = desc->bInterval;
+
+	if (hs_ep->interval > 1 && hs_ep->mc > 1)
+		dev_err(hsotg->dev, "MC > 1 when interval is not 1\n");
+
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_ISOC:
+		epctrl |= DxEPCTL_EPType_Iso;
+		epctrl |= DxEPCTL_SetEvenFr;
+		hs_ep->isochronous = 1;
+		if (dir_in)
+			hs_ep->periodic = 1;
+		break;
+
+	case USB_ENDPOINT_XFER_BULK:
+		epctrl |= DxEPCTL_EPType_Bulk;
+		break;
+
+	case USB_ENDPOINT_XFER_INT:
+		if (dir_in) {
+			/*
+			 * Allocate our TxFNum by simply using the index
+			 * of the endpoint for the moment. We could do
+			 * something better if the host indicates how
+			 * many FIFOs we are expecting to use.
+			 */
+
+			hs_ep->periodic = 1;
+			epctrl |= DxEPCTL_TxFNum(index);
+		}
+
+		epctrl |= DxEPCTL_EPType_Intterupt;
+		break;
+
+	case USB_ENDPOINT_XFER_CONTROL:
+		epctrl |= DxEPCTL_EPType_Control;
+		break;
+	}
+
+	/*
+	 * if the hardware has dedicated fifos, we must give each IN EP
+	 * a unique tx-fifo even if it is non-periodic.
+	 */
+	if (dir_in && hsotg->dedicated_fifos)
+		epctrl |= DxEPCTL_TxFNum(index);
+
+	/* for non control endpoints, set PID to D0 */
+	if (index)
+		epctrl |= DxEPCTL_SetD0PID;
+
+	dev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",
+		__func__, epctrl);
+
+	writel(epctrl, hsotg->regs + epctrl_reg);
+	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",
+		__func__, readl(hsotg->regs + epctrl_reg));
+
+	/* enable the endpoint interrupt */
+	rtk_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return ret;
+}
+
+/**
+ * rtk_hsotg_ep_disable - disable given endpoint
+ * @ep: The endpoint to disable.
+ */
+static int rtk_hsotg_ep_disable(struct usb_ep *ep)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hsotg = hs_ep->parent;
+	int dir_in = hs_ep->dir_in;
+	int index = hs_ep->index;
+	unsigned long flags;
+	u32 epctrl_reg;
+	u32 ctrl;
+
+	dev_info(hsotg->dev, "%s(ep %p)\n", __func__, ep);
+
+	if (ep == &hsotg->eps[0].ep) {
+		dev_err(hsotg->dev, "%s: called for ep0\n", __func__);
+		return -EINVAL;
+	}
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	/* terminate all requests with shutdown */
+	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);
+
+
+	ctrl = readl(hsotg->regs + epctrl_reg);
+	ctrl &= ~DxEPCTL_EPEna;
+	ctrl &= ~DxEPCTL_USBActEp;
+	ctrl |= DxEPCTL_SNAK;
+
+	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
+	writel(ctrl, hsotg->regs + epctrl_reg);
+
+	/* disable endpoint interrupts */
+	rtk_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+	return 0;
+}
+
+/**
+ * on_list - check request is on the given endpoint
+ * @ep: The endpoint to check.
+ * @test: The request to test if it is on the endpoint.
+ */
+static bool on_list(struct rtk_hsotg_ep *ep, struct rtk_hsotg_req *test)
+{
+	struct rtk_hsotg_req *req, *treq;
+
+	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
+		if (req == test)
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * rtk_hsotg_ep_dequeue - dequeue given endpoint
+ * @ep: The endpoint to dequeue.
+ * @req: The request to be removed from a queue.
+ */
+static int rtk_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
+{
+	struct rtk_hsotg_req *hs_req = our_req(req);
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hs = hs_ep->parent;
+	unsigned long flags;
+
+	dev_info(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);
+
+	spin_lock_irqsave(&hs->lock, flags);
+
+	if (!on_list(hs_ep, hs_req)) {
+		spin_unlock_irqrestore(&hs->lock, flags);
+		return -EINVAL;
+	}
+
+	rtk_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
+	spin_unlock_irqrestore(&hs->lock, flags);
+
+	return 0;
+}
+
+/**
+ * rtk_hsotg_ep_sethalt - set halt on a given endpoint
+ * @ep: The endpoint to set halt.
+ * @value: Set or unset the halt.
+ */
+static int rtk_hsotg_ep_sethalt(struct usb_ep *ep, int value)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hs = hs_ep->parent;
+	int index = hs_ep->index;
+	u32 epreg;
+	u32 epctl;
+	u32 xfertype;
+
+	dev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);
+
+	if (index == 0) {
+		if (value)
+			rtk_hsotg_stall_ep0(hs);
+		else
+			dev_warn(hs->dev,
+				 "%s: can't clear halt on ep0\n", __func__);
+		return 0;
+	}
+
+	/* write both IN and OUT control registers */
+
+	epreg = DIEPCTL(index);
+	epctl = readl(hs->regs + epreg);
+
+	if (value) {
+		epctl |= DxEPCTL_Stall + DxEPCTL_SNAK;
+		if (epctl & DxEPCTL_EPEna)
+			epctl |= DxEPCTL_EPDis;
+	} else {
+		epctl &= ~DxEPCTL_Stall;
+		xfertype = epctl & DxEPCTL_EPType_MASK;
+		if (xfertype == DxEPCTL_EPType_Bulk ||
+			xfertype == DxEPCTL_EPType_Intterupt)
+				epctl |= DxEPCTL_SetD0PID;
+	}
+
+	writel(epctl, hs->regs + epreg);
+
+	epreg = DOEPCTL(index);
+	epctl = readl(hs->regs + epreg);
+
+	if (value)
+		epctl |= DxEPCTL_Stall;
+	else {
+		epctl &= ~DxEPCTL_Stall;
+		xfertype = epctl & DxEPCTL_EPType_MASK;
+		if (xfertype == DxEPCTL_EPType_Bulk ||
+			xfertype == DxEPCTL_EPType_Intterupt)
+				epctl |= DxEPCTL_SetD0PID;
+	}
+
+	writel(epctl, hs->regs + epreg);
+
+	hs_ep->halted = value;
+
+	return 0;
+}
+
+/**
+ * rtk_hsotg_ep_sethalt_lock - set halt on a given endpoint with lock held
+ * @ep: The endpoint to set halt.
+ * @value: Set or unset the halt.
+ */
+static int rtk_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)
+{
+	struct rtk_hsotg_ep *hs_ep = our_ep(ep);
+	struct rtk_hsotg *hs = hs_ep->parent;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	spin_lock_irqsave(&hs->lock, flags);
+	ret = rtk_hsotg_ep_sethalt(ep, value);
+	spin_unlock_irqrestore(&hs->lock, flags);
+
+	return ret;
+}
+
+static struct usb_ep_ops rtk_hsotg_ep_ops = {
+	.enable		= rtk_hsotg_ep_enable,
+	.disable	= rtk_hsotg_ep_disable,
+	.alloc_request	= rtk_hsotg_ep_alloc_request,
+	.free_request	= rtk_hsotg_ep_free_request,
+	.queue		= rtk_hsotg_ep_queue_lock,
+	.dequeue	= rtk_hsotg_ep_dequeue,
+	.set_halt	= rtk_hsotg_ep_sethalt_lock,
+	/* note, don't believe we have any call for the fifo routines */
+};
+
+/**
+ * rtk_hsotg_phy_enable - enable platform phy dev
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB code
+ */
+static void rtk_hsotg_phy_enable(struct rtk_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+
+	if(hsotg->phyregs) {
+		writel(readl(hsotg->phyregs+0xc)|BIT(0), hsotg->phyregs+0xc);
+		mdelay(100);
+		writel(readl(hsotg->phyregs+0x2c)|BIT(0), hsotg->phyregs+0x2c);
+		mdelay(100);
+		writel(readl(hsotg->phyregs+0x40)|BIT(0), hsotg->phyregs+0x40);
+		writel(readl(hsotg->phyregs+0x44)|0x180, hsotg->phyregs+0x44);
+		mdelay(100);
+	}
+}
+
+/**
+ * rtk_hsotg_phy_disable - disable platform phy dev
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB code
+ */
+static void rtk_hsotg_phy_disable(struct rtk_hsotg *hsotg)
+{
+#if 0	//barry
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+
+	if (hsotg->phy) {
+		phy_power_off(hsotg->phy);
+		phy_exit(hsotg->phy);
+	} else if (hsotg->uphy)
+		usb_phy_shutdown(hsotg->uphy);
+	else if (hsotg->plat->phy_exit)
+		hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);
+#endif
+#ifdef CONFIG_USB_OTG
+	if(hsotg->phyregs)
+		writel(readl(hsotg->phyregs+0x40)&~BIT(0), hsotg->phyregs+0x40);
+#endif
+}
+
+/**
+ * rtk_hsotg_init - initalize the usb core
+ * @hsotg: The driver state
+ */
+static void rtk_hsotg_init(struct rtk_hsotg *hsotg)
+{
+	/* unmask subset of endpoint interrupts */
+
+	writel(DIEPMSK_TimeOUTMsk | DIEPMSK_AHBErrMsk |
+	       DIEPMSK_EPDisbldMsk | DIEPMSK_XferComplMsk,
+	       hsotg->regs + DIEPMSK);
+
+	writel(DOEPMSK_SetupMsk | DOEPMSK_AHBErrMsk |
+	       DOEPMSK_EPDisbldMsk | DOEPMSK_XferComplMsk,
+	       hsotg->regs + DOEPMSK);
+
+	writel(0, hsotg->regs + DAINTMSK);
+
+	/* Be in disconnected state until gadget is registered */
+	__orr32(hsotg->regs + DCTL, DCTL_SftDiscon);
+
+	if (0) {
+		/* post global nak until we're ready */
+		writel(DCTL_SGNPInNAK | DCTL_SGOUTNak,
+		       hsotg->regs + DCTL);
+	}
+
+	/* setup fifos */
+
+	dev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
+		readl(hsotg->regs + GRXFSIZ),
+		readl(hsotg->regs + GNPTXFSIZ));
+
+	rtk_hsotg_init_fifo(hsotg);
+
+	/* set the PLL on, remove the HNP/SRP and set the PHY */
+	writel(GUSBCFG_PHYIf16 | GUSBCFG_TOutCal(7) | (0x5 << 10),
+	       hsotg->regs + GUSBCFG);
+//	writel(hsotg->phyif | GUSBCFG_TOutCal(7) | (0x5 << 10),		//barry
+//	       hsotg->regs + GUSBCFG);
+	mdelay(100);
+
+	writel(using_dma(hsotg) ? GAHBCFG_DMAEn : 0x0,
+	       hsotg->regs + GAHBCFG);
+}
+
+/**
+ * rtk_hsotg_udc_start - prepare the udc for work
+ * @gadget: The usb gadget state
+ * @driver: The usb gadget driver
+ *
+ * Perform initialization to prepare udc device and driver
+ * to work.
+ */
+static int rtk_hsotg_udc_start(struct usb_gadget *gadget,
+			   struct usb_gadget_driver *driver)
+{
+	struct rtk_hsotg *hsotg = to_hsotg(gadget);
+	int ret;
+
+	if (!hsotg) {
+		pr_err("%s: called with no device\n", __func__);
+		return -ENODEV;
+	}
+
+	if (!driver) {
+		dev_err(hsotg->dev, "%s: no driver\n", __func__);
+		return -EINVAL;
+	}
+
+	if (driver->max_speed < USB_SPEED_FULL)
+		dev_err(hsotg->dev, "%s: bad speed\n", __func__);
+
+	if (!driver->setup) {
+		dev_err(hsotg->dev, "%s: missing entry points\n", __func__);
+		return -EINVAL;
+	}
+
+	WARN_ON(hsotg->driver);
+
+	driver->driver.bus = NULL;
+	hsotg->driver = driver;
+	hsotg->gadget.dev.of_node = hsotg->dev->of_node;
+	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+#if 0
+	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
+				    hsotg->supplies);
+	if (ret) {
+		dev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);
+		goto err;
+	}
+#endif
+	hsotg->last_rst = jiffies;
+	dev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);
+	return 0;
+
+//err:
+	hsotg->driver = NULL;
+	return ret;
+}
+
+/**
+ * rtk_hsotg_udc_stop - stop the udc
+ * @gadget: The usb gadget state
+ * @driver: The usb gadget driver
+ *
+ * Stop udc hw block and stay tunned for future transmissions
+ */
+static int rtk_hsotg_udc_stop(struct usb_gadget *gadget)
+{
+	struct rtk_hsotg *hsotg = to_hsotg(gadget);
+	unsigned long flags = 0;
+	int ep;
+
+	if (!hsotg)
+		return -ENODEV;
+
+	/* all endpoints should be shutdown */
+	for (ep = 0; ep < hsotg->num_of_eps; ep++)
+		rtk_hsotg_ep_disable(&hsotg->eps[ep].ep);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	rtk_hsotg_phy_disable(hsotg);
+
+	hsotg->driver = NULL;
+
+	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+#if 0
+	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
+#endif
+	return 0;
+}
+
+/**
+ * rtk_hsotg_gadget_getframe - read the frame number
+ * @gadget: The usb gadget state
+ *
+ * Read the {micro} frame number
+ */
+static int rtk_hsotg_gadget_getframe(struct usb_gadget *gadget)
+{
+	return rtk_hsotg_read_frameno(to_hsotg(gadget));
+}
+
+/**
+ * rtk_hsotg_pullup - connect/disconnect the USB PHY
+ * @gadget: The usb gadget state
+ * @is_on: Current state of the USB PHY
+ *
+ * Connect/Disconnect the USB PHY pullup
+ */
+static int rtk_hsotg_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct rtk_hsotg *hsotg = to_hsotg(gadget);
+	unsigned long flags = 0;
+
+	dev_dbg(hsotg->dev, "%s: is_in: %d\n", __func__, is_on);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	if (is_on) {
+		rtk_hsotg_phy_enable(hsotg);
+		rtk_hsotg_core_init(hsotg);
+	} else {
+		rtk_hsotg_disconnect(hsotg);
+		rtk_hsotg_phy_disable(hsotg);
+	}
+
+	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops rtk_hsotg_gadget_ops = {
+	.get_frame	= rtk_hsotg_gadget_getframe,
+	.udc_start		= rtk_hsotg_udc_start,
+	.udc_stop		= rtk_hsotg_udc_stop,
+	.pullup                 = rtk_hsotg_pullup,
+};
+
+/**
+ * rtk_hsotg_initep - initialise a single endpoint
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint to be initialised.
+ * @epnum: The endpoint number
+ *
+ * Initialise the given endpoint (as part of the probe and device state
+ * creation) to give to the gadget driver. Setup the endpoint name, any
+ * direction information and other state that may be required.
+ */
+static void rtk_hsotg_initep(struct rtk_hsotg *hsotg,
+				       struct rtk_hsotg_ep *hs_ep,
+				       int epnum)
+{
+	u32 ptxfifo;
+	char *dir;
+
+	if (epnum == 0)
+		dir = "";
+	else if ((epnum % 2) == 0) {
+		dir = "out";
+	} else {
+		dir = "in";
+		hs_ep->dir_in = 1;
+	}
+
+	hs_ep->index = epnum;
+
+	snprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);
+
+	INIT_LIST_HEAD(&hs_ep->queue);
+	INIT_LIST_HEAD(&hs_ep->ep.ep_list);
+
+	/* add to the list of endpoints known by the gadget driver */
+	if (epnum)
+		list_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);
+
+	hs_ep->parent = hsotg;
+	hs_ep->ep.name = hs_ep->name;
+	usb_ep_set_maxpacket_limit(&hs_ep->ep, epnum ? 1024 : EP0_MPS_LIMIT);
+	hs_ep->ep.ops = &rtk_hsotg_ep_ops;
+
+	/*
+	 * Read the FIFO size for the Periodic TX FIFO, even if we're
+	 * an OUT endpoint, we may as well do this if in future the
+	 * code is changed to make each endpoint's direction changeable.
+	 */
+
+	ptxfifo = readl(hsotg->regs + DPTXFSIZn(epnum));
+	hs_ep->fifo_size = DPTXFSIZn_DPTxFSize_GET(ptxfifo) * 4;
+
+	/*
+	 * if we're using dma, we need to set the next-endpoint pointer
+	 * to be something valid.
+	 */
+
+	if (using_dma(hsotg)) {
+		u32 next = DxEPCTL_NextEp((epnum + 1) % 15);
+		writel(next, hsotg->regs + DIEPCTL(epnum));
+		writel(next, hsotg->regs + DOEPCTL(epnum));
+	}
+}
+
+/**
+ * rtk_hsotg_hw_cfg - read HW configuration registers
+ * @param: The device state
+ *
+ * Read the USB core HW configuration registers
+ */
+static void rtk_hsotg_hw_cfg(struct rtk_hsotg *hsotg)
+{
+	u32 cfg2, cfg4;
+	/* check hardware configuration */
+
+#ifdef CONFIG_USB_OTG
+	hsotg->num_of_eps = 5;
+	hsotg->dedicated_fifos = 0;
+#else
+	cfg2 = readl(hsotg->regs + 0x48);
+	hsotg->num_of_eps = (cfg2 >> 10) & 0xF;
+
+	dev_info(hsotg->dev, "EPs:%d\n", hsotg->num_of_eps);
+
+	cfg4 = readl(hsotg->regs + 0x50);
+	hsotg->dedicated_fifos = (cfg4 >> 25) & 1;
+#endif
+	dev_info(hsotg->dev, "%s fifos\n",
+		 hsotg->dedicated_fifos ? "dedicated" : "shared");
+}
+
+/**
+ * rtk_hsotg_dump - dump state of the udc
+ * @param: The device state
+ */
+static void rtk_hsotg_dump(struct rtk_hsotg *hsotg)
+{
+#ifdef DEBUG
+	struct device *dev = hsotg->dev;
+	void __iomem *regs = hsotg->regs;
+	u32 val;
+	int idx;
+
+	dev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
+		 readl(regs + DCFG), readl(regs + DCTL),
+		 readl(regs + DIEPMSK));
+
+	dev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",
+		 readl(regs + GAHBCFG), readl(regs + 0x44));
+
+	dev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
+		 readl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));
+
+	/* show periodic fifo settings */
+
+	for (idx = 1; idx <= 15; idx++) {
+		val = readl(regs + DPTXFSIZn(idx));
+		dev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
+			 val >> DPTXFSIZn_DPTxFSize_SHIFT,
+			 val & DPTXFSIZn_DPTxFStAddr_MASK);
+	}
+
+	for (idx = 0; idx < 15; idx++) {
+		dev_info(dev,
+			 "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,
+			 readl(regs + DIEPCTL(idx)),
+			 readl(regs + DIEPTSIZ(idx)),
+			 readl(regs + DIEPDMA(idx)));
+
+		val = readl(regs + DOEPCTL(idx));
+		dev_info(dev,
+			 "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
+			 idx, readl(regs + DOEPCTL(idx)),
+			 readl(regs + DOEPTSIZ(idx)),
+			 readl(regs + DOEPDMA(idx)));
+
+	}
+
+	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
+		 readl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));
+#endif
+}
+
+/**
+ * state_show - debugfs: show overall driver and device state.
+ * @seq: The seq file to write to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the overall state of the hardware and
+ * some general information about each of the endpoints available
+ * to the system.
+ */
+static int state_show(struct seq_file *seq, void *v)
+{
+	struct rtk_hsotg *hsotg = seq->private;
+	void __iomem *regs = hsotg->regs;
+	int idx;
+
+	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
+		 readl(regs + DCFG),
+		 readl(regs + DCTL),
+		 readl(regs + DSTS));
+
+	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
+		   readl(regs + DIEPMSK), readl(regs + DOEPMSK));
+
+	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
+		   readl(regs + GINTMSK),
+		   readl(regs + GINTSTS));
+
+	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
+		   readl(regs + DAINTMSK),
+		   readl(regs + DAINT));
+
+	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
+		   readl(regs + GNPTXSTS),
+		   readl(regs + GRXSTSR));
+
+	seq_puts(seq, "\nEndpoint status:\n");
+
+	for (idx = 0; idx < 15; idx++) {
+		u32 in, out;
+
+		in = readl(regs + DIEPCTL(idx));
+		out = readl(regs + DOEPCTL(idx));
+
+		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
+			   idx, in, out);
+
+		in = readl(regs + DIEPTSIZ(idx));
+		out = readl(regs + DOEPTSIZ(idx));
+
+		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
+			   in, out);
+
+		seq_puts(seq, "\n");
+	}
+
+	return 0;
+}
+
+static int state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, state_show, inode->i_private);
+}
+
+static const struct file_operations state_fops = {
+	.owner		= THIS_MODULE,
+	.open		= state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * fifo_show - debugfs: show the fifo information
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * Show the FIFO information for the overall fifo and all the
+ * periodic transmission FIFOs.
+ */
+static int fifo_show(struct seq_file *seq, void *v)
+{
+	struct rtk_hsotg *hsotg = seq->private;
+	void __iomem *regs = hsotg->regs;
+	u32 val;
+	int idx;
+
+	seq_puts(seq, "Non-periodic FIFOs:\n");
+	seq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));
+
+	val = readl(regs + GNPTXFSIZ);
+	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
+		   val >> GNPTXFSIZ_NPTxFDep_SHIFT,
+		   val & GNPTXFSIZ_NPTxFStAddr_MASK);
+
+	seq_puts(seq, "\nPeriodic TXFIFOs:\n");
+
+	for (idx = 1; idx <= 15; idx++) {
+		val = readl(regs + DPTXFSIZn(idx));
+
+		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
+			   val >> DPTXFSIZn_DPTxFSize_SHIFT,
+			   val & DPTXFSIZn_DPTxFStAddr_MASK);
+	}
+
+	return 0;
+}
+
+static int fifo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fifo_show, inode->i_private);
+}
+
+static const struct file_operations fifo_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fifo_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+static const char *decode_direction(int is_in)
+{
+	return is_in ? "in" : "out";
+}
+
+/**
+ * ep_show - debugfs: show the state of an endpoint.
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the state of the given endpoint (one is
+ * registered for each available).
+ */
+static int ep_show(struct seq_file *seq, void *v)
+{
+	struct rtk_hsotg_ep *ep = seq->private;
+	struct rtk_hsotg *hsotg = ep->parent;
+	struct rtk_hsotg_req *req;
+	void __iomem *regs = hsotg->regs;
+	int index = ep->index;
+	int show_limit = 15;
+	unsigned long flags;
+
+	seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n",
+		   ep->index, ep->ep.name, decode_direction(ep->dir_in));
+
+	/* first show the register state */
+
+	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
+		   readl(regs + DIEPCTL(index)),
+		   readl(regs + DOEPCTL(index)));
+
+	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
+		   readl(regs + DIEPDMA(index)),
+		   readl(regs + DOEPDMA(index)));
+
+	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
+		   readl(regs + DIEPINT(index)),
+		   readl(regs + DOEPINT(index)));
+
+	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
+		   readl(regs + DIEPTSIZ(index)),
+		   readl(regs + DOEPTSIZ(index)));
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
+	seq_printf(seq, "total_data=%ld\n", ep->total_data);
+
+	seq_printf(seq, "request list (%p,%p):\n",
+		   ep->queue.next, ep->queue.prev);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (--show_limit < 0) {
+			seq_puts(seq, "not showing more requests...\n");
+			break;
+		}
+
+		seq_printf(seq, "%c req %p: %d bytes @%p, ",
+			   req == ep->req ? '*' : ' ',
+			   req, req->req.length, req->req.buf);
+		seq_printf(seq, "%d done, res %d\n",
+			   req->req.actual, req->req.status);
+	}
+
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return 0;
+}
+
+static int ep_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ep_show, inode->i_private);
+}
+
+static const struct file_operations ep_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ep_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * rtk_hsotg_create_debug - create debugfs directory and files
+ * @hsotg: The driver state
+ *
+ * Create the debugfs files to allow the user to get information
+ * about the state of the system. The directory name is created
+ * with the same name as the device itself, in case we end up
+ * with multiple blocks in future systems.
+ */
+static void rtk_hsotg_create_debug(struct rtk_hsotg *hsotg)
+{
+	struct dentry *root;
+	unsigned epidx;
+
+	root = debugfs_create_dir(dev_name(hsotg->dev), NULL);
+	hsotg->debug_root = root;
+	if (IS_ERR(root)) {
+		dev_err(hsotg->dev, "cannot create debug root\n");
+		return;
+	}
+
+	/* create general state file */
+
+	hsotg->debug_file = debugfs_create_file("state", 0444, root,
+						hsotg, &state_fops);
+
+	if (IS_ERR(hsotg->debug_file))
+		dev_err(hsotg->dev, "%s: failed to create state\n", __func__);
+
+	hsotg->debug_fifo = debugfs_create_file("fifo", 0444, root,
+						hsotg, &fifo_fops);
+
+	if (IS_ERR(hsotg->debug_fifo))
+		dev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);
+
+	/* create one file for each endpoint */
+
+	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
+		struct rtk_hsotg_ep *ep = &hsotg->eps[epidx];
+
+		ep->debugfs = debugfs_create_file(ep->name, 0444,
+						  root, ep, &ep_fops);
+
+		if (IS_ERR(ep->debugfs))
+			dev_err(hsotg->dev, "failed to create %s debug file\n",
+				ep->name);
+	}
+}
+
+/**
+ * rtk_hsotg_delete_debug - cleanup debugfs entries
+ * @hsotg: The driver state
+ *
+ * Cleanup (remove) the debugfs files for use on module exit.
+ */
+static void rtk_hsotg_delete_debug(struct rtk_hsotg *hsotg)
+{
+	unsigned epidx;
+
+	for (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {
+		struct rtk_hsotg_ep *ep = &hsotg->eps[epidx];
+		debugfs_remove(ep->debugfs);
+	}
+
+	debugfs_remove(hsotg->debug_file);
+	debugfs_remove(hsotg->debug_fifo);
+	debugfs_remove(hsotg->debug_root);
+}
+
+#ifdef CONFIG_USB_RTK_UDC_OTG_SWITCH
+static int rtk_hsotg_gadget_suspend(struct platform_device *pdev)
+{
+	struct rtk_hsotg *hsotg = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret = 0;
+
+	if (hsotg->driver)
+		dev_info(hsotg->dev, "suspending usb gadget %s\n",
+			 hsotg->driver->driver.name);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	rtk_hsotg_disconnect(hsotg);
+	rtk_hsotg_phy_disable(hsotg);
+	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	if (hsotg->driver) {
+		int ep;
+		for (ep = 0; ep < hsotg->num_of_eps; ep++)
+			rtk_hsotg_ep_disable(&hsotg->eps[ep].ep);
+	}
+
+	return ret;
+}
+
+static int rtk_hsotg_gadget_resume(struct platform_device *pdev)
+{
+	struct rtk_hsotg *hsotg = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret = 0;
+
+	if (hsotg->driver) {
+		dev_info(hsotg->dev, "resuming usb gadget %s\n",
+			 hsotg->driver->driver.name);
+	}
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	hsotg->last_rst = jiffies;
+	rtk_hsotg_phy_enable(hsotg);
+	rtk_hsotg_core_init(hsotg);
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return ret;
+}
+
+static int switch_to_device_mode(struct rtk_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	return rtk_hsotg_gadget_resume(pdev);
+}
+
+static int switch_to_host_mode(struct rtk_hsotg *hsotg)
+{
+	struct platform_device *pdev = to_platform_device(hsotg->dev);
+	int ret;
+
+	ret = rtk_hsotg_gadget_suspend(pdev);
+
+	if(hsotg->phyregs) {
+		writel(readl(hsotg->phyregs+0xc)|BIT(0), hsotg->phyregs+0xc);
+		mdelay(100);
+		writel(readl(hsotg->phyregs+0x2c)|BIT(0), hsotg->phyregs+0x2c);
+		mdelay(100);
+		writel(readl(hsotg->phyregs+0x40) & ~BIT(0), hsotg->phyregs+0x40);
+		writel(readl(hsotg->phyregs+0x44) & ~0x180, hsotg->phyregs+0x44);
+		mdelay(100);
+	}
+	return ret;
+}
+
+static ssize_t switch_mode_show(struct device *dev, struct device_attribute *attr, char *buffer)
+{
+	struct rtk_hsotg *hsotg = dev_get_drvdata(dev);
+
+	return sprintf(buffer, "%s\n", hsotg->otg_type?"In device mode":"In host mode");
+}
+
+static ssize_t switch_mode_store(struct device *dev, struct device_attribute *attr,
+		const char *buffer, size_t size)
+{
+	struct rtk_hsotg *hsotg = dev_get_drvdata(dev);
+	int ret;
+	char str[8];
+
+	ret = sscanf(buffer, "%7s", str);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (!strcmp(str, "device")) {
+		hsotg->otg_type = RTK_DEVICE_MODE;
+		dev_info(hsotg->dev, "switch to device mode\n");
+		switch_to_device_mode(hsotg);
+	} else if (!strcmp(str, "host")) {
+		hsotg->otg_type = RTK_HOST_MODE;
+		dev_info(hsotg->dev, "switch to host mode\n");
+		switch_to_host_mode(hsotg);
+	} else {
+		dev_err(hsotg->dev, "ERROR switch to %s mode\n", str);
+	}
+	return size;
+}
+
+static DEVICE_ATTR(switch_mode, 0644, switch_mode_show, switch_mode_store);
+
+static const struct attribute *switch_mode_attrs[] = {
+	&dev_attr_switch_mode.attr,
+	NULL
+};
+
+static int rtk_hsotg_create_sysfs_by_otg(struct rtk_hsotg *hsotg)
+{
+	struct device *dev = hsotg->dev;
+	int retval;
+
+	hsotg->otg_type = RTK_DEVICE_MODE;
+
+	retval = sysfs_create_files(&dev->kobj,
+			(const struct attribute **)switch_mode_attrs);
+
+	return retval;
+}
+#endif // CONFIG_USB_RTK_UDC_OTG_SWITCH
+
+/**
+ * rtk_hsotg_probe - probe function for hsotg driver
+ * @pdev: The platform information for the driver
+ */
+static int rtk_hsotg_probe(struct platform_device *pdev)
+{
+	struct rtk_hsotg_plat *plat = dev_get_platdata(&pdev->dev);
+//	struct phy *phy;
+	struct usb_phy *uphy;
+	struct device *dev = &pdev->dev;
+	struct rtk_hsotg_ep *eps;
+	struct rtk_hsotg *hsotg;
+	struct resource *res;
+	int epnum;
+	int ret;
+//	int i;
+
+	hsotg = devm_kzalloc(&pdev->dev, sizeof(struct rtk_hsotg), GFP_KERNEL);
+	if (!hsotg) {
+		dev_err(dev, "cannot get memory\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Attempt to find a generic PHY, then look for an old style
+	 * USB PHY, finally fall back to pdata
+	 */
+	uphy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 0);
+	if (IS_ERR(uphy)) {
+		/* Fallback for pdata */
+		plat = dev_get_platdata(&pdev->dev);
+		if (!plat) {
+			dev_err(&pdev->dev, "no platform data or transceiver defined\n");
+			return -EPROBE_DEFER;
+		}
+		hsotg->plat = plat;
+	} else {
+		hsotg->uphy = uphy;
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		hsotg->phyregs = devm_ioremap(dev, res->start, resource_size(res));
+	}
+
+	hsotg->dev = dev;
+#if 0	//barry
+	hsotg->clk = devm_clk_get(&pdev->dev, "otg");
+	if (IS_ERR(hsotg->clk)) {
+		dev_err(dev, "cannot get otg clock\n");
+		return PTR_ERR(hsotg->clk);
+	}
+#endif
+	platform_set_drvdata(pdev, hsotg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	hsotg->regs = devm_ioremap(dev, res->start, resource_size(res));
+	//hsotg->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hsotg->regs)) {
+		ret = PTR_ERR(hsotg->regs);
+		goto err_clk;
+	}
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0) {
+		dev_err(dev, "cannot find IRQ\n");
+		goto err_clk;
+	}
+
+	spin_lock_init(&hsotg->lock);
+
+	hsotg->irq = ret;
+
+	ret = devm_request_irq(&pdev->dev, hsotg->irq, rtk_hsotg_irq, IRQF_SHARED,
+				dev_name(dev), hsotg);
+	if (ret < 0) {
+		dev_err(dev, "cannot claim IRQ\n");
+		goto err_clk;
+	}
+
+	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
+
+	hsotg->gadget.max_speed = USB_SPEED_HIGH;
+	hsotg->gadget.ops = &rtk_hsotg_gadget_ops;
+	hsotg->gadget.name = dev_name(dev);
+
+	/* reset the system */
+#if 0	//barry
+	clk_prepare_enable(hsotg->clk);
+
+	/* regulators */
+
+	for (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)
+		hsotg->supplies[i].supply = rtk_hsotg_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(hsotg->supplies),
+				 hsotg->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
+				    hsotg->supplies);
+
+	if (ret) {
+		dev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);
+		goto err_supplies;
+	}
+#endif
+	/* Set default UTMI width */
+	//hsotg->phyif = GUSBCFG_PHYIf16;
+	hsotg->phyif = GUSBCFG_PHYIf16|GUSBCFG_FORCEDEVMODE;
+	//hsotg->phyif = GUSBCFG_PHYIf8|GUSBCFG_FORCEDEVMODE;
+
+	/* usb phy enable */
+	//	rtk_usb_phy_init();
+	rtk_hsotg_phy_enable(hsotg);
+	rtk_hsotg_corereset(hsotg);
+	rtk_hsotg_init(hsotg);
+	rtk_hsotg_hw_cfg(hsotg);
+
+	/* hsotg->num_of_eps holds number of EPs other than ep0 */
+
+	if (hsotg->num_of_eps == 0) {
+		dev_err(dev, "wrong number of EPs (zero)\n");
+		ret = -EINVAL;
+		goto err_supplies;
+	}
+
+	eps = kcalloc(hsotg->num_of_eps + 1, sizeof(struct rtk_hsotg_ep),
+		      GFP_KERNEL);
+	if (!eps) {
+		dev_err(dev, "cannot get memory\n");
+		ret = -ENOMEM;
+		goto err_supplies;
+	}
+
+	hsotg->eps = eps;
+
+	/* setup endpoint information */
+
+	INIT_LIST_HEAD(&hsotg->gadget.ep_list);
+	hsotg->gadget.ep0 = &hsotg->eps[0].ep;
+
+	/* allocate EP0 request */
+
+	hsotg->ctrl_req = rtk_hsotg_ep_alloc_request(&hsotg->eps[0].ep,
+						     GFP_KERNEL);
+	if (!hsotg->ctrl_req) {
+		dev_err(dev, "failed to allocate ctrl req\n");
+		ret = -ENOMEM;
+		goto err_ep_mem;
+	}
+
+	/* initialise the endpoints now the core has been initialised */
+	for (epnum = 0; epnum < hsotg->num_of_eps; epnum++)
+		rtk_hsotg_initep(hsotg, &hsotg->eps[epnum], epnum);
+
+	/* disable power and clock */
+#if 0
+	ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
+				    hsotg->supplies);
+	if (ret) {
+		dev_err(hsotg->dev, "failed to disable supplies: %d\n", ret);
+		goto err_ep_mem;
+	}
+#endif
+	rtk_hsotg_phy_disable(hsotg);
+
+	ret = usb_add_gadget_udc(&pdev->dev, &hsotg->gadget);
+	if (ret)
+		goto err_ep_mem;
+
+	rtk_hsotg_create_debug(hsotg);
+
+#ifdef CONFIG_USB_RTK_UDC_OTG_SWITCH
+	rtk_hsotg_create_sysfs_by_otg(hsotg);
+#endif // CONFIG_USB_RTK_UDC_OTG_SWITCH
+
+	rtk_hsotg_dump(hsotg);
+
+#ifdef CONFIG_USB_OTG
+	otg_set_peripheral(hsotg->uphy->otg, &hsotg->gadget);
+#endif
+	return 0;
+
+err_ep_mem:
+	kfree(eps);
+err_supplies:
+	rtk_hsotg_phy_disable(hsotg);
+err_clk:
+	clk_disable_unprepare(hsotg->clk);
+
+	return ret;
+}
+
+/**
+ * rtk_hsotg_remove - remove function for hsotg driver
+ * @pdev: The platform information for the driver
+ */
+static int rtk_hsotg_remove(struct platform_device *pdev)
+{
+	struct rtk_hsotg *hsotg = platform_get_drvdata(pdev);
+
+	usb_del_gadget_udc(&hsotg->gadget);
+
+	rtk_hsotg_delete_debug(hsotg);
+
+	if (hsotg->driver) {
+		/* should have been done already by driver model core */
+		usb_gadget_unregister_driver(hsotg->driver);
+	}
+
+	rtk_hsotg_phy_disable(hsotg);
+#if 0	//barry
+	if (hsotg->phy)
+		phy_exit(hsotg->phy);
+	clk_disable_unprepare(hsotg->clk);
+#endif
+	return 0;
+}
+
+#if 0	//barry
+static int rtk_hsotg_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct rtk_hsotg *hsotg = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret = 0;
+
+	if (hsotg->driver)
+		dev_info(hsotg->dev, "suspending usb gadget %s\n",
+			 hsotg->driver->driver.name);
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	rtk_hsotg_disconnect(hsotg);
+	rtk_hsotg_phy_disable(hsotg);
+	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	if (hsotg->driver) {
+		int ep;
+		for (ep = 0; ep < hsotg->num_of_eps; ep++)
+			rtk_hsotg_ep_disable(&hsotg->eps[ep].ep);
+
+		ret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),
+					     hsotg->supplies);
+	}
+
+	return ret;
+}
+
+static int rtk_hsotg_resume(struct platform_device *pdev)
+{
+	struct rtk_hsotg *hsotg = platform_get_drvdata(pdev);
+	unsigned long flags;
+	int ret = 0;
+
+	if (hsotg->driver) {
+		dev_info(hsotg->dev, "resuming usb gadget %s\n",
+			 hsotg->driver->driver.name);
+		ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
+				      hsotg->supplies);
+	}
+
+	spin_lock_irqsave(&hsotg->lock, flags);
+	hsotg->last_rst = jiffies;
+	rtk_hsotg_phy_enable(hsotg);
+	rtk_hsotg_core_init(hsotg);
+	spin_unlock_irqrestore(&hsotg->lock, flags);
+
+	return ret;
+}
+#else
+#define rtk_hsotg_suspend NULL
+#define rtk_hsotg_resume NULL
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id rtk_hsotg_of_ids[] = {
+	{ .compatible = "Realtek,rtd129x-usb2-udc" },
+	{ .compatible = "snps,dwc2", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, rtk_hsotg_of_ids);
+#endif
+
+#ifdef CONFIG_USB_OTG
+static int rtk_hsotg_otg_suspend(struct device *dev, pm_message_t state)
+{
+	struct rtk_hsotg *hsotg = dev_get_drvdata(dev);
+	rtk_hsotg_phy_disable(hsotg);
+	return 0;
+}
+static int rtk_hsotg_otg_resume(struct device *dev)
+{
+	struct rtk_hsotg *hsotg = dev_get_drvdata(dev);
+	rtk_hsotg_phy_enable(hsotg);
+//	rtk_hsotg_core_init(hsotg);
+	return 0;
+}
+#else
+#define rtk_hsotg_otg_suspend NULL
+#define rtk_hsotg_otg_resume NULL
+#endif
+
+static struct platform_driver rtk_hsotg_driver = {
+	.driver		= {
+		.name	= "rtk-hsotg",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(rtk_hsotg_of_ids),
+#ifdef CONFIG_USB_OTG
+		.suspend = rtk_hsotg_otg_suspend,
+		.resume  = rtk_hsotg_otg_resume,
+#endif
+	},
+	.probe		= rtk_hsotg_probe,
+	.remove		= rtk_hsotg_remove,
+	.suspend	= rtk_hsotg_suspend,
+	.resume		= rtk_hsotg_resume,
+};
+
+module_platform_driver(rtk_hsotg_driver);
+
+MODULE_DESCRIPTION("Realtek USB High-speed/OtG device");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rtk-hsotg");
diff --git a/drivers/usb/gadget/udc/rtk-hsotg.h b/drivers/usb/gadget/udc/rtk-hsotg.h
new file mode 100644
index 000000000..2a1231d28
--- /dev/null
+++ b/drivers/usb/gadget/udc/rtk-hsotg.h
@@ -0,0 +1,380 @@
+/* drivers/usb/gadget/rtk-hsotg.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * USB2.0 Highspeed/OtG Synopsis DWC2 device block registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __REGS_USB_HSOTG_H
+#define __REGS_USB_HSOTG_H __FILE__
+
+#define HSOTG_REG(x) (x)
+
+#define GOTGCTL				HSOTG_REG(0x000)
+#define GOTGCTL_BSESVLD			(1 << 19)
+#define GOTGCTL_ASESVLD			(1 << 18)
+#define GOTGCTL_DBNC_SHORT			(1 << 17)
+#define GOTGCTL_CONID_B			(1 << 16)
+#define GOTGCTL_DEVHNPEN			(1 << 11)
+#define GOTGCTL_HSSETHNPEN			(1 << 10)
+#define GOTGCTL_HNPREQ				(1 << 9)
+#define GOTGCTL_HSTNEGSCS			(1 << 8)
+#define GOTGCTL_SESREQ				(1 << 1)
+#define GOTGCTL_SESREQSCS			(1 << 0)
+
+#define GOTGINT				HSOTG_REG(0x004)
+#define GOTGINT_DbnceDone			(1 << 19)
+#define GOTGINT_ADevTOUTChg			(1 << 18)
+#define GOTGINT_HstNegDet			(1 << 17)
+#define GOTGINT_HstnegSucStsChng		(1 << 9)
+#define GOTGINT_SesReqSucStsChng		(1 << 8)
+#define GOTGINT_SesEndDet			(1 << 2)
+
+#define GAHBCFG				HSOTG_REG(0x008)
+#define GAHBCFG_PTxFEmpLvl			(1 << 8)
+#define GAHBCFG_NPTxFEmpLvl			(1 << 7)
+#define GAHBCFG_DMAEn				(1 << 5)
+#define GAHBCFG_HBstLen_MASK			(0xf << 1)
+#define GAHBCFG_HBstLen_SHIFT			(1)
+#define GAHBCFG_HBstLen_Single			(0x0 << 1)
+#define GAHBCFG_HBstLen_Incr			(0x1 << 1)
+#define GAHBCFG_HBstLen_Incr4			(0x3 << 1)
+#define GAHBCFG_HBstLen_Incr8			(0x5 << 1)
+#define GAHBCFG_HBstLen_Incr16			(0x7 << 1)
+#define GAHBCFG_GlblIntrEn			(1 << 0)
+
+#define GUSBCFG				HSOTG_REG(0x00C)
+#define GUSBCFG_FORCEDEVMODE		(1 << 30)
+#define GUSBCFG_FORCEHOSTMODE		(1 << 29)
+#define GUSBCFG_PHYLPClkSel			(1 << 15)
+#define GUSBCFG_HNPCap				(1 << 9)
+#define GUSBCFG_SRPCap				(1 << 8)
+#define GUSBCFG_PHYIf16			(1 << 3)
+#define GUSBCFG_PHYIf8				(0 << 3)
+#define GUSBCFG_TOutCal_MASK			(0x7 << 0)
+#define GUSBCFG_TOutCal_SHIFT			(0)
+#define GUSBCFG_TOutCal_LIMIT			(0x7)
+#define GUSBCFG_TOutCal(_x)			((_x) << 0)
+
+#define GRSTCTL				HSOTG_REG(0x010)
+
+#define GRSTCTL_AHBIdle			(1 << 31)
+#define GRSTCTL_DMAReq				(1 << 30)
+#define GRSTCTL_TxFNum_MASK			(0x1f << 6)
+#define GRSTCTL_TxFNum_SHIFT			(6)
+#define GRSTCTL_TxFNum_LIMIT			(0x1f)
+#define GRSTCTL_TxFNum(_x)			((_x) << 6)
+#define GRSTCTL_TxFFlsh			(1 << 5)
+#define GRSTCTL_RxFFlsh			(1 << 4)
+#define GRSTCTL_INTknQFlsh			(1 << 3)
+#define GRSTCTL_FrmCntrRst			(1 << 2)
+#define GRSTCTL_HSftRst			(1 << 1)
+#define GRSTCTL_CSftRst			(1 << 0)
+
+#define GINTSTS				HSOTG_REG(0x014)
+#define GINTMSK				HSOTG_REG(0x018)
+
+#define GINTSTS_WkUpInt			(1 << 31)
+#define GINTSTS_SessReqInt			(1 << 30)
+#define GINTSTS_DisconnInt			(1 << 29)
+#define GINTSTS_ConIDStsChng			(1 << 28)
+#define GINTSTS_PTxFEmp			(1 << 26)
+#define GINTSTS_HChInt				(1 << 25)
+#define GINTSTS_PrtInt				(1 << 24)
+#define GINTSTS_FetSusp			(1 << 22)
+#define GINTSTS_incompIP			(1 << 21)
+#define GINTSTS_IncomplSOIN			(1 << 20)
+#define GINTSTS_OEPInt				(1 << 19)
+#define GINTSTS_IEPInt				(1 << 18)
+#define GINTSTS_EPMis				(1 << 17)
+#define GINTSTS_EOPF				(1 << 15)
+#define GINTSTS_ISOutDrop			(1 << 14)
+#define GINTSTS_EnumDone			(1 << 13)
+#define GINTSTS_USBRst				(1 << 12)
+#define GINTSTS_USBSusp			(1 << 11)
+#define GINTSTS_ErlySusp			(1 << 10)
+#define GINTSTS_GOUTNakEff			(1 << 7)
+#define GINTSTS_GINNakEff			(1 << 6)
+#define GINTSTS_NPTxFEmp			(1 << 5)
+#define GINTSTS_RxFLvl				(1 << 4)
+#define GINTSTS_SOF				(1 << 3)
+#define GINTSTS_OTGInt				(1 << 2)
+#define GINTSTS_ModeMis			(1 << 1)
+#define GINTSTS_CurMod_Host			(1 << 0)
+
+#define GRXSTSR				HSOTG_REG(0x01C)
+#define GRXSTSP				HSOTG_REG(0x020)
+
+#define GRXSTS_FN_MASK				(0x7f << 25)
+#define GRXSTS_FN_SHIFT			(25)
+
+#define GRXSTS_PktSts_MASK			(0xf << 17)
+#define GRXSTS_PktSts_SHIFT			(17)
+#define GRXSTS_PktSts_GlobalOutNAK		(0x1 << 17)
+#define GRXSTS_PktSts_OutRX			(0x2 << 17)
+#define GRXSTS_PktSts_OutDone			(0x3 << 17)
+#define GRXSTS_PktSts_SetupDone		(0x4 << 17)
+#define GRXSTS_PktSts_SetupRX			(0x6 << 17)
+
+#define GRXSTS_DPID_MASK			(0x3 << 15)
+#define GRXSTS_DPID_SHIFT			(15)
+#define GRXSTS_ByteCnt_MASK			(0x7ff << 4)
+#define GRXSTS_ByteCnt_SHIFT			(4)
+#define GRXSTS_EPNum_MASK			(0xf << 0)
+#define GRXSTS_EPNum_SHIFT			(0)
+
+#define GRXFSIZ				HSOTG_REG(0x024)
+
+#define GNPTXFSIZ				HSOTG_REG(0x028)
+
+#define GNPTXFSIZ_NPTxFDep_MASK		(0xffff << 16)
+#define GNPTXFSIZ_NPTxFDep_SHIFT		(16)
+#define GNPTXFSIZ_NPTxFDep_LIMIT		(0xffff)
+#define GNPTXFSIZ_NPTxFDep(_x)			((_x) << 16)
+#define GNPTXFSIZ_NPTxFStAddr_MASK		(0xffff << 0)
+#define GNPTXFSIZ_NPTxFStAddr_SHIFT		(0)
+#define GNPTXFSIZ_NPTxFStAddr_LIMIT		(0xffff)
+#define GNPTXFSIZ_NPTxFStAddr(_x)		((_x) << 0)
+
+#define GNPTXSTS				HSOTG_REG(0x02C)
+
+#define GNPTXSTS_NPtxQTop_MASK			(0x7f << 24)
+#define GNPTXSTS_NPtxQTop_SHIFT		(24)
+
+#define GNPTXSTS_NPTxQSpcAvail_MASK		(0xff << 16)
+#define GNPTXSTS_NPTxQSpcAvail_SHIFT		(16)
+#define GNPTXSTS_NPTxQSpcAvail_GET(_v)		(((_v) >> 16) & 0xff)
+
+#define GNPTXSTS_NPTxFSpcAvail_MASK		(0xffff << 0)
+#define GNPTXSTS_NPTxFSpcAvail_SHIFT		(0)
+#define GNPTXSTS_NPTxFSpcAvail_GET(_v)		(((_v) >> 0) & 0xffff)
+
+
+#define HPTXFSIZ				HSOTG_REG(0x100)
+
+#define DPTXFSIZn(_a)		HSOTG_REG(0x104 + (((_a) - 1) * 4))
+
+#define DPTXFSIZn_DPTxFSize_MASK		(0xffff << 16)
+#define DPTXFSIZn_DPTxFSize_SHIFT		(16)
+#define DPTXFSIZn_DPTxFSize_GET(_v)		(((_v) >> 16) & 0xffff)
+#define DPTXFSIZn_DPTxFSize_LIMIT		(0xffff)
+#define DPTXFSIZn_DPTxFSize(_x)		((_x) << 16)
+
+#define DPTXFSIZn_DPTxFStAddr_MASK		(0xffff << 0)
+#define DPTXFSIZn_DPTxFStAddr_SHIFT		(0)
+
+/* Device mode registers */
+#define DCFG					HSOTG_REG(0x800)
+
+#define DCFG_EPMisCnt_MASK			(0x1f << 18)
+#define DCFG_EPMisCnt_SHIFT			(18)
+#define DCFG_EPMisCnt_LIMIT			(0x1f)
+#define DCFG_EPMisCnt(_x)			((_x) << 18)
+
+#define DCFG_PerFrInt_MASK			(0x3 << 11)
+#define DCFG_PerFrInt_SHIFT			(11)
+#define DCFG_PerFrInt_LIMIT			(0x3)
+#define DCFG_PerFrInt(_x)			((_x) << 11)
+
+#define DCFG_DevAddr_MASK			(0x7f << 4)
+#define DCFG_DevAddr_SHIFT			(4)
+#define DCFG_DevAddr_LIMIT			(0x7f)
+#define DCFG_DevAddr(_x)			((_x) << 4)
+
+#define DCFG_NZStsOUTHShk			(1 << 2)
+
+#define DCFG_DevSpd_MASK			(0x3 << 0)
+#define DCFG_DevSpd_SHIFT			(0)
+#define DCFG_DevSpd_HS				(0x0 << 0)
+#define DCFG_DevSpd_FS				(0x1 << 0)
+#define DCFG_DevSpd_LS				(0x2 << 0)
+#define DCFG_DevSpd_FS48			(0x3 << 0)
+
+#define DCTL					HSOTG_REG(0x804)
+
+#define DCTL_PWROnPrgDone			(1 << 11)
+#define DCTL_CGOUTNak				(1 << 10)
+#define DCTL_SGOUTNak				(1 << 9)
+#define DCTL_CGNPInNAK				(1 << 8)
+#define DCTL_SGNPInNAK				(1 << 7)
+#define DCTL_TstCtl_MASK			(0x7 << 4)
+#define DCTL_TstCtl_SHIFT			(4)
+#define DCTL_GOUTNakSts			(1 << 3)
+#define DCTL_GNPINNakSts			(1 << 2)
+#define DCTL_SftDiscon				(1 << 1)
+#define DCTL_RmtWkUpSig			(1 << 0)
+
+#define DSTS					HSOTG_REG(0x808)
+
+#define DSTS_SOFFN_MASK			(0x3fff << 8)
+#define DSTS_SOFFN_SHIFT			(8)
+#define DSTS_SOFFN_LIMIT			(0x3fff)
+#define DSTS_SOFFN(_x)				((_x) << 8)
+#define DSTS_ErraticErr			(1 << 3)
+#define DSTS_EnumSpd_MASK			(0x3 << 1)
+#define DSTS_EnumSpd_SHIFT			(1)
+#define DSTS_EnumSpd_HS			(0x0 << 1)
+#define DSTS_EnumSpd_FS			(0x1 << 1)
+#define DSTS_EnumSpd_LS			(0x2 << 1)
+#define DSTS_EnumSpd_FS48			(0x3 << 1)
+
+#define DSTS_SuspSts				(1 << 0)
+
+#define DIEPMSK				HSOTG_REG(0x810)
+
+#define DIEPMSK_TxFIFOEmpty			(1 << 7)
+#define DIEPMSK_INEPNakEffMsk			(1 << 6)
+#define DIEPMSK_INTknEPMisMsk			(1 << 5)
+#define DIEPMSK_INTknTXFEmpMsk			(1 << 4)
+#define DIEPMSK_TimeOUTMsk			(1 << 3)
+#define DIEPMSK_AHBErrMsk			(1 << 2)
+#define DIEPMSK_EPDisbldMsk			(1 << 1)
+#define DIEPMSK_XferComplMsk			(1 << 0)
+
+#define DOEPMSK				HSOTG_REG(0x814)
+
+#define DOEPMSK_Back2BackSetup			(1 << 6)
+#define DOEPMSK_OUTTknEPdisMsk			(1 << 4)
+#define DOEPMSK_SetupMsk			(1 << 3)
+#define DOEPMSK_AHBErrMsk			(1 << 2)
+#define DOEPMSK_EPDisbldMsk			(1 << 1)
+#define DOEPMSK_XferComplMsk			(1 << 0)
+
+#define DAINT					HSOTG_REG(0x818)
+#define DAINTMSK				HSOTG_REG(0x81C)
+
+#define DAINT_OutEP_SHIFT			(16)
+#define DAINT_OutEP(x)				(1 << ((x) + 16))
+#define DAINT_InEP(x)				(1 << (x))
+
+#define DTKNQR1				HSOTG_REG(0x820)
+#define DTKNQR2				HSOTG_REG(0x824)
+#define DTKNQR3				HSOTG_REG(0x830)
+#define DTKNQR4				HSOTG_REG(0x834)
+
+#define DVBUSDIS				HSOTG_REG(0x828)
+#define DVBUSPULSE				HSOTG_REG(0x82C)
+
+#define DIEPCTL0				HSOTG_REG(0x900)
+#define DOEPCTL0				HSOTG_REG(0xB00)
+#define DIEPCTL(_a)			HSOTG_REG(0x900 + ((_a) * 0x20))
+#define DOEPCTL(_a)			HSOTG_REG(0xB00 + ((_a) * 0x20))
+
+/* EP0 specialness:
+ * bits[29..28] - reserved (no SetD0PID, SetD1PID)
+ * bits[25..22] - should always be zero, this isn't a periodic endpoint
+ * bits[10..0] - MPS setting differenct for EP0
+ */
+#define D0EPCTL_MPS_MASK			(0x3 << 0)
+#define D0EPCTL_MPS_SHIFT			(0)
+#define D0EPCTL_MPS_64				(0x0 << 0)
+#define D0EPCTL_MPS_32				(0x1 << 0)
+#define D0EPCTL_MPS_16				(0x2 << 0)
+#define D0EPCTL_MPS_8				(0x3 << 0)
+
+#define DxEPCTL_EPEna				(1 << 31)
+#define DxEPCTL_EPDis				(1 << 30)
+#define DxEPCTL_SetD1PID			(1 << 29)
+#define DxEPCTL_SetOddFr			(1 << 29)
+#define DxEPCTL_SetD0PID			(1 << 28)
+#define DxEPCTL_SetEvenFr			(1 << 28)
+#define DxEPCTL_SNAK				(1 << 27)
+#define DxEPCTL_CNAK				(1 << 26)
+#define DxEPCTL_TxFNum_MASK			(0xf << 22)
+#define DxEPCTL_TxFNum_SHIFT			(22)
+#define DxEPCTL_TxFNum_LIMIT			(0xf)
+#define DxEPCTL_TxFNum(_x)			((_x) << 22)
+
+#define DxEPCTL_Stall				(1 << 21)
+#define DxEPCTL_Snp				(1 << 20)
+#define DxEPCTL_EPType_MASK			(0x3 << 18)
+#define DxEPCTL_EPType_SHIFT			(18)
+#define DxEPCTL_EPType_Control			(0x0 << 18)
+#define DxEPCTL_EPType_Iso			(0x1 << 18)
+#define DxEPCTL_EPType_Bulk			(0x2 << 18)
+#define DxEPCTL_EPType_Intterupt		(0x3 << 18)
+
+#define DxEPCTL_NAKsts				(1 << 17)
+#define DxEPCTL_DPID				(1 << 16)
+#define DxEPCTL_EOFrNum			(1 << 16)
+#define DxEPCTL_USBActEp			(1 << 15)
+#define DxEPCTL_NextEp_MASK			(0xf << 11)
+#define DxEPCTL_NextEp_SHIFT			(11)
+#define DxEPCTL_NextEp_LIMIT			(0xf)
+#define DxEPCTL_NextEp(_x)			((_x) << 11)
+
+#define DxEPCTL_MPS_MASK			(0x7ff << 0)
+#define DxEPCTL_MPS_SHIFT			(0)
+#define DxEPCTL_MPS_LIMIT			(0x7ff)
+#define DxEPCTL_MPS(_x)			((_x) << 0)
+
+#define DIEPINT(_a)			HSOTG_REG(0x908 + ((_a) * 0x20))
+#define DOEPINT(_a)			HSOTG_REG(0xB08 + ((_a) * 0x20))
+
+#define DxEPINT_INEPNakEff			(1 << 6)
+#define DxEPINT_Back2BackSetup			(1 << 6)
+#define DxEPINT_INTknEPMis			(1 << 5)
+#define DxEPINT_INTknTXFEmp			(1 << 4)
+#define DxEPINT_OUTTknEPdis			(1 << 4)
+#define DxEPINT_Timeout			(1 << 3)
+#define DxEPINT_Setup				(1 << 3)
+#define DxEPINT_AHBErr				(1 << 2)
+#define DxEPINT_EPDisbld			(1 << 1)
+#define DxEPINT_XferCompl			(1 << 0)
+
+#define DIEPTSIZ0				HSOTG_REG(0x910)
+
+#define DIEPTSIZ0_PktCnt_MASK			(0x3 << 19)
+#define DIEPTSIZ0_PktCnt_SHIFT			(19)
+#define DIEPTSIZ0_PktCnt_LIMIT			(0x3)
+#define DIEPTSIZ0_PktCnt(_x)			((_x) << 19)
+
+#define DIEPTSIZ0_XferSize_MASK		(0x7f << 0)
+#define DIEPTSIZ0_XferSize_SHIFT		(0)
+#define DIEPTSIZ0_XferSize_LIMIT		(0x7f)
+#define DIEPTSIZ0_XferSize(_x)			((_x) << 0)
+
+#define DOEPTSIZ0				HSOTG_REG(0xB10)
+#define DOEPTSIZ0_SUPCnt_MASK			(0x3 << 29)
+#define DOEPTSIZ0_SUPCnt_SHIFT			(29)
+#define DOEPTSIZ0_SUPCnt_LIMIT			(0x3)
+#define DOEPTSIZ0_SUPCnt(_x)			((_x) << 29)
+
+#define DOEPTSIZ0_PktCnt			(1 << 19)
+#define DOEPTSIZ0_XferSize_MASK		(0x7f << 0)
+#define DOEPTSIZ0_XferSize_SHIFT		(0)
+
+#define DIEPTSIZ(_a)			HSOTG_REG(0x910 + ((_a) * 0x20))
+#define DOEPTSIZ(_a)			HSOTG_REG(0xB10 + ((_a) * 0x20))
+
+#define DxEPTSIZ_MC_MASK			(0x3 << 29)
+#define DxEPTSIZ_MC_SHIFT			(29)
+#define DxEPTSIZ_MC_LIMIT			(0x3)
+#define DxEPTSIZ_MC(_x)			((_x) << 29)
+
+#define DxEPTSIZ_PktCnt_MASK			(0x3ff << 19)
+#define DxEPTSIZ_PktCnt_SHIFT			(19)
+#define DxEPTSIZ_PktCnt_GET(_v)		(((_v) >> 19) & 0x3ff)
+#define DxEPTSIZ_PktCnt_LIMIT			(0x3ff)
+#define DxEPTSIZ_PktCnt(_x)			((_x) << 19)
+
+#define DxEPTSIZ_XferSize_MASK			(0x7ffff << 0)
+#define DxEPTSIZ_XferSize_SHIFT		(0)
+#define DxEPTSIZ_XferSize_GET(_v)		(((_v) >> 0) & 0x7ffff)
+#define DxEPTSIZ_XferSize_LIMIT		(0x7ffff)
+#define DxEPTSIZ_XferSize(_x)			((_x) << 0)
+
+#define DIEPDMA(_a)			HSOTG_REG(0x914 + ((_a) * 0x20))
+#define DOEPDMA(_a)			HSOTG_REG(0xB14 + ((_a) * 0x20))
+#define DTXFSTS(_a)			HSOTG_REG(0x918 + ((_a) * 0x20))
+
+#define EPFIFO(_a)			HSOTG_REG(0x1000 + ((_a) * 0x1000))
+
+#endif /* __REGS_USB_HSOTG_H */
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 31e59309d..6e27a600a 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -213,6 +213,18 @@ config USB_EHCI_FSL
 	help
 	  Variation of ARC USB block used in some Freescale chips.
 
+config USB_EHCI_RTK
+	tristate "Support for RTK on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD
+	select USB_RTK_CTRL_MANAGER
+	select RTK_USB_RLE0599_PHY
+	default ARCH_RTD129x
+	help
+	  The Realtek chips are dual-role host/peripheral USB controllers.
+
+	  Enable this option to support this chip in host controller mode.
+	  If unsure, say N.
+
 config USB_EHCI_HCD_NPCM7XX
 	tristate "Support for Nuvoton NPCM7XX on-chip EHCI USB controller"
 	depends on (USB_EHCI_HCD && ARCH_NPCM7XX) || COMPILE_TEST
@@ -422,6 +434,18 @@ config USB_OHCI_HCD
 
 if USB_OHCI_HCD
 
+config USB_OHCI_RTK
+	bool "Support for RTK on-chip OHCI USB controller"
+	depends on USB_OHCI_HCD && (ARCH_RTD119X || ARCH_RTD129x || ARCH_RTD139x)
+	select USB_RTK_CTRL_MANAGER
+	select RTK_USB_RLE0599_PHY
+	default ARCH_RTD129x
+	help
+	  The Realtek chips are dual-role host/peripheral USB controllers.
+
+	  Enable this option to support this chip in host controller mode.
+	  If unsure, say N.
+
 config USB_OHCI_HCD_OMAP1
 	tristate "OHCI support for OMAP1/2 chips"
 	depends on ARCH_OMAP1
@@ -774,3 +798,17 @@ config USB_HCD_TEST_MODE
 	  This option is of interest only to developers who need to validate
 	  their USB hardware designs.  It is not needed for normal use.  If
 	  unsure, say N.
+
+config USB_RTK_HCD_TEST_MODE
+	bool "RTK Host CTS test mode"
+	depends on USB_EHCI_HCD && USB_XHCI_HCD
+	default n
+	help
+	  Enable RTK USB Host CTS testing mode.
+
+config USB_RTK_CTRL_MANAGER
+	tristate "RTK Multiple USB Host/Device Controller Manager"
+	default y if USB_OHCI_RTK || USB_EHCI_RTK || USB_DWC3_RTK
+	help
+	  The Realtek chips are Multiple host/peripheral USB controllers.
+	  Enable the driver to control clock, reset and usb power gpio.
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index c1b08703a..6f954a821 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_USB_EHCI_EXYNOS)	+= ehci-exynos.o
 obj-$(CONFIG_USB_EHCI_HCD_AT91) += ehci-atmel.o
 obj-$(CONFIG_USB_EHCI_TEGRA)	+= ehci-tegra.o
 obj-$(CONFIG_USB_EHCI_BRCMSTB)	+= ehci-brcm.o
+obj-$(CONFIG_USB_EHCI_RTK)	+= ehci-rtk.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
@@ -88,3 +89,5 @@ obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
 obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
 obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
 obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
+
+obj-$(CONFIG_USB_RTK_CTRL_MANAGER)	+= rtk-usb-manager.o
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 0b7f1edd9..8c3bfe7a3 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -867,6 +867,28 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	size -= temp;
 	next += temp;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	temp = scnprintf (next, size, "CTRLDSSEGMENT %08x\n",
+			ehci_readl(ehci, &ehci->regs->segment));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "PERIODIC_LIST_BASE %08x\n",
+			ehci_readl(ehci, &ehci->regs->frame_list));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "ASYNC_LIST_ADDR %08x\n",
+			ehci_readl(ehci, &ehci->regs->async_next));
+	size -= temp;
+	next += temp;
+
+	temp = scnprintf (next, size, "CONFIG_FLAG %08x\n",
+			ehci_readl(ehci, &ehci->regs->configured_flag));
+	size -= temp;
+	next += temp;
+#endif
+
 	for (i = 1; i <= HCS_N_PORTS(ehci->hcs_params); i++) {
 		temp = dbg_port_buf(scratch, sizeof(scratch), label, i,
 				ehci_readl(ehci,
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a826715ae..093d06ff0 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -31,6 +31,32 @@
 #define PID_CODE_IN    1
 #define PID_CODE_SETUP 2
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+extern int RTK_ohci_force_suspend(const char *func);
+
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+int check_and_restore_async_list(struct ehci_hcd *ehci, const char *func, int line) {
+
+	int retry = 0;
+	if (ehci->fixed_async_list_addr_bug) {
+		for (retry = 0; retry < 5; retry++) {
+			u32 async_next = ehci_readl(ehci, &ehci->regs->async_next);
+			if (async_next == 0) {
+				ehci_err(ehci, "%s:%d #%d async_next is NULL ==> fixed async_next to HEAD=%x\n",
+					func, line, retry, (unsigned int) ehci->async->qh_dma);
+				ehci_writel(ehci, (u32) ehci->async->qh_dma,
+					&ehci->regs->async_next);
+				wmb();
+				mdelay(2);
+			} else {
+				break;
+			}
+		}
+	}
+	return 0;
+}
+#endif
+
 /* fill a qtd, returning how much of the buffer we were able to queue up */
 
 static int
@@ -952,6 +978,11 @@ qh_make (
 
 static void enable_async(struct ehci_hcd *ehci)
 {
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif //CONFIG_USB_PATCH_ON_RTK
+
 	if (ehci->async_count++)
 		return;
 
@@ -965,6 +996,11 @@ static void enable_async(struct ehci_hcd *ehci)
 
 static void disable_async(struct ehci_hcd *ehci)
 {
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif
+
 	if (--ehci->async_count)
 		return;
 
@@ -983,6 +1019,12 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	__hc32		dma = QH_NEXT(ehci, qh->qh_dma);
 	struct ehci_qh	*head;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, force suspend OHCI*/
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif //CONFIG_USB_PATCH_ON_RTK
+
 	/* Don't link a QH if there's a Clear-TT-Buffer pending */
 	if (unlikely(qh->clearing_tt))
 		return;
@@ -1112,6 +1154,13 @@ submit_async (
 
 	epnum = urb->ep->desc.bEndpointAddress;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_OHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	RTK_ohci_force_suspend(__func__);
+#endif
+#endif
+
 #ifdef EHCI_URB_TRACE
 	{
 		struct ehci_qtd *qtd;
@@ -1271,6 +1320,11 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	prev->qh_next = qh->qh_next;
 	if (ehci->qh_scan_next == qh)
 		ehci->qh_scan_next = qh->qh_next.qh;
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif //CONFIG_USB_PATCH_ON_RTK
 }
 
 static void start_iaa_cycle(struct ehci_hcd *ehci)
@@ -1300,6 +1354,11 @@ static void end_iaa_cycle(struct ehci_hcd *ehci)
 		ehci_writel(ehci, (u32) ehci->async->qh_dma,
 			    &ehci->regs->async_next);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	check_and_restore_async_list(ehci, __func__, __LINE__);
+#endif //CONFIG_USB_PATCH_ON_RTK
+
 	/* The current IAA cycle has ended */
 	ehci->iaa_in_progress = false;
 
diff --git a/drivers/usb/host/ehci-rtk.c b/drivers/usb/host/ehci-rtk.c
new file mode 100644
index 000000000..10e277b22
--- /dev/null
+++ b/drivers/usb/host/ehci-rtk.c
@@ -0,0 +1,396 @@
+/*
+ *  ehic-rtk.c RTK EHCI HCD (Host Controller Driver)
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mbus.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/phy.h>
+#include <linux/of_gpio.h>
+#include <linux/suspend.h>
+
+#include "ehci.h"
+
+#define DRIVER_DESC "EHCI realtek driver"
+
+static const char hcd_name[] = "ehci-rtk";
+
+static struct hc_driver __read_mostly ehci_rtk_hc_driver;
+
+static struct ehci_rtk {
+	struct device *dev;
+	struct usb_phy *phy;
+	struct ehci_hcd *ehci;
+	int irq;
+
+	struct work_struct work;
+};
+
+#ifdef CONFIG_RTK_USB_RLE0599_PHY
+extern void rtk_rle0599_phy_toggle(struct usb_phy *usb2_phy, bool isConnect);
+#endif
+
+int RTK_ehci_usb2_phy_toggle(struct device *hcd_dev, bool isConnect)
+{
+	struct usb_phy *phy = NULL;
+
+	if (hcd_dev == NULL)
+		return -ENODEV;
+
+	phy = devm_usb_get_phy_by_phandle(hcd_dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(hcd_dev, "No usb phy found\n");
+		return -ENODEV;
+	}
+
+	dev_dbg(hcd_dev, "%s\n", __func__);
+#ifdef CONFIG_RTK_USB_RLE0599_PHY
+	if (phy != NULL)
+		rtk_rle0599_phy_toggle(phy, isConnect);
+#endif
+	return 0;
+}
+
+extern int rtk_usb_init_gpio_power_on(struct device *usb_dev);
+extern int rtk_usb_manager_schedule_work(struct device *usb_dev, struct work_struct *work);
+
+static void ehci_rtk_probe_work(struct work_struct *work)
+{
+	struct ehci_rtk *rtk = container_of(work, struct ehci_rtk, work);
+	struct device		*dev = rtk->dev;
+	struct usb_hcd *hcd = ehci_to_hcd(rtk->ehci);
+	struct usb_phy *phy = rtk->phy;
+
+	int irq = rtk->irq;
+	int ret = 0;
+
+	unsigned long probe_time = jiffies;
+
+	dev_info(dev, "%s Start ...\n", __func__);
+
+	usb_phy_init(phy);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (ret) {
+		dev_err(dev, "%s: error add hcd\n", __func__);
+		usb_put_hcd(hcd);
+	}
+
+	rtk_usb_init_gpio_power_on(dev);
+
+	dev_info(dev, "%s End ... ok! (take %d ms)\n", __func__,
+			jiffies_to_msecs(jiffies - probe_time));
+	return;
+}
+
+static int ehci_rtk_drv_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	void __iomem *regs;
+	int irq, err = 0;
+	struct usb_phy *phy;
+	unsigned long probe_time = jiffies;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	dev_info(&pdev->dev, "Probe Realtek-SoC USB EHCI Host Controller\n");
+
+	//phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	}
+
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		err = -ENODEV;
+		goto err1;
+	}
+
+	if (of_address_to_resource(pdev->dev.of_node, 0, &res)) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		err = -ENODEV;
+		goto err1;
+	}
+
+	/*
+	 * Right now device-tree probed devices don't get dma_mask
+	 * set. Since shared usb code relies on it, set it here for
+	 * now. Once we have dma capability bindings this can go away.
+	 */
+	if (!pdev->dev.dma_mask)
+		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+	if (!pdev->dev.coherent_dma_mask)
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	regs = of_iomap(pdev->dev.of_node, 0);
+	if (regs == NULL) {
+		dev_err(&pdev->dev, "error mapping memory\n");
+		err = -EFAULT;
+		goto err3;
+	}
+
+	if (readl(regs) == 0xdeadbeef) {
+		dev_err(&pdev->dev, "%s error read ehci registers\n", __func__);
+		err = -ENODEV;
+		goto err3;
+	}
+
+	hcd = usb_create_hcd(&ehci_rtk_hc_driver,
+			&pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		err = -ENOMEM;
+		goto err3;
+	}
+
+	hcd->rsrc_start = res.start;
+	hcd->rsrc_len = resource_size(&res);
+	hcd->regs = regs;
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (of_property_read_bool(pdev->dev.of_node, "fixed_async_list_addr_bug")) {
+		dev_info(&pdev->dev, "%s Enable fixed_async_list_addr_bug\n", __func__);
+		ehci->fixed_async_list_addr_bug  = 1;
+	}
+#endif
+
+	if (of_property_read_bool(pdev->dev.of_node, "delay_probe_work")) {
+		struct ehci_rtk *rtk;
+		rtk = devm_kzalloc(&pdev->dev, sizeof(*rtk), GFP_KERNEL);
+		if (!rtk) {
+			dev_err(&pdev->dev, "not enough memory\n");
+			err = -ENOMEM;
+			goto err4;
+		}
+		rtk->dev = &pdev->dev;
+		rtk->ehci = ehci;
+		rtk->irq = irq;
+		rtk->phy = phy;
+		INIT_WORK(&rtk->work, ehci_rtk_probe_work);
+		if (of_property_read_bool(pdev->dev.of_node, "ordered_probe"))
+			rtk_usb_manager_schedule_work(&pdev->dev, &rtk->work);
+		else
+			schedule_work(&rtk->work);
+	} else {
+		usb_phy_init(phy);
+
+		err = usb_add_hcd(hcd, irq, IRQF_SHARED);
+		if (err) {
+			dev_err(&pdev->dev, "error add hcd\n");
+			goto err4;
+		}
+	}
+
+	dev_info(&pdev->dev, "%s OK (take %d ms)\n", __func__, jiffies_to_msecs(jiffies - probe_time));
+	return 0;
+
+err4:
+	usb_put_hcd(hcd);
+err3:
+	irq_dispose_mapping(irq);
+err1:
+	dev_err(&pdev->dev, "%s: Probe %s fail, %d\n", __func__,
+		dev_name(&pdev->dev), err);
+
+	return err;
+
+}
+
+static int ehci_rtk_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	usb_remove_hcd(hcd);
+	irq_dispose_mapping(hcd->irq);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+bool RTK_ehci_check_schedule_actived(const char *func)
+{
+	static struct ehci_hcd *ehci = NULL;
+	struct device_node *node = NULL;
+	struct platform_device *pdev = NULL;
+	struct usb_hcd *hcd = NULL;
+	bool connected = false;
+	u32 status;
+
+	if (ehci == NULL) {
+		node = of_find_compatible_node(NULL, NULL, "Realtek,rtd129x-ehci");
+		if (node != NULL)
+			pdev = of_find_device_by_node(node);
+		if (pdev != NULL) {
+			hcd = platform_get_drvdata(pdev);
+			ehci = hcd_to_ehci(hcd);
+		}
+	}
+	if (ehci == NULL) {
+		pr_debug("%s NO EHCI\n", __func__);
+		return false;
+	}
+	status = ehci_readl(ehci, &ehci->regs->status);
+	if (status & (STS_PSS | STS_ASS))
+		connected = true;
+	return connected;
+}
+#endif //CONFIG_USB_PATCH_ON_RTK
+
+#ifdef CONFIG_SUSPEND
+static int rtk_ehci_suspend(struct device *dev);
+int RTK_rtk_ehci_suspend(struct device *dev)
+{
+	return rtk_ehci_suspend(dev);
+}
+
+static int rtk_ehci_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_phy *phy;
+	bool do_wakeup = device_may_wakeup(dev);
+	int rc = 0;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	dev_info(dev, "[USB] %s Suspend mode\n", __func__);
+
+	rc = ehci_suspend(hcd, do_wakeup);
+
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	} else {
+		usb_phy_shutdown(phy);
+	}
+
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return rc;
+}
+
+static int rtk_ehci_resume(struct device *dev);
+int RTK_rtk_ehci_resume(struct device *dev)
+{
+	return rtk_ehci_resume(dev);
+}
+
+static int rtk_ehci_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_phy *phy;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	dev_info(dev, "[USB] %s Suspend mode\n", __func__);
+
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	} else {
+		usb_phy_init(phy);
+	}
+
+	ehci_resume(hcd, false);
+
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return 0;
+}
+
+#else
+#define rtk_ehci_suspend	NULL
+#define rtk_ehci_resume		NULL
+#endif
+
+static const struct dev_pm_ops rtk_ehci_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(rtk_ehci_suspend, rtk_ehci_resume)
+	//SET_LATE_SYSTEM_SLEEP_PM_OPS(rtk_ehci_suspend, rtk_ehci_resume)
+};
+
+static const struct of_device_id ehci_rtk_dt_ids[] = {
+	{ .compatible = "Realtek,rtk119x-ehci", },
+	{ .compatible = "Realtek,rtd129x-ehci", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ehci_rtk_dt_ids);
+
+static struct platform_driver ehci_rtk_driver = {
+	.probe		= ehci_rtk_drv_probe,
+	.remove		= ehci_rtk_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name	= "rtk-ehci",
+		.owner  = THIS_MODULE,
+		.pm		= &rtk_ehci_pm_ops,
+		.of_match_table = of_match_ptr(ehci_rtk_dt_ids),
+	},
+};
+
+static int __init ehci_rtk_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC " init\n", hcd_name);
+
+	ehci_init_driver(&ehci_rtk_hc_driver, NULL);
+	return platform_driver_register(&ehci_rtk_driver);
+}
+module_init(ehci_rtk_init);
+//late_initcall_sync(ehci_rtk_init);
+
+static void __exit ehci_rtk_cleanup(void)
+{
+	platform_driver_unregister(&ehci_rtk_driver);
+}
+module_exit(ehci_rtk_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_ALIAS("platform:rtk-ehci");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 0f85aa9b2..1c6091652 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -6,6 +6,11 @@
 
 /* this file is part of ehci-hcd.c */
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+extern int RTK_ohci_force_suspend(const char *func);
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -915,6 +920,14 @@ static int intr_submit(
 	/* get endpoint and transfer/schedule data */
 	epnum = urb->ep->desc.bEndpointAddress;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_OHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, force suspend OHCI*/
+	RTK_ohci_force_suspend(__func__);
+#endif
+#endif
+
 	spin_lock_irqsave(&ehci->lock, flags);
 
 	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index eabf22a78..a779a9618 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -218,6 +218,9 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
 	unsigned		need_oc_pp_cycle:1; /* MPC834X port power */
 	unsigned		imx28_write_fix:1; /* For Freescale i.MX28 */
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	unsigned		fixed_async_list_addr_bug:1;
+#endif
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 << 6)
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 1f5e69314..e68db5d4b 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1271,6 +1271,11 @@ MODULE_LICENSE ("GPL");
 #define TMIO_OHCI_DRIVER	ohci_hcd_tmio_driver
 #endif
 
+#ifdef CONFIG_USB_OHCI_RTK
+#include "ohci-rtk.c"
+#define	PLATFORM_DRIVER		ohci_rtk_driver
+#endif
+
 static int __init ohci_hcd_mod_init(void)
 {
 	int retval = 0;
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index f474f2f9c..ace47b65b 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -43,6 +43,13 @@
 static void update_done_list(struct ohci_hcd *);
 static void ohci_work(struct ohci_hcd *);
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_EHCI_RTK
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+extern bool RTK_ehci_check_schedule_actived(const char *func);
+#endif
+#endif
+
 #ifdef	CONFIG_PM
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
 __releases(ohci->lock)
@@ -155,6 +162,20 @@ __acquires(ohci->lock)
 	int			status = -EINPROGRESS;
 	int			autostopped = ohci->autostop;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#ifdef CONFIG_USB_EHCI_RTK
+	/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+	/* When EHCI schedule actived, don't resume OHCI*/
+	if (RTK_ehci_check_schedule_actived(__func__)) {
+		ohci_info (ohci, "[Workaround] %s EHCI schedule actived, skip resume OHCI\n", __func__);
+		return 0;
+	} else {
+		ohci->resuming = 1;
+		init_completion(&ohci->resuming_done);
+	}
+#endif
+#endif
+
 	ohci->autostop = 0;
 	ohci->hc_control = ohci_readl (ohci, &ohci->regs->control);
 
@@ -295,6 +316,12 @@ __acquires(ohci->lock)
 	}
 
 	ohci->rh_state = OHCI_RH_RUNNING;
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (ohci->resuming) {
+		complete(&ohci->resuming_done);
+		ohci->resuming = 0;
+	}
+#endif
 	return 0;
 }
 
@@ -521,7 +548,17 @@ int ohci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	else
 		clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
 
-
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	/* add to check OHCI register deadbeef */
+	if (true) {
+		u32 status = roothub_portstatus (ohci, 0);
+		if (status == 0xdeadbeef) {
+			ohci_err(ohci, "OHCI register is 0x%x"
+					" to clear HCD_FLAG_POLL_RH", status);
+			clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+		}
+	}
+#endif //CONFIG_USB_PATCH_ON_RTK
 done:
 	spin_unlock_irqrestore (&ohci->lock, flags);
 
diff --git a/drivers/usb/host/ohci-rtk.c b/drivers/usb/host/ohci-rtk.c
new file mode 100644
index 000000000..bb7f366d2
--- /dev/null
+++ b/drivers/usb/host/ohci-rtk.c
@@ -0,0 +1,440 @@
+/*
+ *  ohic-rtk.c RTK OHCI HCD (Host Controller Driver)
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mbus.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/suspend.h>
+#include <linux/completion.h>
+
+#define RTK_OHCI_HCD_NAME "rtk-ohci"
+
+extern int usb_disabled(void);
+
+static int ohci_rtk_setup(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	ohci_dbg(ohci, "ohci_rtk_setup, ohci:%p", ohci);
+
+	ret = ohci_init(ohci);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int ohci_rtk_dmp_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int ret;
+
+	ohci_dbg(ohci, "ohci_rtk_dmp_start, ohci:%p", ohci);
+
+	ret = ohci_run(ohci);
+	if (ret < 0) {
+		printk ("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct hc_driver ohci_rtk_dmp_hc_driver = {
+	.description =		hcd_name,
+	.product_desc =		"Rtk Dmp OHCI",
+	.hcd_priv_size =	sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohci_irq,
+	.flags =		HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		ohci_rtk_setup,
+	.start =		ohci_rtk_dmp_start,
+	.stop =			ohci_stop,
+	.shutdown =		ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohci_urb_enqueue,
+	.urb_dequeue =		ohci_urb_dequeue,
+	.endpoint_disable =	ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohci_hub_status_data,
+	.hub_control =		ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
+#endif
+	.start_port_reset =	ohci_start_port_reset,
+};
+
+struct ohci_rtk {
+	struct device *dev;
+	struct ohci_hcd *ohci;
+	struct usb_phy *phy;
+	int irq;
+
+	struct work_struct work;
+};
+
+extern void rtk_usb_init_gpio_power_on(struct device *dev);
+extern int rtk_usb_manager_schedule_work(struct device *usb_dev, struct work_struct *work);
+
+static void ohci_rtk_probe_work(struct work_struct *work)
+{
+	struct ohci_rtk *rtk = container_of(work, struct ohci_rtk, work);
+	struct device		*dev = rtk->dev;
+	struct usb_hcd *hcd = ohci_to_hcd(rtk->ohci);
+	struct usb_phy *phy = rtk->phy;
+	int irq = rtk->irq;
+	int ret = 0;
+
+	unsigned long probe_time = jiffies;
+
+	dev_info(dev, "%s Start ...\n", __func__);
+
+	usb_phy_init(phy);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (ret) {
+		dev_err(dev, "%s: error add hcd\n", __func__);
+		usb_put_hcd(hcd);
+	}
+
+	rtk_usb_init_gpio_power_on(dev);
+
+	dev_info(dev, "%s End ... ok! (take %d ms)\n", __func__, jiffies_to_msecs(jiffies - probe_time));
+	return;
+}
+
+static int ohci_rtk_drv_probe(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd;
+	struct ohci_hcd *ohci;
+	void *reg_base;
+	struct resource res;
+	int irq;
+	int ret;
+	struct usb_phy *phy;
+	unsigned long probe_time = jiffies;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	dev_info(&pdev->dev, "Probe Realtek-SoC USB OHCI Host Controller\n");
+
+	//phy = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	}
+
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	if (of_address_to_resource(pdev->dev.of_node, 0, &res)) {
+		dev_err(&pdev->dev,
+			"Found HC with no register addr. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	/*
+	 * Right now device-tree probed devices don't get dma_mask
+	 * set. Since shared usb code relies on it, set it here for
+	 * now. Once we have dma capability bindings this can go away.
+	 */
+	if (!pdev->dev.dma_mask)
+		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+	if (!pdev->dev.coherent_dma_mask)
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+
+	hcd = usb_create_hcd(&ohci_rtk_dmp_hc_driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = res.start;
+	hcd->rsrc_len = resource_size(&res);
+
+	reg_base = of_iomap(pdev->dev.of_node, 0);
+	if (!reg_base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto err2;
+	}
+
+	if (readl(reg_base) == 0xdeadbeef) {
+		dev_err(&pdev->dev, "%s error read ohci registers\n", __func__);
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	hcd->regs = reg_base;
+
+	ohci = hcd_to_ohci(hcd);
+
+	ohci_hcd_init(ohci);
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (pdev->dev.of_node) {
+		u32 wrap_reg = 0;
+		of_property_read_u32(pdev->dev.of_node, "wrap_reg", &wrap_reg);
+		if (wrap_reg)
+			ohci->wrap_reg = ioremap(wrap_reg, 0x4);
+		else
+			ohci->wrap_reg = NULL;
+	}
+#endif
+
+	if (of_property_read_bool(pdev->dev.of_node, "delay_probe_work")) {
+		struct ohci_rtk *rtk;
+		rtk = devm_kzalloc(&pdev->dev, sizeof(*rtk), GFP_KERNEL);
+		if (!rtk) {
+			dev_err(&pdev->dev, "not enough memory\n");
+			ret = -ENOMEM;
+			goto err2;
+		}
+		rtk->dev = &pdev->dev;
+		rtk->ohci = ohci;
+		rtk->phy = phy;
+		rtk->irq = irq;
+		INIT_WORK(&rtk->work, ohci_rtk_probe_work);
+		if (of_property_read_bool(pdev->dev.of_node, "ordered_probe"))
+			rtk_usb_manager_schedule_work(&pdev->dev, &rtk->work);
+		else
+			schedule_work(&rtk->work);
+	} else {
+		usb_phy_init(phy);
+
+		ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to add hcd with err %d\n", ret);
+			goto err2;
+		}
+	}
+
+	platform_set_drvdata(pdev, hcd);
+
+	dev_info(&pdev->dev, "%s OK (take %d ms)\n", __func__, jiffies_to_msecs(jiffies - probe_time));
+	return 0;
+
+err2:
+	irq_dispose_mapping(irq);
+//err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+static int ohci_rtk_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+
+	iounmap(hcd->regs);
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	if (hcd) {
+		struct ohci_hcd *ohci;
+		ohci = hcd_to_ohci(hcd);
+		if (ohci->wrap_reg)
+			iounmap(ohci->wrap_reg);
+	}
+#endif
+
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+extern int usb_runtime_suspend(struct device *dev);
+
+/* Add Workaround to fixed EHCI/OHCI Wrapper can't work simultaneously */
+int RTK_ohci_force_suspend(const char *func)
+{
+	static struct ohci_hcd *s_ohci = NULL;
+	struct device_node *node = NULL;
+	struct platform_device *pdev = NULL;
+	struct usb_hcd *hcd = NULL;
+	struct ohci_hcd *ohci = NULL;
+	unsigned long	flags;
+
+	if (s_ohci == NULL) {
+		node = of_find_compatible_node(NULL, NULL, "Realtek,rtd129x-ohci");
+		if (node != NULL)
+			pdev = of_find_device_by_node(node);
+		if (pdev != NULL) {
+			hcd = platform_get_drvdata(pdev);
+			s_ohci = hcd_to_ohci(hcd);
+		}
+	} else
+		ohci = s_ohci;
+
+	if (ohci) {
+		u32 hc_control;
+		int resuming;
+
+		spin_lock_irqsave(&ohci->lock, flags);
+		resuming = ohci->resuming;
+		spin_unlock_irqrestore(&ohci->lock, flags);
+
+		if (resuming) {
+			ohci_dbg(ohci, "%s wait for resuming done !!\n", __func__);
+			if (!wait_for_completion_timeout(&ohci->resuming_done, msecs_to_jiffies(1000))) {
+				ohci_info(ohci,
+					"%s timed out on wait resuming_done\n", __func__);
+			}
+		}
+
+		spin_lock_irqsave(&ohci->lock, flags);
+		hc_control = ohci_readl (ohci, &ohci->regs->control);
+		if ((hc_control&OHCI_CTRL_HCFS) == OHCI_USB_OPER) {
+#ifdef CONFIG_PM
+			ohci_info(ohci, "%s force suspend by %s\n",
+					__func__, func);
+			ohci_rh_suspend(ohci, 1);
+#else
+			ohci_err(ohci, "%s NO build config CONFIG_PM!!\n", __func__);
+#endif
+		}
+		spin_unlock_irqrestore (&ohci->lock, flags);
+
+	} else
+		pr_debug("%s NO OHCI !!!\n", __func__);
+	return 0;
+}
+#endif //CONFIG_USB_PATCH_ON_RTK
+
+#ifdef CONFIG_PM
+static int rtk_ohci_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_phy *phy;
+	bool do_wakeup = device_may_wakeup(dev);
+	int rc = 0;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	dev_info(dev, "[USB] %s Suspend mode\n", __func__);
+
+	rc = ohci_suspend(hcd, do_wakeup);
+
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	} else {
+		usb_phy_shutdown(phy);
+	}
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return rc;
+}
+
+static int rtk_ohci_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct platform_device *pdev = to_platform_device(dev);
+	struct usb_phy *phy;
+
+	dev_info(dev, "[USB] Enter %s", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		goto out;
+//	}
+	dev_info(dev, "[USB] %s Suspend mode\n", __func__);
+
+	phy = devm_usb_get_phy_by_phandle(&pdev->dev, "usb-phy", 0);
+	if (IS_ERR(phy)) {
+		dev_err(&pdev->dev, "No usb phy found\n");
+		return -ENODEV;
+	} else {
+		usb_phy_init(phy);
+	}
+
+	ohci_resume(hcd, false);
+out:
+	dev_info(dev, "[USB] Exit %s", __func__);
+	return 0;
+}
+#else
+#define rtk_ohci_suspend       NULL
+#define rtk_ohci_resume        NULL
+#endif
+
+static const struct dev_pm_ops rtk_ohci_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(rtk_ohci_suspend, rtk_ohci_resume)
+	//SET_LATE_SYSTEM_SLEEP_PM_OPS(rtk_ohci_suspend, rtk_ohci_resume)
+};
+
+static const struct of_device_id ohci_rtk_dt_ids[] = {
+	{ .compatible = "Realtek,rtk119x-ohci", },
+	{ .compatible = "Realtek,rtd129x-ohci", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ohci_rtk_dt_ids);
+
+static struct platform_driver ohci_rtk_driver = {
+	.probe		= ohci_rtk_drv_probe,
+	.remove		= ohci_rtk_drv_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver		= {
+		.name	= RTK_OHCI_HCD_NAME,
+		.owner	= THIS_MODULE,
+		.pm		= &rtk_ohci_pm_ops,
+		.of_match_table = of_match_ptr(ohci_rtk_dt_ids),
+	},
+};
+
+MODULE_ALIAS("platform:" RTK_OHCI_HCD_NAME);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index aac6285b3..bf23c81f3 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -8,6 +8,10 @@
  * This file is licenced under the GPL.
  */
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#include <soc/realtek/rtd129x_lockapi.h>
+#endif
+
 /*
  * __hc32 and __hc16 are "Host Controller" types, they may be equivalent to
  * __leXX (normally) or __beXX (given OHCI_BIG_ENDIAN), depending on the
@@ -367,6 +371,10 @@ struct ohci_hcd {
 	 */
 	struct ohci_regs __iomem *regs;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	void __iomem *wrap_reg;
+#endif
+
 	/*
 	 * main memory used to communicate with the HC (dma-consistent).
 	 * hcd adds to schedule for a live hc any time, but removals finish
@@ -399,6 +407,10 @@ struct ohci_hcd {
 	 * driver state
 	 */
 	enum ohci_rh_state	rh_state;
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	int			resuming;
+	struct completion	resuming_done;
+#endif
 	int			num_ports;
 	int			load [NUM_INTS];
 	u32			hc_control;	/* copy of hc control reg */
@@ -561,6 +573,18 @@ static inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	unsigned long flags;
+	rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+	if (ohci->wrap_reg && readl(ohci->wrap_reg) == 0x0) {
+		ohci_err(ohci, "%s [USB Workaround] fixed force to enable "
+					"ohci clock \n", __func__);
+		writel(0x40, ohci->wrap_reg);
+		mdelay(1);
+	}
+	rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+#endif
+
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	return big_endian_mmio(ohci) ?
 		readl_be (regs) :
@@ -573,6 +597,17 @@ static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 static inline void _ohci_writel (const struct ohci_hcd *ohci,
 				 const unsigned int val, __hc32 __iomem *regs)
 {
+#ifdef CONFIG_USB_PATCH_ON_RTK
+	unsigned long flags;
+	rtk_lockapi_lock(flags, __FUNCTION__); /* Add global lock for emmc issue*/
+	if (ohci->wrap_reg && readl(ohci->wrap_reg) == 0x0) {
+		ohci_err(ohci, "%s [USB Workaround] fixed force to enable ohci clock \n", __func__);
+		writel(0x40, ohci->wrap_reg);
+		mdelay(1);
+	}
+	rtk_lockapi_unlock(flags,__FUNCTION__); /* Add global lock for emmc issue*/
+#endif
+
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	big_endian_mmio(ohci) ?
 		writel_be (val, regs) :
diff --git a/drivers/usb/host/rtk-usb-manager.c b/drivers/usb/host/rtk-usb-manager.c
new file mode 100644
index 000000000..8032c13ca
--- /dev/null
+++ b/drivers/usb/host/rtk-usb-manager.c
@@ -0,0 +1,1757 @@
+/*
+ *  rtk-usb-manager.c RTK Manager Driver for All USB.
+ *
+ * Copyright (C) 2017 Realtek Semiconductor Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+//#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <soc/realtek/reset-helper.h>		// rstc_get
+#include <linux/reset.h>
+#include <linux/clk.h>				// clk_get
+#include <linux/clk-provider.h>
+#include <linux/suspend.h>
+#include <linux/regulator/consumer.h>
+#include <soc/realtek/rtk_chip.h>
+#include <soc/realtek/rtk_usb.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+
+#define CRT_SOFT_RESET1 	0x0
+#define CRT_SOFT_RESET2 	0x4
+#define CRT_CLOCK_ENABLE1 	0xc
+
+struct manager_data {
+	void __iomem *crt_base;
+	struct device *dev;
+
+	/* port enable/disable */
+	int port0;
+	int port1;
+	int port2;
+	int port3;
+	/* port mapping to host */
+	struct device_node *port0_host_node;
+	struct device_node *port1_host_node;
+	struct device_node *port2_host_node;
+	struct device_node *port2_ohci_node;
+	struct device_node *port3_host_node;
+
+	struct device_node *type_c_node;
+
+	bool disable_usb;
+
+	/*port GPIO*/
+	unsigned int port0_pow_gpio;
+	unsigned int port1_pow_gpio;
+	unsigned int port2_pow_gpio;
+	unsigned int port3_pow_gpio;
+	unsigned int port0_switch_ctrl_gpio;
+	/* port power on off */
+	bool port0_power_low_active;
+	bool port1_power_low_active;
+	bool port2_power_low_active;
+	bool port3_power_low_active;
+	bool port0_pow_enable;
+	bool port1_pow_enable;
+	bool port2_pow_enable;
+	bool port3_pow_enable;
+
+	bool usb_iso_mode;
+	bool en_usb_storage_reprobe;
+	bool rescue_usb;
+
+	struct rtk_usb *rtk_usb;
+
+	struct workqueue_struct *wq_usb_manager;
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+	struct dentry *debug_dir;
+#endif
+
+	struct mutex lock;
+};
+
+/* [ROOT_CAUSE]: quirk device result in compatibility issue
+ * [SOLUTION]: clear port power and reset port if got error
+ * commit 42e905e60eaadd3fd8374db23dc644b98080717e
+ */
+extern int RTK_usb_probe_device(struct device *dev);
+extern int RTK_usb_unbind_device(struct device *dev);
+
+int RTK_usb_reprobe_usb_storage(struct usb_device *udev)
+{
+	struct device_node *node;
+	struct platform_device *pdev = NULL;
+	static struct manager_data *data = NULL;
+
+	if (data == NULL) {
+		node = of_find_compatible_node(NULL, NULL,
+		    "Realtek,usb-manager");
+		if (node != NULL)
+			pdev = of_find_device_by_node(node);
+		if (pdev != NULL) {
+			data = platform_get_drvdata(pdev);
+		}
+	}
+	if (data == NULL) {
+		pr_err("%s ERROR no manager_data", __func__);
+		return -ENODEV;
+	}
+
+	/* [ROOT_CAUSE]: quirk device result in compatibility issue
+	 * [SOLUTION]: clear port power and reset port if got error
+	 * commit 42e905e60eaadd3fd8374db23dc644b98080717e
+	 * [DEV_FIX]MediaNAS_V0.1 can't recognise the 5411 hub after power on
+	 * [SOLUTION] dont unbind and probe again after usb_add_device , and set it as quirk device
+	 * commit 75b83399dcf5e38ae39ce16d730f5824fccbb3bf
+	 * [DEV_FIX]xhci hub 2.0  can't be recognize after unplug and plug again
+	 * commit fbb4cc12d549b5193d51e88d6d0bc916a6e4d5d3
+	 * [ROOT_CAUSE] USB hdd can't be mounted cuz scsi not stable during power-on stage
+	 * commit dbb572028226bba6b504ff859fe3f05e5b7efbdf
+	 * [ROOT_CAUSE] USB hdd can't be mounted cuz scsi not stable during power-on stage
+	 * commit 8fa320af443950c0dbc9875546159d9c57cd97f2
+	 * [ROOT_CAUSE]config USB device error ,result in NULL pointer
+	 * commit 0d7ba5cbee8ff84a99f926a0a00128fe9c6c6104
+	 * [ROOT_CAUSE] usb SATA not stable after power on
+	 * commit ba77afca700fa8586607fcfa9091b863f4a3b620
+	 * [ROOT_CAUSE] if se config err , udev->actconfig will be NULL
+	 * commit 2ebede9fe6b6347ecf446a06e958dfd0a671b27d
+	 */
+	//hcy added for quirk HDD
+	if (data->en_usb_storage_reprobe) {
+		int usb_storage = 0;
+		int i;
+
+		if (udev->actconfig) {
+			for (i = 0; i < 1/*udev->actconfig->desc.bNumInterfaces*/; i++) {
+				struct usb_host_config *config = udev->actconfig;
+				struct usb_interface *intf = config->interface[i];
+				struct usb_interface_descriptor *desc;
+				desc = &intf->cur_altsetting->desc;
+
+				dev_info(&udev->dev , "bInterfaceClass = %d "
+					    "(jiffies 0x%2x = %d ms)\n",  desc->bInterfaceClass,
+					    jiffies - INITIAL_JIFFIES,
+					    jiffies_to_msecs(jiffies - INITIAL_JIFFIES));
+				if (desc->bInterfaceClass == USB_CLASS_MASS_STORAGE) {
+					usb_storage = 1;
+					break;
+				}
+			}
+		}
+
+		if ((jiffies - INITIAL_JIFFIES) < 0x400
+			    && (usb_storage ||
+			    udev->descriptor.bDeviceClass == USB_CLASS_MASS_STORAGE)) {
+			msleep(100);
+			dev_info(&udev->dev , "%s unbind-probe dev_name = %s "
+				    "(jiffies= 0x%2x = %d ms)\n", __func__,
+				    dev_name(&udev->dev), jiffies - INITIAL_JIFFIES,
+				    jiffies_to_msecs(jiffies - INITIAL_JIFFIES));
+			RTK_usb_unbind_device(&udev->dev);
+			//hcy added for waiting some scsi HDD stable after power on
+			if (data->rescue_usb) {
+				dev_err(&udev->dev ,"** rescue type **\n");
+				msleep(5000);
+			} else {
+				msleep(10000);
+			}
+
+			dev_info(&udev->dev , "%s bind-probe dev_name = %s "
+				    "(jiffies= 0x%2x = %d ms)\n", __func__,
+				    dev_name(&udev->dev), jiffies - INITIAL_JIFFIES,
+				    jiffies_to_msecs(jiffies - INITIAL_JIFFIES));
+			RTK_usb_probe_device(&udev->dev);
+		}
+	}
+	return 0;
+}
+
+int rtk_usb_manager_schedule_work(struct device *usb_dev,
+	    struct work_struct *work) {
+	struct device_node *node = of_find_compatible_node(NULL, NULL,
+		    "Realtek,usb-manager");
+	struct platform_device *pdev = NULL;
+	struct manager_data *data = NULL;
+
+	if (node != NULL)
+		pdev = of_find_device_by_node(node);
+	if (pdev != NULL) {
+		data = platform_get_drvdata(pdev);
+	}
+	if (data == NULL) {
+		pr_err("%s ERROR no manager_data", __func__);
+		return -ENODEV;
+	}
+    dev_dbg(data->dev, "%s Enter ..\n", __func__);
+
+	dev_info(data->dev, "%s for %s", __func__, dev_name(usb_dev));
+
+	if (work == NULL) {
+		dev_err(data->dev, "%s, work is NULL", __func__);
+		return -1;
+	}
+	mutex_lock(&data->lock);
+
+	queue_work(data->wq_usb_manager, work);
+
+	mutex_unlock(&data->lock);
+
+    dev_dbg(data->dev, "%s Exit ..\n", __func__);
+	return 0;
+}
+
+/* enable hw_pm (L4 ICG)
+ *   The hw_pm function will be reset after doing soft_reset, so
+ *   only enable is provided.
+ */
+static __maybe_unused void __rtk_usb_set_hw_pm_enable(struct manager_data *data)
+{
+	struct device *dev = data->dev;
+	bool on = true;
+
+	if (!data->rtk_usb)
+		return;
+
+	dev_dbg(dev, "set usb_hw_pm\n");
+
+	/* for hw_pm, enable is equal to power_off */
+	if (data->port0)
+		rtk_usb_set_hw_l4icg_on_off(data->rtk_usb, USB_PORT_0, on);
+	if (data->port1)
+		rtk_usb_set_hw_l4icg_on_off(data->rtk_usb, USB_PORT_1, on);
+	if (data->port2)
+		rtk_usb_set_hw_l4icg_on_off(data->rtk_usb, USB_PORT_2, on);
+	if (data->port3)
+		rtk_usb_set_hw_l4icg_on_off(data->rtk_usb, USB_PORT_3, on);
+}
+
+/* set usb charger power */
+static __maybe_unused void __usb_set_charger_power(
+	    struct manager_data *data, bool power_on)
+{
+	struct device *dev = data->dev;
+	unsigned int val = 0;
+
+	if (!data->rtk_usb)
+		return;
+
+	if (power_on) {
+		val |= data->port0 << 0;
+		val |= data->port1 << 1;
+		val |= data->port2 << 2;
+		val |= data->port3 << 3;
+	}
+
+	dev_dbg(dev, "%s set usb_charger %x\n", __func__, val);
+
+	rtk_usb_set_charger_power(data->rtk_usb, val);
+}
+
+/* set usb power domain */
+static void __usb_set_pd_power(struct manager_data* data, bool power_on)
+{
+	struct device *dev = data->dev;
+
+	if (power_on &&
+		    (data->port0 || data->port1 || data->port2 || data->port3)) {
+		if (!data->rtk_usb)
+			return;
+		rtk_usb_iso_power_ctrl(data->rtk_usb, true);
+	} else {
+		if (!data->rtk_usb)
+			return;
+		rtk_usb_iso_power_ctrl(data->rtk_usb, false);
+	}
+}
+
+static inline struct reset_control *USB_reset_get(struct device *dev,
+	    const char *str)
+{
+	struct reset_control *reset;
+
+	reset = devm_reset_control_get(dev, str);
+	if (IS_ERR(reset)) {
+		dev_dbg(dev, "No controller reset %s\n", str);
+		reset = NULL;
+	}
+	return reset;
+}
+
+static inline void USB_reset_put(struct reset_control *reset)
+{
+	if (reset) {
+		reset_control_put(reset);
+	}
+}
+
+static inline int USB_reset_deassert(struct reset_control *reset)
+{
+	if (!reset) return 0;
+
+	return reset_control_deassert(reset);
+}
+
+static inline int USB_reset_assert(struct reset_control *reset)
+{
+	if (!reset) return 0;
+
+	return reset_control_assert(reset);
+}
+
+static inline struct clk *USB_clk_get(struct device *dev, const char *str)
+{
+	struct clk *clk;
+
+	clk = clk_get(dev, str);
+	if (IS_ERR(clk)) {
+		dev_dbg(dev, "No clk %s\n", str);
+		clk = NULL;
+	}
+	return clk;
+}
+
+static int __usb_init_clock_reset(struct manager_data* data)
+{
+	struct device *dev = data->dev;
+	//void __iomem *crt_reg = data->crt_base;
+	/* GET clock */
+	struct clk *clk_usb_phy0_to_host = USB_clk_get(dev, "clk_en_phy0_to_host");
+	struct clk *clk_usb_phy1_to_host = USB_clk_get(dev, "clk_en_phy1_to_host");
+	struct clk *clk_usb_phy2_to_host = USB_clk_get(dev, "clk_en_phy2_to_host");
+	struct clk *clk_usb_phy3_to_host = USB_clk_get(dev, "clk_en_phy3_to_host");
+	struct clk *clk_usb = USB_clk_get(dev, "clk_en_usb");
+
+	/* GET reset controller */
+	struct reset_control *reset_u2phy0 = USB_reset_get(dev, "u2phy0");
+	struct reset_control *reset_u2phy1 = USB_reset_get(dev, "u2phy1");
+	struct reset_control *reset_u2phy2 = USB_reset_get(dev, "u2phy2");
+	struct reset_control *reset_u2phy3 = USB_reset_get(dev, "u2phy3");
+
+	struct reset_control *reset_u3phy0 = USB_reset_get(dev, "u3phy0");
+	struct reset_control *reset_u3phy1 = USB_reset_get(dev, "u3phy1");
+	struct reset_control *reset_u3phy0_mdio = USB_reset_get(dev, "u3mdio0");
+	struct reset_control *reset_u3phy1_mdio = USB_reset_get(dev, "u3mdio1");
+
+	struct reset_control *reset_usb_host0 = USB_reset_get(dev, "usb_host0");
+	struct reset_control *reset_usb_host1 = USB_reset_get(dev, "usb_host1");
+	struct reset_control *reset_usb_host2 = USB_reset_get(dev, "usb_host2");
+	struct reset_control *reset_usb_host3 = USB_reset_get(dev, "usb_host3");
+	struct reset_control *reset_usb = USB_reset_get(dev, "usb");
+	struct reset_control *reset_type_c = USB_reset_get(dev, "type_c");
+
+	struct reset_control *reset_usb_apply = USB_reset_get(dev, "apply");
+
+	dev_dbg(dev, "Realtek USB init\n");
+
+	USB_reset_assert(reset_u2phy0);
+	USB_reset_assert(reset_u2phy1);
+	USB_reset_assert(reset_u2phy2);
+	USB_reset_assert(reset_u2phy3);
+	USB_reset_assert(reset_u3phy0);
+	USB_reset_assert(reset_u3phy1);
+	USB_reset_assert(reset_u3phy0_mdio);
+	USB_reset_assert(reset_u3phy1_mdio);
+	USB_reset_assert(reset_usb_host0);
+	USB_reset_assert(reset_usb_host1);
+	USB_reset_assert(reset_usb_host2);
+	USB_reset_assert(reset_usb_host3);
+	USB_reset_assert(reset_usb);
+	USB_reset_assert(reset_type_c);
+	wmb();
+
+	// Enable usb phy reset
+	/* DEASSERT: set rstn bit to 1 */
+	dev_dbg(dev, "Realtek USB init: Set phy reset to 1\n");
+	USB_reset_deassert(reset_u2phy0);
+	USB_reset_deassert(reset_u3phy0);
+	USB_reset_deassert(reset_u2phy1);
+	USB_reset_deassert(reset_u2phy2);
+	USB_reset_deassert(reset_u2phy3);
+	USB_reset_deassert(reset_u3phy1);
+
+	USB_reset_deassert(reset_usb_apply);
+
+	mdelay(2);
+
+	dev_dbg(dev, "Realtek USB init: Trigger usb clk\n");
+	// Trigger USB clk (enable -> disable)
+	clk_prepare_enable(clk_usb); // = clk_prepare + clk_enable
+	clk_disable_unprepare(clk_usb); // = clk_disable + clk_unprepare
+	mdelay(1);
+
+	dev_dbg(dev, "Realtek USB init: Set u3phy mdio reset to 1\n");
+	// Enable USB reset
+	USB_reset_deassert(reset_u3phy0_mdio);
+	USB_reset_deassert(reset_u3phy1_mdio);
+
+	USB_reset_deassert(reset_usb_apply);
+
+	dev_dbg(dev, "Realtek USB init: Set usb reset to 1\n");
+	USB_reset_deassert(reset_usb_host0);
+	USB_reset_deassert(reset_usb_host1);
+	USB_reset_deassert(reset_usb_host2);
+	USB_reset_deassert(reset_usb_host3);
+	USB_reset_deassert(reset_usb);
+	USB_reset_deassert(reset_type_c);
+	mdelay(1);
+	dev_dbg(dev, "Realtek USB init: enable usb clk\n");
+
+	// Enable USB clk
+	clk_prepare_enable(clk_usb); // = clk_prepare + clk_enable
+	mdelay(2);
+	clk_prepare_enable(clk_usb_phy0_to_host); // = clk_prepare + clk_enable
+	clk_prepare_enable(clk_usb_phy1_to_host); // = clk_prepare + clk_enable
+	clk_prepare_enable(clk_usb_phy2_to_host); // = clk_prepare + clk_enable
+	clk_prepare_enable(clk_usb_phy3_to_host); // = clk_prepare + clk_enable
+
+	dev_info(dev, "Realtek USB init OK\n");
+
+	clk_put(clk_usb);
+	clk_put(clk_usb_phy0_to_host);
+	clk_put(clk_usb_phy1_to_host);
+	clk_put(clk_usb_phy2_to_host);
+	clk_put(clk_usb_phy3_to_host);
+
+	USB_reset_put(reset_u2phy0);
+	USB_reset_put(reset_u2phy1);
+	USB_reset_put(reset_u2phy2);
+	USB_reset_put(reset_u2phy3);
+
+	USB_reset_put(reset_u3phy0);
+	USB_reset_put(reset_u3phy1);
+	USB_reset_put(reset_u3phy0_mdio);
+	USB_reset_put(reset_u3phy1_mdio);
+
+	USB_reset_put(reset_usb_host0);
+	USB_reset_put(reset_usb_host1);
+	USB_reset_put(reset_usb_host2);
+	USB_reset_put(reset_usb_host3);
+	USB_reset_put(reset_usb);
+	USB_reset_put(reset_type_c);
+
+	USB_reset_put(reset_usb_apply);
+
+	return 0;
+}
+
+static int __usb_clear_clock_reset(struct manager_data* data) {
+	struct device *dev = data->dev;
+	//void __iomem *crt_reg = data->crt_base;
+	/* GET clock */
+	struct clk *clk_usb_phy0_to_host = USB_clk_get(dev, "clk_en_phy0_to_host");
+	struct clk *clk_usb_phy1_to_host = USB_clk_get(dev, "clk_en_phy1_to_host");
+	struct clk *clk_usb_phy2_to_host = USB_clk_get(dev, "clk_en_phy2_to_host");
+	struct clk *clk_usb_phy3_to_host = USB_clk_get(dev, "clk_en_phy3_to_host");
+	struct clk *clk_usb = USB_clk_get(dev, "clk_en_usb");
+
+	/* GET reset controller */
+	struct reset_control *reset_u2phy0 = USB_reset_get(dev, "u2phy0");
+	struct reset_control *reset_u2phy1 = USB_reset_get(dev, "u2phy1");
+	struct reset_control *reset_u2phy2 = USB_reset_get(dev, "u2phy2");
+	struct reset_control *reset_u2phy3 = USB_reset_get(dev, "u2phy3");
+
+	struct reset_control *reset_u3phy0 = USB_reset_get(dev, "u3phy0");
+	struct reset_control *reset_u3phy1 = USB_reset_get(dev, "u3phy1");
+	struct reset_control *reset_u3phy0_mdio = USB_reset_get(dev, "u3mdio0");
+	struct reset_control *reset_u3phy1_mdio = USB_reset_get(dev, "u3mdio1");
+
+	struct reset_control *reset_usb_host0 = USB_reset_get(dev, "usb_host0");
+	struct reset_control *reset_usb_host1 = USB_reset_get(dev, "usb_host1");
+	struct reset_control *reset_usb_host2 = USB_reset_get(dev, "usb_host2");
+	struct reset_control *reset_usb_host3 = USB_reset_get(dev, "usb_host3");
+	struct reset_control *reset_usb = USB_reset_get(dev, "usb");
+	struct reset_control *reset_type_c = USB_reset_get(dev, "type_c");
+
+	struct reset_control *reset_usb_apply = USB_reset_get(dev, "apply");
+
+	dev_dbg(dev, "Realtek USB clear clock and reset\n");
+
+	USB_reset_assert(reset_u2phy0);
+	USB_reset_assert(reset_u2phy1);
+	USB_reset_assert(reset_u2phy2);
+	USB_reset_assert(reset_u2phy3);
+	USB_reset_assert(reset_u3phy0);
+	USB_reset_assert(reset_u3phy1);
+	USB_reset_assert(reset_u3phy0_mdio);
+	USB_reset_assert(reset_u3phy1_mdio);
+	USB_reset_assert(reset_usb_host0);
+	USB_reset_assert(reset_usb_host1);
+	USB_reset_assert(reset_usb_host2);
+	USB_reset_assert(reset_usb_host3);
+	USB_reset_assert(reset_usb);
+	USB_reset_assert(reset_type_c);
+	wmb();
+
+	clk_disable_unprepare(clk_usb); // = clk_disable + clk_unprepare
+	clk_disable_unprepare(clk_usb_phy0_to_host); // = clk_disable + clk_unprepare
+	clk_disable_unprepare(clk_usb_phy1_to_host); // = clk_disable + clk_unprepare
+	clk_disable_unprepare(clk_usb_phy2_to_host); // = clk_disable + clk_unprepare
+	clk_disable_unprepare(clk_usb_phy3_to_host); // = clk_disable + clk_unprepare
+
+	dev_info(dev, "Realtek USB clear clock and reset... OK\n");
+
+	clk_put(clk_usb);
+	clk_put(clk_usb_phy0_to_host);
+	clk_put(clk_usb_phy1_to_host);
+	clk_put(clk_usb_phy2_to_host);
+	clk_put(clk_usb_phy3_to_host);
+
+	USB_reset_put(reset_u2phy0);
+	USB_reset_put(reset_u2phy1);
+	USB_reset_put(reset_u2phy2);
+	USB_reset_put(reset_u2phy3);
+
+	USB_reset_put(reset_u3phy0);
+	USB_reset_put(reset_u3phy1);
+	USB_reset_put(reset_u3phy0_mdio);
+	USB_reset_put(reset_u3phy1_mdio);
+
+	USB_reset_put(reset_usb_host0);
+	USB_reset_put(reset_usb_host1);
+	USB_reset_put(reset_usb_host2);
+	USB_reset_put(reset_usb_host3);
+	USB_reset_put(reset_usb);
+	USB_reset_put(reset_type_c);
+
+	USB_reset_put(reset_usb_apply);
+
+	return 0;
+}
+
+static int __port0_switch_gpio(struct manager_data *data, bool high)
+{
+	struct device *dev = data->dev;
+
+	if (data->port0_switch_ctrl_gpio != -1 &&
+		    gpio_is_valid(data->port0_switch_ctrl_gpio)) {
+		dev_dbg(dev, "%s gpio %d, set to %s\n",
+			    __func__, data->port0_switch_ctrl_gpio, high?"high":"low");
+		if (gpio_direction_output(data->port0_switch_ctrl_gpio, high))
+			dev_err(dev, "%s ERROR switch_ctrl_gpio = 0 fail\n",
+				    __func__);
+		else
+			return 1;
+	}
+
+	return 0;
+}
+
+int rtk_usb_set_type_c_switch_gpio(struct device *type_c_dev, bool high)
+{
+	static struct manager_data *s_data = NULL;
+	struct device_node *node = NULL;
+	struct platform_device *pdev = NULL;
+	struct manager_data *data = NULL;
+	struct device *dev = NULL;
+
+	if (s_data == NULL) {
+		node = of_find_compatible_node(NULL, NULL, "Realtek,usb-manager");
+		if (node != NULL)
+			pdev = of_find_device_by_node(node);
+		if (pdev != NULL)
+			s_data = platform_get_drvdata(pdev);
+	}
+	data = s_data;
+	if (data == NULL) {
+		dev_err(data->dev, "%s ERROR no manager_data", __func__);
+		return -ENODEV;
+	}
+	dev = data->dev;
+	return __port0_switch_gpio(data, high);
+}
+
+static int __port0_gpio_on_off(struct manager_data *data, bool on);
+
+int rtk_usb_type_c_power_on_off(struct device *type_c_dev, bool on) {
+	static struct manager_data *s_data = NULL;
+	struct device_node *node = NULL;
+	struct platform_device *pdev = NULL;
+	struct manager_data *data = NULL;
+	int ret;
+
+	if (s_data == NULL) {
+		node = of_find_compatible_node(NULL, NULL, "Realtek,usb-manager");
+		if (node != NULL)
+			pdev = of_find_device_by_node(node);
+		if (pdev != NULL)
+			s_data = platform_get_drvdata(pdev);
+	}
+	data = s_data;
+	if (data == NULL) {
+		dev_err(data->dev, "%s ERROR no manager_data", __func__);
+		return -ENODEV;
+	}
+
+	dev_dbg(data->dev, "%s power %s for %s", __func__,
+			on?"on":"off", dev_name(type_c_dev));
+
+	mutex_lock(&data->lock);
+
+	ret = __port0_gpio_on_off(data, on);
+
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int __port0_gpio_on_off(struct manager_data *data, bool on)
+{
+	struct device *dev = data->dev;
+	int ret = 0;
+	int gpio = data->port0_pow_gpio;
+	bool power_low_active = data->port0_power_low_active;
+
+	if (gpio_is_valid(gpio)) {
+		if (gpio_direction_output(gpio, power_low_active?!on:on)) {
+			dev_err(dev, "%s ERROR set gpio fail\n", __func__);
+			ret = -1;
+		} else {
+			dev_info(dev, "%s to set port0 power%s %s by gpio (id=%d) OK\n",
+				    __func__, power_low_active?" (power_low_active)":"",
+				    on?"on":"off", gpio);
+			data->port0_pow_enable = on;
+		}
+	}
+	return ret;
+}
+
+static int __port1_gpio_on_off(struct manager_data *data, bool on) {
+	struct device *dev = data->dev;
+	int port1_pow_gpio = data->port1_pow_gpio;
+	bool power_low_active = data->port1_power_low_active;
+
+	if (gpio_is_valid(port1_pow_gpio)) {
+		if (gpio_request(port1_pow_gpio, "port1_pow_gpio"))    //request gpio
+			dev_err(dev, "%s ERROR Request port1_pow_gpio (id=%d) fail\n",
+				   __func__, port1_pow_gpio);
+		else if (port1_pow_gpio != -1) {
+			if (gpio_direction_output(port1_pow_gpio, power_low_active?!on:on)) {
+				dev_err(dev, "%s ERROR port1 power %s fail\n",
+					    __func__, on?"on":"off");
+			} else {
+				dev_info(dev, "%s to set port1 power%s %s by gpio (id=%d) OK\n",
+					    __func__, power_low_active?" (power_low_active)":"",
+					    on?"on":"off", port1_pow_gpio);
+				data->port1_pow_enable = on;
+			}
+			gpio_free(port1_pow_gpio);
+		}
+	}
+	return 0;
+}
+
+static int __port2_gpio_on_off(struct manager_data *data, bool on) {
+	struct device *dev = data->dev;
+	int port2_pow_gpio = data->port2_pow_gpio;
+	bool power_low_active = data->port2_power_low_active;
+
+	if (gpio_is_valid(port2_pow_gpio)) {
+		if (gpio_request(port2_pow_gpio, "port2_pow_gpio"))    //request gpio
+			dev_err(dev, "%s ERROR Request port1_pow_gpio (id=%d) fail\n",
+				   __func__, port2_pow_gpio);
+		else if (port2_pow_gpio != -1) {
+			if (gpio_direction_output(port2_pow_gpio,
+				    power_low_active?!on:on)) {
+				dev_err(dev, "%s ERROR port2 power %s fail\n",
+					    __func__, on?"on":"off");
+			} else {
+				dev_info(dev, "%s to set port2 power%s %s by gpio (id=%d) OK\n",
+					    __func__, power_low_active?" (power_low_active)":"",
+					    on?"on":"off", port2_pow_gpio);
+				data->port2_pow_enable = on;
+			}
+			gpio_free(port2_pow_gpio);
+		}
+	}
+	return 0;
+}
+
+static int __port3_gpio_on_off(struct manager_data *data, bool on) {
+	struct device *dev = data->dev;
+	int port3_pow_gpio = data->port3_pow_gpio;
+	bool power_low_active = data->port3_power_low_active;
+
+	if (gpio_is_valid(port3_pow_gpio)) {
+		if (gpio_request(port3_pow_gpio, "port3_pow_gpio")) //request gpio
+			dev_err(dev, "%s ERROR Request port3_pow_gpio (id=%d) fail\n",
+				    __func__, port3_pow_gpio);
+		else if (port3_pow_gpio != -1) {
+			if (gpio_direction_output(port3_pow_gpio,
+				    power_low_active?!on:on)) {
+				dev_err(dev, "%s ERROR port3 power %s fail\n",
+					    __func__, on?"on":"off");
+			} else {
+				dev_info(dev, "%s to set port3 power%s %s by gpio (id=%d) OK\n",
+					    __func__, power_low_active?" (power_low_active)":"",
+					    on?"on":"off", port3_pow_gpio);
+				data->port3_pow_enable = on;
+			}
+			gpio_free(port3_pow_gpio);
+		}
+	}
+	return 0;
+}
+
+static int __usb_port_suspend(struct manager_data *data) {
+	struct device *dev = data->dev;
+	bool is_suspend = true;
+
+	if (!data->rtk_usb)
+		return -ENODEV;
+
+	dev_info(dev, "%s", __func__);
+	if (data->port0) {
+		dev_dbg(dev, "set port 0 phy suspend\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_0, is_suspend);
+	}
+	if (data->port1) {
+		dev_dbg(dev, "set port 1 phy suspend\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_1, is_suspend);
+	}
+	if (data->port2) {
+		dev_dbg(dev, "set port 2 phy suspend\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_2, is_suspend);
+	}
+	if (data->port3) {
+		dev_dbg(dev, "set port 3 phy suspend\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_3, is_suspend);
+	}
+	return 0;
+}
+
+static int __usb_port_resume(struct manager_data *data) {
+	struct device *dev = data->dev;
+	//void __iomem *reg_u3_port;
+	//void __iomem *reg_u2_port;
+	bool is_suspend = false;
+
+	if (!data->rtk_usb)
+		return -ENODEV;
+
+	dev_info(dev, "%s", __func__);
+	if (data->port0) {
+		dev_dbg(dev, "set port 0 phy resume\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_0, is_suspend);
+	}
+	if (data->port1) {
+		dev_dbg(dev, "set port 1 phy resume\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_1, is_suspend);
+	}
+	if (data->port2) {
+		dev_dbg(dev, "set port 2 phy resume\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_2, is_suspend);
+	}
+	if (data->port3) {
+		dev_dbg(dev, "set port 3 phy resume\n");
+		rtk_usb_port_suspend_resume(data->rtk_usb, USB_PORT_3, is_suspend);
+	}
+	return 0;
+}
+
+static int __usb_port_gpio_off(struct manager_data *data) {
+	struct device *dev = data->dev;
+	bool off = false;
+
+	dev_info(dev, "%s", __func__);
+	if (data->port0) {
+		struct device_node *node = data->port0_host_node;
+		struct device_node *next_node;
+		int dr_mode = USB_DR_MODE_UNKNOWN;
+
+		if (node)
+			next_node = of_get_next_child(node, NULL);
+		if (next_node) {
+			struct platform_device *pdev;
+			pdev = of_find_device_by_node(next_node);
+			dr_mode = usb_get_dr_mode(&pdev->dev);
+
+			next_node = of_get_next_child(node, next_node);
+		}
+		/* For type c port power on/off for type c driver disable */
+		if (USB_DR_MODE_HOST == dr_mode &&
+			    !of_device_is_available(next_node)) {
+			dev_info(data->dev, "%s Type c Node is disable ==> power off port0",
+				    data->port0_host_node->name);
+			__port0_gpio_on_off(data, off);
+		}
+	}
+	if (data->port1) {
+		__port1_gpio_on_off(data, off);
+	}
+	if (data->port2) {
+		__port2_gpio_on_off(data, off);
+	}
+	if (data->port3) {
+		__port3_gpio_on_off(data, off);
+	}
+	return 0;
+}
+
+static int __usb_port_gpio_on(struct manager_data *data) {
+	struct device *dev = data->dev;
+	bool on = true;
+
+	dev_info(dev, "%s", __func__);
+	if (data->port0) {
+		struct device_node *node = data->port0_host_node;
+		struct device_node *next_node;
+		int dr_mode = USB_DR_MODE_UNKNOWN;
+
+		if (node)
+			next_node = of_get_next_child(node, NULL);
+		if (next_node) {
+			struct platform_device *pdev;
+			pdev = of_find_device_by_node(next_node);
+			dr_mode = usb_get_dr_mode(&pdev->dev);
+
+			next_node = of_get_next_child(node, next_node);
+		}
+		/* For type c port power on/off for type c driver disable */
+		if (USB_DR_MODE_HOST == dr_mode &&
+			    !of_device_is_available(next_node)) {
+			dev_info(data->dev, "%s Type c Node is disable ==> power on port0",
+				    data->port0_host_node->name);
+			__port0_switch_gpio(data, false);
+			__port0_gpio_on_off(data, on);
+		}
+	}
+	if (data->port1) {
+		__port1_gpio_on_off(data, on);
+	}
+	if (data->port2) {
+		__port2_gpio_on_off(data, on);
+	}
+	if (data->port3) {
+		__port3_gpio_on_off(data, on);
+	}
+	return 0;
+}
+
+int rtk_usb_init_gpio_power_on(struct device *usb_dev) {
+	struct device_node *usb_node = usb_dev->of_node;
+	struct device_node *node = of_find_compatible_node(NULL, NULL,
+		    "Realtek,usb-manager");
+	struct platform_device *pdev = NULL;
+	struct manager_data *data = NULL;
+	bool on = true;
+
+	if (node != NULL)
+		pdev = of_find_device_by_node(node);
+	if (pdev != NULL) {
+		data = platform_get_drvdata(pdev);
+	}
+	if (data == NULL) {
+		dev_err(data->dev, "%s ERROR no manager_data", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(data->dev, "%s for %s", __func__, dev_name(usb_dev));
+	mutex_lock(&data->lock);
+	if (data->port0 && (data->port0_host_node->phandle == usb_node->phandle)) {
+		struct device_node *node = data->port0_host_node;
+		struct device_node *next_node;
+		int dr_mode = USB_DR_MODE_UNKNOWN;
+
+		if (node)
+			next_node = of_get_next_child(node, NULL);
+		if (next_node) {
+			struct platform_device *pdev;
+			pdev = of_find_device_by_node(next_node);
+			dr_mode = usb_get_dr_mode(&pdev->dev);
+
+			next_node = of_get_next_child(node, next_node);
+		}
+		/* For type c port power on/off for type c driver disable */
+		if (USB_DR_MODE_HOST == dr_mode &&
+			    !of_device_is_available(next_node)) {
+			dev_info(data->dev, "%s Type c Node is disable ==> power on port0",
+				    data->port0_host_node->name);
+			__port0_switch_gpio(data, false);
+			__port0_gpio_on_off(data, on);
+		}
+	}
+	if (data->port1 || data->port2) {
+		static int count = 0;
+		if (data->port1_host_node->phandle == usb_node->phandle)
+			count++;
+		if (data->port2_host_node->phandle == usb_node->phandle)
+			count++;
+		if (data->port2_ohci_node &&
+			    data->port2_ohci_node->phandle == usb_node->phandle)
+			count++;
+
+		if (count == (data->port1 + data->port2)) {
+			dev_dbg(data->dev, "%s %s power on port 1 and port 2",
+				    __func__, dev_name(usb_dev));
+			__port1_gpio_on_off(data, on);
+			__port2_gpio_on_off(data, on);
+			count = 0;
+		}
+	}
+	if (data->port3 && (data->port3_host_node->phandle == usb_node->phandle)) {
+		dev_dbg(data->dev, "%s %s power on port 3",
+			    __func__, dev_name(usb_dev));
+		__port3_gpio_on_off(data, on);
+	}
+
+	mutex_unlock(&data->lock);
+	return 0;
+}
+
+int rtk_usb_host_gpio_power_on(void)
+{
+        struct device_node *node = of_find_compatible_node(NULL, NULL,
+                    "Realtek,usb-manager");
+        struct platform_device *pdev = NULL;
+        struct manager_data *data = NULL;
+        bool on = true;
+
+        if (node != NULL)
+                pdev = of_find_device_by_node(node);
+        if (pdev != NULL) {
+                data = platform_get_drvdata(pdev);
+        }
+
+        if (data == NULL) {
+                dev_err(data->dev, "%s ERROR no manager_data", __func__);
+                return -ENODEV;
+        }
+
+	__port1_gpio_on_off(data, on);
+	__port2_gpio_on_off(data, on);
+
+	return 0;
+}
+EXPORT_SYMBOL(rtk_usb_host_gpio_power_on);
+
+int rtk_usb_host_gpio_power_off(void)
+{
+        struct device_node *node = of_find_compatible_node(NULL, NULL,
+                    "Realtek,usb-manager");
+        struct platform_device *pdev = NULL;
+        struct manager_data *data = NULL;
+        bool off = false;
+
+        if (node != NULL)
+                pdev = of_find_device_by_node(node);
+        if (pdev != NULL) {
+                data = platform_get_drvdata(pdev);
+        }
+
+        if (data == NULL) {
+                dev_err(data->dev, "%s ERROR no manager_data", __func__);
+                return -ENODEV;
+        }
+
+	__port1_gpio_on_off(data, off);
+	__port2_gpio_on_off(data, off);
+
+	return 0;
+}
+EXPORT_SYMBOL(rtk_usb_host_gpio_power_off);
+
+static int __usb_gpio_init(struct manager_data *data) {
+	bool off = false;
+
+	data->port0_pow_enable = off;
+	data->port1_pow_enable = off;
+	data->port2_pow_enable = off;
+	data->port3_pow_enable = off;
+
+	__port0_gpio_on_off(data, off);
+	__port1_gpio_on_off(data, off);
+	__port2_gpio_on_off(data, off);
+	__port3_gpio_on_off(data, off);
+
+	return 0;
+}
+
+static int rtk_usb_manager_init(struct manager_data *data) {
+	struct device *dev = data->dev;
+
+	dev_dbg(dev, "Realtek USB init ....\n");
+
+	__usb_set_pd_power(data, 1);
+
+	if (data->disable_usb) {
+		dev_err(dev, "Realtek USB No any usb be enabled ....\n");
+		return 0;
+	}
+
+	__usb_init_clock_reset(data);
+
+	__usb_gpio_init(data);
+
+	__rtk_usb_set_hw_pm_enable(data);
+
+	dev_dbg(dev, "Realtek USB init Done\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+static int rtk_port0_power_show(struct seq_file *s, void *unused)
+{
+	struct manager_data		*data = s->private;
+
+	seq_printf(s, "To Control Port 0 (DWC3 DRD power)\n");
+	seq_printf(s, "echo \"on\" > port0_power\n");
+	seq_printf(s, "echo \"off\" > port0_power\n");
+	seq_printf(s, "\n");
+	seq_printf(s, "Now port0 %s\n", data->port0_pow_enable?"on":"off");
+
+	return 0;
+}
+
+static int rtk_port0_power_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_port0_power_show, inode->i_private);
+}
+
+static ssize_t rtk_port0_power_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40];
+	char *buf = buffer;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	mutex_lock(&data->lock);
+	if (!strncmp(buf, "on", 2)) {
+		__port0_gpio_on_off(data, true);
+	} else if (!strncmp(buf, "off", 3)) {
+		__port0_gpio_on_off(data, false);
+	} else
+		dev_err(data->dev, "UNKNOWN input (%s)", buf);
+
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static const struct file_operations rtk_port0_power_fops = {
+	.open			= rtk_port0_power_open,
+	.write			= rtk_port0_power_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int rtk_port1_power_show(struct seq_file *s, void *unused)
+{
+	struct manager_data		*data = s->private;
+
+	seq_printf(s, "To Control Port 1 (DWC3 u2host power)\n");
+	seq_printf(s, "echo \"on\" > port1_power\n");
+	seq_printf(s, "echo \"off\" > port1_power\n");
+	seq_printf(s, "\n");
+	seq_printf(s, "Now port1 %s\n", data->port1_pow_enable?"on":"off");
+
+	return 0;
+}
+
+static int rtk_port1_power_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_port1_power_show, inode->i_private);
+}
+
+static ssize_t rtk_port1_power_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40];
+	char *buf = buffer;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	mutex_lock(&data->lock);
+	if (!strncmp(buf, "on", 2)) {
+		__port1_gpio_on_off(data, true);
+	} else if (!strncmp(buf, "off", 3)) {
+		__port1_gpio_on_off(data, false);
+	} else
+		dev_err(data->dev, "UNKNOWN input (%s)", buf);
+
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static const struct file_operations rtk_port1_power_fops = {
+	.open			= rtk_port1_power_open,
+	.write			= rtk_port1_power_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int rtk_port2_power_show(struct seq_file *s, void *unused)
+{
+	struct manager_data		*data = s->private;
+
+	seq_printf(s, "To Control Port 2 (EHCI/OHCI power)\n");
+	seq_printf(s, "echo \"on\" > port2_power\n");
+	seq_printf(s, "echo \"off\" > port2_power\n");
+	seq_printf(s, "\n");
+	seq_printf(s, "Now port2 %s\n", data->port2_pow_enable?"on":"off");
+
+	return 0;
+}
+
+static int rtk_port2_power_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_port2_power_show, inode->i_private);
+}
+
+static ssize_t rtk_port2_power_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40];
+	char *buf = buffer;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	mutex_lock(&data->lock);
+	if (!strncmp(buf, "on", 2)) {
+		__port2_gpio_on_off(data, true);
+	} else if (!strncmp(buf, "off", 3)) {
+		__port2_gpio_on_off(data, false);
+	} else
+		dev_err(data->dev, "UNKNOWN input (%s)", buf);
+
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static const struct file_operations rtk_port2_power_fops = {
+	.open			= rtk_port2_power_open,
+	.write			= rtk_port2_power_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int rtk_port3_power_show(struct seq_file *s, void *unused)
+{
+	struct manager_data		*data = s->private;
+
+	seq_printf(s, "To Control Port 3 (DWC3 u3host power)\n");
+	seq_printf(s, "echo \"on\" > port3_power\n");
+	seq_printf(s, "echo \"off\" > port3_power\n");
+	seq_printf(s, "\n");
+	seq_printf(s, "Now port3 %s\n", data->port3_pow_enable?"on":"off");
+
+	return 0;
+}
+
+static int rtk_port3_power_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_port3_power_show, inode->i_private);
+}
+
+static ssize_t rtk_port3_power_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40];
+	char *buf = buffer;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	mutex_lock(&data->lock);
+	if (!strncmp(buf, "on", 2)) {
+		__port3_gpio_on_off(data, true);
+	} else if (!strncmp(buf, "off", 3)) {
+		__port3_gpio_on_off(data, false);
+	} else
+		dev_err(data->dev, "UNKNOWN input (%s)", buf);
+
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static const struct file_operations rtk_port3_power_fops = {
+	.open			= rtk_port3_power_open,
+	.write			= rtk_port3_power_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int rtk_iso_mode_show(struct seq_file *s, void *unused)
+{
+	struct manager_data		*data = s->private;
+
+	mutex_lock(&data->lock);
+
+	seq_printf(s, "usb_iso_mode %s\n", data->usb_iso_mode?"Enable":"Disable");
+
+	mutex_unlock(&data->lock);
+
+	return 0;
+}
+
+static int rtk_iso_mode_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_iso_mode_show, inode->i_private);
+}
+
+static ssize_t rtk_iso_mode_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40];
+	char *buf = buffer;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	mutex_lock(&data->lock);
+	if (!strncmp(buf, "enable", 6)) {
+		data->usb_iso_mode = true;
+	} else if (!strncmp(buf, "disable", 7)) {
+		data->usb_iso_mode = false;
+	} else
+		dev_err(data->dev, "UNKNOWN input (%s)", buf);
+
+	mutex_unlock(&data->lock);
+	return count;
+}
+
+static const struct file_operations rtk_iso_mode_fops = {
+	.open			= rtk_iso_mode_open,
+	.write			= rtk_iso_mode_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static u32 rtk_usb_reg_addr = 0;
+static u32 rtk_usb_reg_value = 0;
+
+static int rtk_usb_reg_show(struct seq_file *s, void *unused)
+{
+	//struct manager_data		*data = s->private;
+	void __iomem *addr;
+	if (rtk_usb_reg_addr) {
+		addr = ioremap(rtk_usb_reg_addr, 0x4);
+		seq_printf(s, "Register Addr 0x%x = 0x%x\n",
+			    rtk_usb_reg_addr, readl(addr));
+
+		iounmap(addr);
+	} else {
+		seq_printf(s, "read register: (1) echo \"0x98XXXXXX\" > "
+			    "reg (2) cat reg\n");
+		seq_printf(s, "write register: (1) echo \"0x98XXXXXX value\" > "
+			    "reg (2) cat reg\n");
+	}
+	return 0;
+}
+
+static int rtk_usb_reg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_usb_reg_show, inode->i_private);
+}
+
+static ssize_t rtk_usb_reg_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buffer[40] = "";
+	char *buf = buffer;
+
+	u32 addr, value;
+	int ret;
+
+	if (copy_from_user(&buffer, ubuf, min_t(size_t, sizeof(buffer) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "0x98", 4)) {
+		ret = sscanf(buf, "%x %x", &addr, &value);
+		if (addr >= 0x98000000 && addr <= 0x98200000) {
+			rtk_usb_reg_addr = addr;
+			if (ret > 1) {
+				void __iomem *v_addr = ioremap(rtk_usb_reg_addr, 0x4);
+				rtk_usb_reg_value = value;
+				writel(rtk_usb_reg_value, v_addr);
+				iounmap(v_addr);
+			}
+		} else
+			dev_err(data->dev, "Error: to set addr = 0x%x, value = 0x%x\n",
+				    addr, value);
+	} else
+		rtk_usb_reg_addr = 0;
+
+	return count;
+}
+
+static const struct file_operations rtk_usb_reg_fops = {
+	.open			= rtk_usb_reg_open,
+	.write			= rtk_usb_reg_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static int rtk_usb_debug_show(struct seq_file *s, void *unused)
+{
+	//struct manager_data		*data = s->private;
+
+	seq_printf(s, "To Enable/Disable Debug register\n");
+	seq_printf(s, "echo \"enable\" > debug\n");
+	seq_printf(s, "echo \"disable\" > debug\n");
+
+	return 0;
+}
+
+static int rtk_usb_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rtk_usb_debug_show, inode->i_private);
+}
+
+static ssize_t rtk_usb_debug_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	static struct dentry *reg_file = NULL;
+	struct seq_file		*s = file->private_data;
+	struct manager_data		*data = s->private;
+	char			buf[32];
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	if (!strncmp(buf, "enable", 6)) {
+		if (!reg_file)
+		reg_file = debugfs_create_file("reg", S_IRUGO | S_IWUSR, data->debug_dir,
+				data, &rtk_usb_reg_fops);
+	} else if (!strncmp(buf, "disable", 7)) {
+		debugfs_remove(reg_file);
+		reg_file = NULL;
+	}
+
+	return count;
+}
+
+static const struct file_operations rtk_usb_debug_fops = {
+	.open			= rtk_usb_debug_open,
+	.write			= rtk_usb_debug_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
+static inline void create_debug_files(struct manager_data *data) {
+
+	dev_err(data->dev, "%s", __func__);
+
+	data->debug_dir = debugfs_create_dir("usb_manager", usb_debug_root);
+	if (!data->debug_dir) {
+		dev_err(data->dev, "%s Error debug_dir is NULL", __func__);
+		return;
+	}
+
+	if (data->port0
+			&& !debugfs_create_file("port0_power", S_IRUGO | S_IWUSR,
+					data->debug_dir, data, &rtk_port0_power_fops))
+		goto file_error;
+
+	if (data->port1
+			&& !debugfs_create_file("port1_power", S_IRUGO | S_IWUSR,
+					data->debug_dir, data, &rtk_port1_power_fops))
+		goto file_error;
+
+	if (data->port2
+			&& !debugfs_create_file("port2_power", S_IRUGO | S_IWUSR,
+					data->debug_dir, data, &rtk_port2_power_fops))
+		goto file_error;
+
+	if (data->port3
+			&& !debugfs_create_file("port3_power", S_IRUGO | S_IWUSR,
+					data->debug_dir, data, &rtk_port3_power_fops))
+		goto file_error;
+
+	if (!debugfs_create_file("usb_iso_mode", S_IRUGO | S_IWUSR,
+					data->debug_dir, data, &rtk_iso_mode_fops))
+		goto file_error;
+
+	if (!debugfs_create_file("debug", S_IRUGO | S_IWUSR, data->debug_dir, data,
+						&rtk_usb_debug_fops))
+		goto file_error;
+
+	return;
+
+file_error:
+	debugfs_remove_recursive(data->debug_dir);
+}
+#endif //CONFIG_DYNAMIC_DEBUG
+
+static int rtk_usb_manager_probe(struct platform_device *pdev) {
+	struct device		*dev = &pdev->dev;
+	struct device_node	*node = dev->of_node;
+	struct device_node	*sub_node;
+	struct device_node	*np;
+	struct manager_data 	*data;
+	unsigned int gpio;
+	int ret = 0;
+	unsigned long probe_time = jiffies;
+
+	dev_info(dev, "ENTER %s", __func__);
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->crt_base = of_iomap(pdev->dev.of_node, 0);
+	if (data->crt_base == NULL) {
+		dev_err(&pdev->dev, "error mapping memory for crt_base\n");
+		ret = -EFAULT;
+		goto err1;
+	}
+	data->dev = dev;
+
+	if (node && of_device_is_available(node)) {
+		gpio = of_get_named_gpio(node, "realtek,port0-power-gpio", 0);
+
+		if (gpio_is_valid(gpio)) {
+			data->port0_pow_gpio = gpio;
+			dev_dbg(dev, "%s get port0-power-gpio (id=%d) OK\n", __func__, gpio);
+		 } else {
+			data->port0_pow_gpio = -1;
+			dev_err(dev, "port0-power-gpio no found");
+		}
+
+		gpio = of_get_named_gpio(node, "realtek,port1-power-gpio", 0);
+		if (gpio_is_valid(gpio)) {
+			data->port1_pow_gpio = gpio;
+			dev_dbg(dev, "%s get port1-power-gpio (id=%d) OK\n", __func__, gpio);
+		 } else {
+			data->port1_pow_gpio = -1;
+			dev_err(dev, "port1-power-gpio no found");
+		}
+
+		gpio = of_get_named_gpio(node, "realtek,port2-power-gpio", 0);
+		if (gpio_is_valid(gpio)) {
+			data->port2_pow_gpio = gpio;
+			dev_dbg(dev, "%s get port2-power-gpio (id=%d) OK\n", __func__, gpio);
+		 } else {
+			data->port2_pow_gpio = -1;
+			dev_err(dev, "port2-power-gpio no found");
+		}
+
+		gpio = of_get_named_gpio(node, "realtek,port3-power-gpio", 0);
+		if (gpio_is_valid(gpio)) {
+			data->port3_pow_gpio = gpio;
+			dev_dbg(dev, "%s get port-power-gpio (id=%d) OK\n", __func__, gpio);
+		 } else {
+			data->port3_pow_gpio = -1;
+			dev_dbg(dev, "port3-power-gpio no found");
+		}
+	}
+
+	if (node && of_device_is_available(node)) {
+		gpio = of_get_named_gpio(node, "realtek,port0_switch_ctrl-gpio", 0);
+
+		if (gpio_is_valid(gpio)) {
+			data->port0_switch_ctrl_gpio = gpio;
+			dev_info(dev, "%s get switch_ctrl-gpio (id=%d) OK\n",
+				    __func__, gpio);
+		} else {
+			dev_err(dev, "Error switch_ctrl-gpio no found");
+			data->port0_switch_ctrl_gpio = -1;
+		}
+	}
+
+	if (node && of_device_is_available(node)) {
+		data->port0_host_node = of_parse_phandle(node, "port0", 0);
+		data->port1_host_node = of_parse_phandle(node, "port1", 0);
+		data->port2_host_node = of_parse_phandle(node, "port2", 0);
+		data->port2_ohci_node = of_parse_phandle(node, "port2", 1);
+		data->port3_host_node = of_parse_phandle(node, "port3", 0);
+
+		data->type_c_node = of_parse_phandle(node, "type_c", 0);
+
+		data->disable_usb = true;
+		data->port0 = 0;
+		if (data->port0_host_node &&
+			    of_device_is_available(data->port0_host_node)) {
+			dev_info(dev, "Port 0 %s status is okay",
+				    data->port0_host_node->name);
+			data->port0++;
+		}
+
+		np = of_find_node_by_name(NULL, "rtk_dwc3_u2host");
+		if (of_property_read_bool(np, "usbhost_backend"))
+			data->port1 = 1;
+		else
+			data->port1 = 0;
+
+		if (data->port1_host_node &&
+			    of_device_is_available(data->port1_host_node)) {
+			dev_err(dev, "Port 1 %s status is okay",
+				    data->port1_host_node->name);
+			data->port1++;
+		}
+
+		if (of_property_read_bool(np, "usbhost_backend"))
+			data->port2 = 1;
+		else
+			data->port2 = 0;
+		
+		if (data->port2_host_node &&
+			    of_device_is_available(data->port2_host_node)) {
+			dev_err(dev, "Port 2 %s status is okay",
+				    data->port2_host_node->name);
+			data->port2++;
+		}
+		if (data->port2_ohci_node &&
+			    of_device_is_available(data->port2_ohci_node)) {
+			dev_err(dev, "Port 2 %s status is okay",
+				    data->port2_ohci_node->name);
+			data->port2++;
+		}
+
+		data->port3 = 0;
+		if (data->port3_host_node &&
+			    of_device_is_available(data->port3_host_node)) {
+			dev_err(dev, "Port 3 %s status is okay",
+				    data->port3_host_node->name);
+			data->port3++;
+		}
+		if (data->port0 || data->port1 || data->port2 || data->port3) {
+			data->disable_usb = false;
+		}
+
+		if (of_property_read_bool(node, "power_low_active")) {
+			data->port0_power_low_active = true;
+			data->port1_power_low_active = true;
+			data->port2_power_low_active = true;
+			data->port3_power_low_active = true;
+		} else {
+			data->port0_power_low_active = false;
+			data->port1_power_low_active = false;
+			data->port2_power_low_active = false;
+			data->port3_power_low_active = false;
+		}
+
+		if (of_property_read_bool(node, "port0_power_low_active"))
+			data->port0_power_low_active = true;
+		if (of_property_read_bool(node, "port1_power_low_active"))
+			data->port1_power_low_active = true;
+		if (of_property_read_bool(node, "port2_power_low_active"))
+			data->port2_power_low_active = true;
+		if (of_property_read_bool(node, "port3_power_low_active"))
+			data->port3_power_low_active = true;
+
+		if (of_property_read_bool(node, "usb_iso_mode"))
+			data->usb_iso_mode = true;
+		else
+			data->usb_iso_mode = false;
+
+		if (of_property_read_bool(node, "en_usb_storage_reprobe"))
+			data->en_usb_storage_reprobe = true;
+		else
+			data->en_usb_storage_reprobe = false;
+
+		if (of_property_read_bool(node, "rescue_usb"))
+			data->rescue_usb = true;
+		else
+			data->rescue_usb = false;
+	}
+
+	sub_node = of_get_child_by_name(node, "power_ctrl_reg");
+	if (sub_node) {
+		data->rtk_usb = rtk_usb_soc_init(sub_node);
+	} else {
+		data->rtk_usb = NULL;
+	}
+	mutex_init(&data->lock);
+
+	rtk_usb_manager_init(data);
+
+	platform_set_drvdata(pdev, data);
+
+	data->wq_usb_manager = create_singlethread_workqueue("rtk_usb_manager");
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+	create_debug_files(data);
+#endif
+
+	dev_info(&pdev->dev, "%s OK (take %d ms)\n", __func__,
+		    jiffies_to_msecs(jiffies - probe_time));
+	return 0;
+
+err1:
+	dev_err(&pdev->dev, "%s: Probe fail, %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int rtk_usb_manager_remove(struct platform_device *pdev) {
+	dev_info(&pdev->dev, "%s\n", __func__);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id rtk_usb_manager_match[] = {
+	{ .compatible = "Realtek,usb-manager" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rtk_usb_manager_match);
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+
+static int rtk_usb_manager_prepare(struct device *dev) {
+	struct manager_data *data = dev_get_drvdata(dev);
+	int ret = 0;
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//	} else {
+		dev_info(dev,  "[USB] %s Suspend mode\n", __func__);
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return ret;
+}
+
+static void rtk_usb_manager_complete(struct device *dev) {
+	struct manager_data *data = dev_get_drvdata(dev);
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s S1 (Standby mode)\n", __func__);
+//	} else {
+		dev_info(dev, "[USB] %s S3 (Suspend-to-RAM mode)\n", __func__);
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+}
+
+static int rtk_usb_manager_suspend(struct device *dev) {
+	struct manager_data *data = dev_get_drvdata(dev);
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s S1 (Standby mode)\n", __func__);
+//	} else {
+		//For suspend mode
+		dev_info(dev, "[USB] %s S3 (Suspend-to-RAM mode) %susb_iso_mode\n",
+			    __func__, data->usb_iso_mode?"":"NOT ");
+		if (!data->usb_iso_mode) {
+			__usb_port_gpio_off(data);
+			__usb_set_pd_power(data, 0);
+		} else {
+			__usb_port_suspend(data);
+		}
+
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return 0;
+}
+
+static int rtk_usb_manager_resume(struct device *dev) {
+	struct manager_data *data = dev_get_drvdata(dev);
+	struct clk *clk_usb = USB_clk_get(NULL, "clk_en_usb");
+
+	dev_info(dev, "[USB] Enter %s\n", __func__);
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY){
+//		//For idle mode
+//		dev_info(dev, "[USB] %s S1 (Standby mode)\n", __func__);
+//	} else {
+		//For suspend mode
+		dev_info(dev, "[USB] %s S3 (Suspend-to-RAM mode) %susb_iso_mode\n",
+			    __func__, data->usb_iso_mode?"":"NOT ");
+
+		if (!data->usb_iso_mode) {
+			__usb_set_pd_power(data, 1);
+
+			clk_disable_unprepare(clk_usb); // = clk_disable + clk_unprepare
+			__usb_init_clock_reset(data);
+
+			__rtk_usb_set_hw_pm_enable(data);
+
+		} else {
+			__usb_port_resume(data);
+		}
+		__usb_port_gpio_on(data);
+//	}
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops rtk_usb_manager_pm_ops = {
+	.prepare = rtk_usb_manager_prepare,
+	.complete = rtk_usb_manager_complete,
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(rtk_usb_manager_suspend, rtk_usb_manager_resume)
+};
+
+#define DEV_PM_OPS	(&rtk_usb_manager_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM_SLEEP */
+
+static void rtk_usb_manager_shutdown(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct manager_data *data = dev_get_drvdata(dev);
+
+	dev_info(dev, "[USB] Enter %s S5 (shutdown)\n",
+		    __func__);
+
+	__usb_gpio_init(data);
+	__usb_set_pd_power(data, 0);
+	__usb_clear_clock_reset(data);
+
+	dev_info(dev, "[USB] Exit %s\n", __func__);
+}
+
+static struct platform_driver rtk_usb_manager_driver = {
+	.probe		= rtk_usb_manager_probe,
+	.remove		= rtk_usb_manager_remove,
+	.driver		= {
+		.name	= "rtk-usb-manager",
+		.of_match_table = of_match_ptr(rtk_usb_manager_match),
+		.pm = DEV_PM_OPS,
+	},
+	.shutdown = rtk_usb_manager_shutdown,
+};
+
+static int __init rtk_usb_manager_driver_init(void) {
+	return platform_driver_register(&(rtk_usb_manager_driver));
+}
+subsys_initcall(rtk_usb_manager_driver_init);
+
+static void __exit rtk_usb_manager_driver_exit(void) {
+	platform_driver_unregister(&(rtk_usb_manager_driver));
+}
+
+MODULE_ALIAS("platform:rtk-usb-manager");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index 74c497fd3..0496c8df2 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -1100,7 +1100,11 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 link_state = 0;
 	u16 wake_mask = 0;
 	u16 timeout = 0;
+#ifdef CONFIG_USB_RTK_HCD_TEST_MODE
+	u16 test_mode = (wIndex & 0xff00) >> 8;
+#else
 	u16 test_mode = 0;
+#endif
 	struct xhci_hub *rhub;
 	struct xhci_port **ports;
 
@@ -1421,6 +1425,24 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			temp |= PORT_U2_TIMEOUT(timeout);
 			writel(temp, ports[wIndex]->addr + PORTPMSC);
 			break;
+#ifdef CONFIG_USB_RTK_HCD_TEST_MODE
+		case USB_PORT_FEAT_TEST:
+			if (!test_mode || test_mode > 5)
+				goto error;
+
+			int slot_id = xhci_find_slot_id_by_port(hcd, xhci, wIndex + 1);
+			if (test_mode && test_mode <= 5) {
+				/* unlock to execute stop endpoint commands */
+				spin_unlock_irqrestore(&xhci->lock, flags);
+				xhci_stop_device(xhci, slot_id, 1);
+				spin_lock_irqsave(&xhci->lock, flags);
+				xhci_halt(xhci);
+				temp = readl(port_array[wIndex] + PORTPMSC);
+				temp |= test_mode << 28;
+				writel(temp, port_array[wIndex] + PORTPMSC);
+			}
+			break;
+#else
 		case USB_PORT_FEAT_TEST:
 			/* 4.19.6 Port Test Modes (USB2 Test Mode) */
 			if (hcd->speed != HCD_USB2)
@@ -1431,6 +1453,7 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			retval = xhci_enter_test_mode(xhci, test_mode, wIndex,
 						      &flags);
 			break;
+#endif
 		default:
 			goto error;
 		}
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 3589b49b6..52c930990 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1057,6 +1057,71 @@ void xhci_copy_ep0_dequeue_into_input_ctx(struct xhci_hcd *xhci,
 	virt_dev = xhci->devs[udev->slot_id];
 	ep0_ctx = xhci_get_ep_ctx(xhci, virt_dev->in_ctx, 0);
 	ep_ring = virt_dev->eps[0].ring;
+
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#if 1
+	/* [DEV_FIX]xhci control tranfer will error occasionally (1/45)
+	 * commit 0d2ae2abc867c1a31b7d280dc6429d18ba3770c5
+	 */
+	{
+		int i = 0;
+		struct xhci_ring *ring = ep_ring;
+		union xhci_trb *next;
+		union xhci_trb *trb;
+
+		ring->enq_seg = ring->first_seg;
+		ring->enqueue = ring->first_seg->trbs;
+		next = ring->enqueue;
+		wmb();
+		for (i = 0; i < (TRBS_PER_SEGMENT); i++) {
+			trb = &ring->first_seg->trbs[i];
+			trb->generic.field[3] &= cpu_to_le32(~TRB_CYCLE);
+		}
+		for (i = 0; i < (TRBS_PER_SEGMENT); i++) {
+			trb = &ring->first_seg->next->trbs[i];
+			trb->generic.field[3] &= cpu_to_le32(~TRB_CYCLE);
+		}
+		ring->cycle_state = 1;
+		wmb();
+	}
+#else
+	/* [DEV_FIx]set address fail after warm/hot reset
+	 * commit e7afd2f2d0093553379a9e2d6874ef11897a394f
+	 */
+	/* Fixed : USB reset issue, which will cause set address fail.
+	 * by Ted.
+	 */
+	{
+		int i = 0;
+		struct xhci_ring *ring = ep_ring;
+		union xhci_trb *next;
+		union xhci_trb *trb;
+		ring->enq_seg = ring->first_seg;
+		ring->enqueue = ring->first_seg->trbs;
+		next = ring->enqueue;
+		wmb();
+		for (i = 0; i < (TRBS_PER_SEGMENT -1); ++i) {
+			trb = &ring->first_seg->trbs[i];
+			trb->generic.field[0] = 0x0;
+			trb->generic.field[1] = 0x0;
+			trb->generic.field[2] = 0x0;
+			trb->generic.field[3] = 0x0;
+		}
+		wmb();
+
+		for (i = 0; i < (TRBS_PER_SEGMENT -1); ++i) {
+			trb = &ring->first_seg->next->trbs[i];
+			trb->generic.field[0] = 0x0;
+			trb->generic.field[1] = 0x0;
+			trb->generic.field[2] = 0x0;
+			trb->generic.field[3] = 0x0;
+		}
+		ring->cycle_state = 1;
+		wmb();
+	}
+#endif
+#endif
+
 	/*
 	 * FIXME we don't keep track of the dequeue pointer very well after a
 	 * Set TR dequeue pointer, so we're setting the dequeue pointer of the
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index c1edcc9b1..6fe21979f 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/usb/of.h>
+#include <linux/suspend.h>
 
 #include "xhci.h"
 #include "xhci-plat.h"
@@ -431,12 +432,31 @@ static int xhci_plat_remove(struct platform_device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* [DEV_FIX]implement New USB reset mechanism with CRT reset to workaround any HW or IP issues
+ * commit 319ff9f5c298b94517a10d4ced59812b54994347
+ */
+static int xhci_plat_suspend(struct device *dev);
+int RTK_xhci_plat_suspend(struct device *dev) {
+	return xhci_plat_suspend(dev);
+}
+#endif
+
 static int __maybe_unused xhci_plat_suspend(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 	int ret;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		return 0;
+//	} else
+		xhci_info(xhci, "[USB] %s Suspend mode --> xhci_suspend (do_wakeup=%s)",
+			__func__, device_may_wakeup(dev)? "true":"false");
+#endif
+
 	ret = xhci_priv_suspend_quirk(hcd);
 	if (ret)
 		return ret;
@@ -447,12 +467,31 @@ static int __maybe_unused xhci_plat_suspend(struct device *dev)
 	return xhci_suspend(xhci, device_may_wakeup(dev));
 }
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+/* [DEV_FIX]implement New USB reset mechanism with CRT reset to workaround any HW or IP issues
+ * commit 319ff9f5c298b94517a10d4ced59812b54994347
+ */
+static int xhci_plat_resume(struct device *dev);
+int RTK_xhci_plat_resume(struct device *dev)
+{
+	return xhci_plat_resume(dev);
+}
+#endif
+
 static int __maybe_unused xhci_plat_resume(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 	int ret;
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+//	if (RTK_PM_STATE == PM_SUSPEND_STANDBY) {
+//		dev_info(dev, "[USB] %s Idle mode\n", __func__);
+//		return 0;
+//	} else
+		dev_info(dev,  "[USB] %s Suspend mode --> xhci_resume\n", __func__);
+#endif
+
 	ret = xhci_priv_resume_quirk(hcd);
 	if (ret)
 		return ret;
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index fd84ca753..48c8354c5 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -18,6 +18,10 @@
 #include <linux/dmi.h>
 #include <linux/dma-mapping.h>
 
+#ifdef CONFIG_USB_PATCH_ON_RTK
+#include <linux/usb/quirks.h>
+#endif
+
 #include "xhci.h"
 #include "xhci-trace.h"
 #include "xhci-mtk.h"
@@ -696,6 +700,10 @@ int xhci_run(struct usb_hcd *hcd)
 
 	xhci_debugfs_init(xhci);
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+	create_xhci_debug_files(xhci);
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xhci_run);
@@ -714,6 +722,10 @@ static void xhci_stop(struct usb_hcd *hcd)
 	u32 temp;
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+	remove_xhci_debug_files(xhci);
+#endif
+
 	mutex_lock(&xhci->mutex);
 
 	/* Only halt host and free memory after both hcds are removed */
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 3190fd570..063a16fcf 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1911,6 +1911,11 @@ struct xhci_hcd {
 	struct dentry		*debugfs_slots;
 	struct list_head	regset_list;
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+	/* debug files */
+	struct dentry           *debug_dir;
+#endif
+
 	void			*dbc;
 	/* platform-specific data -- must come last */
 	unsigned long		priv[] __aligned(sizeof(s64));
@@ -2760,4 +2765,10 @@ static inline const char *xhci_decode_ep_context(u32 info, u32 info2, u64 deq,
 	return str;
 }
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+void create_xhci_debug_files(struct xhci_hcd *xhci);
+
+void remove_xhci_debug_files(struct xhci_hcd *xhci);
+#endif //CONFIG_DYNAMIC_DEBUG
+
 #endif /* __LINUX_XHCI_HCD_H */
diff --git a/include/soc/realtek/power-control.h b/include/soc/realtek/power-control.h
new file mode 100644
index 000000000..616e55674
--- /dev/null
+++ b/include/soc/realtek/power-control.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Realtek Semiconductor Corporation
+ * Copyright (C) 2016 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SOC_REALTEK_POWER_CONTROL_H
+#define SOC_REALTEK_POWER_CONTROL_H
+
+struct device_node;
+struct power_control;
+
+#include <linux/types.h>
+
+#ifdef CONFIG_POWER_CONTROL
+const char *power_control_get_name(struct power_control *pctrl);
+int power_control_power_on(struct power_control *pctrl);
+int power_control_power_off(struct power_control *pctrl);
+int power_control_is_powered_on(struct power_control *pctrl);
+struct power_control *power_control_get(const char *name);
+struct power_control *of_power_control_get_by_index(struct device_node *node,
+	int index);
+struct power_control *of_power_control_get(struct device_node *node,
+	const char *id);
+bool power_control_is_match(const struct power_control *a,
+	const struct power_control *b);
+int power_control_register(struct power_control *pctrl);
+void power_control_unregister(struct power_control *pctrl);
+#else
+
+static inline
+const char *power_control_get_name(struct power_control *pctrl)
+{
+	return NULL;
+}
+
+static inline
+int power_control_power_on(struct power_control *pctrl)
+{
+	return -EINVAL;
+}
+
+static inline int power_control_power_off(struct power_control *pctrl)
+{
+	return -EINVAL;
+}
+
+static inline int power_control_is_powered_on(struct power_control *pctrl)
+{
+	return -EINVAL;
+}
+
+static inline struct power_control *power_control_get(const char *name)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static inline struct power_control *of_power_control_get_by_index(
+	struct device_node *node, int index)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static inline struct power_control *of_power_control_get(
+	struct device_node *node, const char *id)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static inline bool power_control_is_match(const struct power_control *a,
+	const struct power_control *b)
+{
+	return true;
+}
+
+static inline int power_control_register(struct power_control *pctrl)
+{
+	return -EINVAL;
+}
+
+static inline void power_control_unregister(struct power_control *pctrl)
+{
+}
+
+#endif
+
+static inline int power_control_enable_hw_pm(struct power_control *pctrl)
+{
+	return power_control_power_off(pctrl);
+}
+
+static inline int power_control_disable_hw_pm(struct power_control *pctrl)
+{
+	return power_control_power_on(pctrl);
+}
+
+#endif
diff --git a/include/soc/realtek/reset-helper.h b/include/soc/realtek/reset-helper.h
new file mode 100644
index 000000000..34a77d91c
--- /dev/null
+++ b/include/soc/realtek/reset-helper.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016-2017 Realtek Semiconductor Corporation
+ * Copyright (C) 2016-2017 Cheng-Yu Lee <cylee12@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_RESET_HELPER_H_
+#define _LINUX_RESET_HELPER_H_
+
+#ifdef CONFIG_RESET_CONTROLLER
+
+struct reset_control;
+
+struct reset_control * rstc_get(const char * name);
+
+int rstc_add(struct reset_control *rstc, const char * name);
+
+#else
+
+static inline struct reset_control * rstc_get(const char * name)
+{
+	WARN_ON(1);
+	return NULL;
+}
+
+
+static inline int rstc_add(struct reset_control *rstc, const char * name)
+{
+	WARN_ON(1);
+	return 0;
+}
+
+#endif
+
+#endif /* _LINUX_RESET_HELPER_H_ */
diff --git a/include/soc/realtek/rtk_usb.h b/include/soc/realtek/rtk_usb.h
new file mode 100644
index 000000000..7b1b3abc8
--- /dev/null
+++ b/include/soc/realtek/rtk_usb.h
@@ -0,0 +1,40 @@
+/*
+ * rtk_usb.h
+ *
+ * Copyright (c) 2017 Realtek Semiconductor Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __RTK_USB_H_INCLUDED_
+#define __RTK_USB_H_INCLUDED_
+
+struct device_node;
+struct rtk_usb;
+
+enum usb_port_num {
+	USB_PORT_0 = 0,
+	USB_PORT_1 = 1,
+	USB_PORT_2 = 2,
+	USB_PORT_3 = 3,
+};
+
+struct rtk_usb *rtk_usb_soc_init(struct device_node *node);
+
+int rtk_usb_soc_free(struct rtk_usb **rtk_usb);
+
+int rtk_usb_port_suspend_resume(struct rtk_usb *rtk_usb,
+	    enum usb_port_num port_num, bool is_suspend);
+
+int rtk_usb_set_hw_l4icg_on_off(struct rtk_usb *rtk_usb,
+	    enum usb_port_num port_num, bool on);
+
+int rtk_usb_iso_power_ctrl(struct rtk_usb *rtk_usb,
+	    bool power_on);
+
+void rtk_usb_set_charger_power(struct rtk_usb *rtk_usb, unsigned int val);
+
+#endif // __RTK_USB_H_INCLUDED_
-- 
2.25.1

